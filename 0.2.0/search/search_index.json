{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"HoloConf <p>       Multi-language hierarchical configuration library     </p> <p> </p>"},{"location":"#overview","title":"Overview","text":"<p>HoloConf provides a consistent, powerful configuration management experience across multiple programming languages. Write your configuration once in YAML or JSON, and access it seamlessly from Python, Rust, JavaScript, Go, and more.</p> Get Started API Reference"},{"location":"#features","title":"Features","text":"<ul> <li>Multi-language support - Rust core with native bindings for Python, JavaScript, Go, and more</li> <li>Interpolation - Reference environment variables, other config values, files, and HTTP endpoints</li> <li>Hierarchical merging - Combine multiple config files with predictable override behavior</li> <li>Schema validation - Validate configuration against JSON Schema</li> <li>Type coercion - Automatic type conversion based on schema definitions</li> <li>Lazy resolution - Values are resolved on access, not at parse time</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"PythonRustCLI <pre><code>from holoconf import Config\n\n# Load configuration\nconfig = Config.from_file(\"config.yaml\")\n\n# Access values with dot notation\nhost = config.get(\"database.host\")\nport = config.get(\"database.port\")\n\n# Environment variables are resolved automatically\n# database:\n#   host: ${env:DB_HOST,default=localhost}\n#   port: ${env:DB_PORT,default=5432}\n</code></pre> <pre><code>use holoconf::Config;\n\nfn main() -&gt; Result&lt;(), holoconf::Error&gt; {\n    // Load configuration\n    let config = Config::from_file(\"config.yaml\")?;\n\n    // Access values with dot notation\n    let host: String = config.get(\"database.host\")?;\n    let port: i64 = config.get(\"database.port\")?;\n\n    Ok(())\n}\n</code></pre> <pre><code># Get a specific value\nholoconf get config.yaml database.host\n\n# Dump resolved configuration\nholoconf dump config.yaml --resolve\n\n# Validate against a schema\nholoconf validate config.yaml --schema schema.json\n</code></pre>"},{"location":"#installation","title":"Installation","text":"PythonRustCLI <pre><code>pip install holoconf\n</code></pre> <pre><code># Cargo.toml\n[dependencies]\nholoconf = \"0.1\"\n</code></pre> <pre><code># Install via pip (includes CLI)\npip install holoconf\n\n# Or install the Rust binary\ncargo install holoconf-cli\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Getting Started - Installation and first configuration</li> <li>Interpolation - Learn about variable substitution</li> <li>Resolvers - Environment, file, HTTP, and self-reference resolvers</li> <li>API Reference - Detailed API documentation</li> </ul>"},{"location":"CONSTRAINTS/","title":"holoconf Constraints","text":"<p>This document captures constraints that must be respected when building holoconf.</p>"},{"location":"CONSTRAINTS/#design-constraints","title":"Design Constraints","text":""},{"location":"CONSTRAINTS/#c-1-omegaconf-style-resolver-syntax","title":"C-1: OmegaConf-Style Resolver Syntax","text":"<p>Must use OmegaConf-compatible interpolation syntax.</p> <ul> <li>Self-references: <code>${path.to.value}</code> (absolute) or <code>${.relative.path}</code> (relative)</li> <li>External resolvers: <code>${resolver:key}</code></li> <li>Examples: <code>${env:DB_HOST}</code>, <code>${ssm:/prod/password}</code>, <code>${defaults.port}</code></li> </ul> <p>Rationale: Familiar to OmegaConf users, clear distinction between self-refs and external resolvers.</p>"},{"location":"CONSTRAINTS/#c-2-native-custom-resolvers","title":"C-2: Native Custom Resolvers","text":"<p>Custom resolvers must be implementable in the user's native language (Python, JavaScript, etc.) without requiring Rust knowledge.</p> <p>Rationale: Low barrier for users to extend holoconf for their specific needs.</p>"},{"location":"CONSTRAINTS/#c-3-cross-language-behavioral-parity","title":"C-3: Cross-Language Behavioral Parity","text":"<p>All language implementations must behave identically for the same input.</p> <ul> <li>Same config files must produce same merged output</li> <li>Same resolver syntax must resolve identically</li> <li>Conformance test suite validates parity</li> </ul> <p>Rationale: Users should be able to switch languages without surprises.</p>"},{"location":"CONSTRAINTS/#c-4-language-agnostic-configuration-format","title":"C-4: Language-Agnostic Configuration Format","text":"<p>Configuration files must be language-agnostic (YAML/JSON).</p> <ul> <li>No language-specific constructs in config files</li> <li>Same config files work across all supported languages</li> </ul> <p>Rationale: Config files are often shared across services in different languages.</p>"},{"location":"CONSTRAINTS/#technical-constraints","title":"Technical Constraints","text":""},{"location":"CONSTRAINTS/#c-5-rust-core-implementation","title":"C-5: Rust Core Implementation","text":"<p>Core logic must be implemented in Rust with FFI bindings.</p> <p>Rationale: ADR-001 decision - ensures consistency and scales to many languages.</p>"},{"location":"CONSTRAINTS/#c-6-async-first-internal-architecture","title":"C-6: Async-First Internal Architecture","text":"<p>Internal architecture must support async execution for parallel resolver calls.</p> <p>Rationale: ADR-003 decision - required for performance with multiple external resolvers.</p>"},{"location":"CONSTRAINTS/#c-7-lazy-resolution","title":"C-7: Lazy Resolution","text":"<p>Resolver execution must be lazy (on-access) not eager (on-parse).</p> <p>Rationale: ADR-005 decision - avoids wasted work, enables fast startup.</p>"},{"location":"CONSTRAINTS/#operational-constraints","title":"Operational Constraints","text":""},{"location":"CONSTRAINTS/#c-8-no-secrets-in-config-files","title":"C-8: No Secrets in Config Files","text":"<p>Config files should reference secrets via resolvers, not contain them directly.</p> <ul> <li>Use <code>${ssm:/path}</code> or <code>${env:SECRET}</code> for secrets</li> <li>Config files can be committed to version control</li> </ul> <p>Rationale: Security best practice, enables GitOps workflows.</p>"},{"location":"CONSTRAINTS/#c-9-deterministic-merging","title":"C-9: Deterministic Merging","text":"<p>Config merging must be deterministic given the same inputs in the same order.</p> <p>Rationale: Reproducible deployments require predictable configuration.</p>"},{"location":"CONSTRAINTS/#constraint-traceability","title":"Constraint Traceability","text":"Constraint Related ADR C-1 ADR-002 C-2 ADR-002 C-3 ADR-001 C-4 - C-5 ADR-001 C-6 ADR-003 C-7 ADR-005 C-8 - C-9 ADR-004"},{"location":"PROBLEM_STATEMENT/","title":"HoloConf Problem Statement","text":"<p>HoloConf is an ecosystem for managing configuration of applications. It handles the complexities of merging hierarchical configuration options, using multiple sources.</p>"},{"location":"REQUIREMENTS/","title":"holoconf Requirements","text":"<p>This document captures the core requirements that drive holoconf development.</p>"},{"location":"REQUIREMENTS/#functional-requirements","title":"Functional Requirements","text":""},{"location":"REQUIREMENTS/#r-1-cross-language-compatibility","title":"R-1: Cross-Language Compatibility","text":"<p>holoconf must support multiple programming languages with consistent behavior.</p> <ul> <li>R-1.1: Python support (initial)</li> <li>R-1.2: JavaScript/Node.js support (initial)</li> <li>R-1.3: Go support (future)</li> <li>R-1.4: Java support (future)</li> <li>R-1.5: Rust support (future)</li> <li>R-1.6: C support (future)</li> </ul>"},{"location":"REQUIREMENTS/#r-2-hierarchical-configuration-merging","title":"R-2: Hierarchical Configuration Merging","text":"<p>holoconf must support loading and merging multiple configuration files in a defined hierarchy.</p> <ul> <li>R-2.1: Load multiple config files in priority order</li> <li>R-2.2: Deep merge dictionaries/objects</li> <li>R-2.3: Last-writer-wins for scalar values</li> <li>R-2.4: List replacement on merge</li> <li>R-2.5: Null values remove keys from merged result</li> </ul>"},{"location":"REQUIREMENTS/#r-3-config-interpolationresolution","title":"R-3: Config Interpolation/Resolution","text":"<p>holoconf must support referencing other configuration values within the config.</p> <ul> <li>R-3.1: Absolute references from document root: <code>${path.to.value}</code></li> <li>R-3.2: Relative references from current node: <code>${.sibling}</code>, <code>${..parent}</code></li> <li>R-3.3: Lazy resolution (resolve on access, not parse)</li> <li>R-3.4: Memoization (resolve each key exactly once)</li> </ul>"},{"location":"REQUIREMENTS/#r-4-custom-resolvers","title":"R-4: Custom Resolvers","text":"<p>holoconf must support resolving values from external sources.</p> <ul> <li>R-4.1: Built-in <code>env</code> resolver for environment variables</li> <li>R-4.2: Built-in self-reference resolver</li> <li>R-4.3: AWS resolvers: SSM, S3, CloudFormation outputs</li> <li>R-4.4: User-defined custom resolvers in native language</li> <li>R-4.5: Resolver syntax: <code>${resolver:key}</code></li> </ul>"},{"location":"REQUIREMENTS/#r-5-yaml-configuration-file-support","title":"R-5: YAML Configuration File Support","text":"<p>holoconf must support YAML as the primary configuration format.</p> <ul> <li>R-5.1: Parse standard YAML files</li> <li>R-5.2: Support interpolation syntax within YAML values</li> </ul>"},{"location":"REQUIREMENTS/#r-6-hierarchical-deployment-configuration","title":"R-6: Hierarchical Deployment Configuration","text":"<p>holoconf must support partition/region/account/deployment level config hierarchies.</p> <ul> <li>R-6.1: Define config loading order/hierarchy</li> <li>R-6.2: Override lower-priority configs with higher-priority ones</li> <li>R-6.3: Support environment-specific configurations</li> </ul>"},{"location":"REQUIREMENTS/#non-functional-requirements","title":"Non-Functional Requirements","text":""},{"location":"REQUIREMENTS/#nfr-1-performance","title":"NFR-1: Performance","text":"<ul> <li>NFR-1.1: Fast startup (no resolver calls at parse time)</li> <li>NFR-1.2: Parallel resolver execution for multiple external references</li> <li>NFR-1.3: Suitable for AWS Lambda cold start scenarios</li> </ul>"},{"location":"REQUIREMENTS/#nfr-2-platform-support","title":"NFR-2: Platform Support","text":"<ul> <li>NFR-2.1: x86_64 architecture support</li> <li>NFR-2.2: aarch64 (ARM64) architecture support</li> </ul>"},{"location":"REQUIREMENTS/#nfr-3-api-ergonomics","title":"NFR-3: API Ergonomics","text":"<ul> <li>NFR-3.1: Both sync and async APIs</li> <li>NFR-3.2: Language-idiomatic bindings</li> <li>NFR-3.3: Clear error messages</li> </ul>"},{"location":"REQUIREMENTS/#requirement-traceability","title":"Requirement Traceability","text":"Requirement ADR Feature Spec R-1 ADR-001 TBD R-2 ADR-004 TBD R-3 ADR-002, ADR-005 TBD R-4 ADR-002 TBD R-5 TBD (ADR-006 future) TBD R-6 ADR-004 TBD NFR-1 ADR-003, ADR-005 TBD NFR-2 ADR-001 TBD NFR-3 ADR-001, ADR-003 TBD"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#020-2026-01-17","title":"[0.2.0] - 2026-01-17","text":""},{"location":"changelog/#changed","title":"Changed","text":""},{"location":"changelog/#simplified-config-loading-api-breaking-change","title":"Simplified Config Loading API (Breaking Change)","text":"<ul> <li>Removed <code>FileSpec</code> from public API - <code>FileSpec</code> was a Rust-ism that leaked to Python; the concept is now internal</li> <li>Old: <code>FileSpec.required(\"path\")</code>, <code>FileSpec.optional(\"path\")</code></li> <li>New: <code>Config.load(\"path\")</code> for required, <code>Config.optional(\"path\")</code> for optional</li> <li>Removed <code>load_merged()</code> and <code>load_merged_with_specs()</code> - Use explicit load + merge pattern instead</li> <li>Old: <code>Config.load_merged([\"base.yaml\", \"override.yaml\"])</code></li> <li>New: <code>config = Config.load(\"base.yaml\"); config.merge(Config.load(\"override.yaml\"))</code></li> <li>Added <code>Config.optional(path)</code> - Returns empty Config if file doesn't exist (no error)</li> <li>Added <code>Config.required(path)</code> - Alias for <code>Config.load()</code> for symmetry with <code>optional()</code></li> <li>Updated <code>Config.load(path)</code> - Now returns a proper \"file not found\" error for missing files</li> </ul>"},{"location":"changelog/#resolver-syntax-breaking-change","title":"Resolver Syntax (Breaking Change)","text":"<ul> <li>Keyword-only syntax for default and sensitive options - Resolver options now use keyword argument syntax exclusively</li> <li>Old syntax: <code>${env:VAR,fallback_value}</code> (positional default)</li> <li>New syntax: <code>${env:VAR,default=fallback_value}</code> (keyword default)</li> <li>Sensitive flag: <code>${env:SECRET,sensitive=true}</code></li> <li>Both combined: <code>${env:VAR,default=fallback,sensitive=true}</code></li> <li>Framework-level default/sensitive handling - All resolvers now consistently support <code>default=</code> and <code>sensitive=</code> options</li> <li>Lazy evaluation: default values only resolved when primary resolver fails</li> <li>Works with any resolver: <code>${file:./config.yaml,default={}}</code>, <code>${http:...,default=fallback}</code></li> <li>Sensitive marking propagates correctly through resolution chain</li> </ul>"},{"location":"changelog/#added","title":"Added","text":""},{"location":"changelog/#http-resolver-tlsproxy-enhancements","title":"HTTP Resolver TLS/Proxy Enhancements","text":"<ul> <li>Proxy support - Configure HTTP/SOCKS proxies for HTTP resolver requests</li> <li><code>http_proxy=\"http://proxy:8080\"</code> or <code>http_proxy=\"socks5://proxy:1080\"</code></li> <li><code>http_proxy_from_env=True</code> to auto-detect from HTTP_PROXY/HTTPS_PROXY environment variables</li> <li>Per-request override: <code>${http:url,proxy=http://proxy:8080}</code></li> <li>Custom CA certificates - Use internal/corporate CAs or self-signed certificates</li> <li><code>http_ca_bundle=\"/path/to/ca.pem\"</code> - Replace default root certificates</li> <li><code>http_extra_ca_bundle=\"/path/to/extra.pem\"</code> - Add to default root certificates</li> <li>Per-request override: <code>${http:url,ca_bundle=/path}</code> or <code>${http:url,extra_ca_bundle=/path}</code></li> <li>Mutual TLS (mTLS) / Client certificates - Authenticate with client certificates</li> <li><code>http_client_cert=\"/path/to/cert.pem\"</code> - Client certificate (PEM or P12/PFX)</li> <li><code>http_client_key=\"/path/to/key.pem\"</code> - Private key (not needed for P12/PFX)</li> <li><code>http_client_key_password=\"secret\"</code> - Password for encrypted keys or P12/PFX</li> <li>Supports: unencrypted PEM, encrypted PKCS#8 PEM, P12/PFX bundles</li> <li>Per-request override: <code>${http:url,client_cert=/path,client_key=/path,key_password=secret}</code></li> <li>TLS verification bypass - For development with self-signed certs (DANGEROUS)</li> <li><code>http_insecure=True</code> - Skip all TLS certificate verification</li> <li>Per-request: <code>${http:url,insecure=true}</code></li> <li>WARNING: Never use in production - exposes to MITM attacks</li> <li>FIPS-compliant TLS - Uses rustls with aws-lc-rs crypto backend</li> </ul>"},{"location":"changelog/#glob-pattern-support","title":"Glob Pattern Support","text":"<ul> <li>Glob patterns in <code>Config.load()</code> and <code>Config.optional()</code> - Load and merge multiple files matching a pattern</li> <li><code>Config.load(\"config/*.yaml\")</code> - Load all matching files, error if none match</li> <li><code>Config.optional(\"config/*.yaml\")</code> - Load all matching files, empty config if none match</li> <li>Supported patterns: <code>*</code> (any chars), <code>**</code> (recursive), <code>?</code> (single char), <code>[abc]</code> (char class)</li> <li>Alphabetical merge order - Files are sorted before merging, so <code>00-base.yaml</code> loads before <code>99-local.yaml</code></li> </ul>"},{"location":"changelog/#schema-default-values","title":"Schema Default Values","text":"<ul> <li>Schema defaults for missing paths - When a schema is attached to a config, accessing a missing path returns the schema default instead of <code>PathNotFoundError</code></li> <li><code>Config.load(\"config.yaml\", schema=\"schema.yaml\")</code> - Load with schema attached</li> <li><code>config.set_schema(schema)</code> - Attach schema to existing config</li> <li><code>config.get_schema()</code> - Retrieve attached schema</li> <li>Null-aware default lookup - If a config value is <code>null</code> and the schema doesn't allow <code>null</code>, the schema default is used</li> <li>validate() uses attached schema - Call <code>config.validate()</code> with no args to use the attached schema</li> <li>CLI --schema flag - <code>holoconf get</code> and <code>holoconf dump</code> now accept <code>--schema</code> for default values</li> <li>Enhanced validate output - <code>holoconf validate</code> now shows all validation errors with paths</li> </ul>"},{"location":"changelog/#http-resolver","title":"HTTP Resolver","text":"<ul> <li>Full HTTP resolver implementation - Fetch configuration from remote URLs</li> <li>Disabled by default for security - enable with <code>allow_http=True</code></li> <li>URL allowlist support for restricting which URLs can be fetched</li> <li>Parse modes: <code>auto</code>, <code>yaml</code>, <code>json</code>, <code>text</code>, <code>binary</code></li> <li>Configurable timeout via <code>timeout=&lt;seconds&gt;</code> parameter</li> <li>Custom header support via <code>header=Name:Value</code> parameter</li> <li>Auto-detection from Content-Type and URL extension</li> <li>Security controls:</li> <li><code>allow_http</code> option to explicitly enable HTTP resolver</li> <li><code>http_allowlist</code> option to restrict accessible URLs with glob patterns</li> <li>Example usage:   <pre><code>config: ${http:https://config.example.com/settings.yaml}\napi_key: ${http:https://api.example.com/key,header=Authorization:Bearer token}\n</code></pre></li> </ul>"},{"location":"changelog/#custom-resolver-registration","title":"Custom Resolver Registration","text":"<ul> <li>Global resolver registry - Register resolvers once, use everywhere</li> <li><code>holoconf.register_resolver(name, func, force=False)</code> - Python API</li> <li><code>register_global(resolver, force)</code> - Rust API</li> <li>Async resolver support - Async functions automatically awaited via <code>asyncio.run()</code></li> <li><code>async def my_resolver(key, **kwargs): return await fetch(key)</code></li> <li>Return types - Resolvers can return scalars, lists, dicts, or <code>ResolvedValue</code> for sensitive data</li> <li>KeyError for default handling - Custom resolvers raise <code>KeyError</code> to trigger framework default</li> <li>Plugin discovery - Automatic discovery of installed resolver plugins</li> <li><code>holoconf.discover_plugins()</code> - Load all plugins via entry points</li> <li>Entry point group: <code>holoconf.resolvers</code></li> <li>holoconf-aws package - AWS resolvers for SSM, CloudFormation, and S3</li> <li>Rust crate: <code>holoconf-aws</code> with SSM, CFN, and S3 resolvers</li> <li>Python package: <code>holoconf-aws</code> with auto-discovery via entry points</li> <li>SSM Parameter Store resolver (<code>ssm</code>): Fetch parameters from AWS Systems Manager<ul> <li>Automatic SecureString sensitivity detection</li> <li>StringList to array conversion</li> <li>Region/profile per-parameter overrides</li> </ul> </li> <li>CloudFormation resolver (<code>cfn</code>): Fetch stack outputs<ul> <li>Syntax: <code>${cfn:stack-name/OutputKey}</code></li> <li>Region/profile overrides</li> </ul> </li> <li>S3 resolver (<code>s3</code>): Fetch and parse S3 objects<ul> <li>Syntax: <code>${s3:bucket/key}</code></li> <li>Parse modes: <code>auto</code>, <code>yaml</code>, <code>json</code>, <code>text</code>, <code>binary</code></li> <li>Auto-detection from file extension and Content-Type</li> <li>Region/profile overrides</li> </ul> </li> </ul>"},{"location":"changelog/#optional-file-support","title":"Optional File Support","text":"<ul> <li>Optional files in config loading - Load files that can be missing without causing errors</li> <li><code>Config.load(path)</code> / <code>Config.required(path)</code> - File must exist (error if missing)</li> <li><code>Config.optional(path)</code> - Returns empty Config if file doesn't exist</li> <li>Use <code>config.merge(other)</code> to combine multiple configs</li> <li>Common use case: local developer overrides that aren't committed to version control</li> <li>Example pattern:   <pre><code>config = Config.load(\"base.yaml\")\nlocal = Config.optional(\"local.yaml\")  # Empty if missing\nconfig.merge(local)\n</code></pre></li> <li>CLI <code>--ignore-missing</code> flag - Skip missing files when loading multiple config files</li> <li><code>holoconf dump --ignore-missing base.yaml local.yaml</code> - Works even if <code>local.yaml</code> doesn't exist</li> <li>At least one file must load successfully; fails if all files are missing</li> <li>Available on: <code>dump</code>, <code>get</code>, <code>validate</code>, <code>check</code> commands</li> </ul>"},{"location":"changelog/#source-tracking","title":"Source Tracking","text":"<ul> <li>File-level source tracking for merged configurations - track which file each value came from</li> <li><code>config.get_source(\"path.to.value\")</code> - Returns the filename that provided this value</li> <li><code>config.dump_sources()</code> - Returns a map of all config paths to their source filenames</li> <li>Always enabled with low overhead (no opt-in required)</li> <li>CLI <code>--sources</code> flag for <code>holoconf dump</code> - Output source files instead of values</li> <li><code>holoconf dump --sources base.yaml override.yaml</code> - Shows which file each value came from</li> <li>Supports both text and JSON output formats</li> </ul>"},{"location":"changelog/#cli","title":"CLI","text":"<ul> <li><code>holoconf schema template</code> - Generate a YAML config template from a JSON Schema with defaults and required field markers</li> </ul>"},{"location":"changelog/#file-resolver","title":"File Resolver","text":"<ul> <li>Encoding options for the file resolver:</li> <li><code>encoding=utf-8</code> (default) - Read file as UTF-8 text</li> <li><code>encoding=ascii</code> - Read file as ASCII, stripping non-ASCII characters</li> <li><code>encoding=base64</code> - Read file as binary and return base64-encoded string</li> <li><code>encoding=binary</code> - Read file as binary and return raw bytes (<code>Value::Bytes</code>)</li> </ul>"},{"location":"changelog/#value-system","title":"Value System","text":"<ul> <li>Added <code>Value::Bytes</code> variant for native binary data support</li> <li>Serializes to base64 in YAML/JSON output</li> <li>Returns native Python <code>bytes</code> in <code>to_dict()</code></li> <li>Accessible via <code>value.is_bytes()</code> and <code>value.as_bytes()</code> in Rust</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Circular reference detection - Fixed a critical bug where transitive circular references (e.g., A\u2192B\u2192C\u2192A) caused a stack overflow/segfault instead of returning a proper error message. The resolution now correctly tracks the full resolution stack and detects cycles.</li> </ul>"},{"location":"changelog/#tests","title":"Tests","text":"<ul> <li>Added unit tests for source tracking (5 tests covering merged configs, single file, null removal, and array replacement)</li> <li>Added unit tests for circular reference detection (4 tests covering direct, chain, self, and nested cycles)</li> <li>Added unit tests for file resolver encoding options (4 tests)</li> <li>Added unit tests for boolean coercion edge cases (case-insensitivity and invalid value rejection)</li> <li>Added acceptance tests for file resolver encoding (3 tests)</li> <li>Added acceptance test for sensitivity inheritance via self-references</li> <li>Re-enabled previously disabled circular reference acceptance tests (2 tests)</li> <li>Added acceptance tests for optional file support (10 tests covering missing files, merge behavior, deep merge)</li> </ul>"},{"location":"changelog/#013-2026-01-09","title":"[0.1.3] - 2026-01-09","text":"<p>No change, debugging release process</p>"},{"location":"changelog/#012-2026-01-08","title":"[0.1.2] - 2026-01-08","text":"<p>No change, debugging release process</p>"},{"location":"changelog/#added_1","title":"Added","text":""},{"location":"changelog/#configuration-loading-parsing","title":"Configuration Loading &amp; Parsing","text":"<ul> <li>Load configuration from YAML and JSON files with automatic format detection</li> <li>Parse configuration into a tree structure supporting scalars (null, bool, int, float, string) and collections (sequences, mappings)</li> <li>Path-based value access using dot notation (<code>database.host</code>) and array indexing (<code>servers[0].name</code>)</li> <li>Type-safe accessors: <code>get_string()</code>, <code>get_i64()</code>, <code>get_f64()</code>, <code>get_bool()</code></li> <li>Load and deep-merge multiple configuration files with <code>load_merged()</code></li> </ul>"},{"location":"changelog/#resolver-system","title":"Resolver System","text":"<ul> <li>Environment Variable Resolver (<code>env</code>): Access environment variables with optional defaults</li> <li>Syntax: <code>${env:VAR_NAME}</code> or <code>${env:VAR_NAME,default_value}</code></li> <li>Sensitivity marking: <code>${env:SECRET,sensitive=true}</code> for automatic redaction</li> <li>Self-Reference Resolver: Reference other values within the same configuration</li> <li>Absolute paths: <code>${path.to.value}</code></li> <li>Relative paths: <code>${.sibling}</code> or <code>${..parent.value}</code></li> <li>Array access: <code>${servers[0].host}</code></li> <li>Circular reference detection with helpful error messages</li> <li>File Resolver (<code>file</code>): Include content from external files</li> <li>Syntax: <code>${file:./path/to/config.yaml}</code></li> <li>Automatic format detection (YAML, JSON, or plain text)</li> <li>Explicit parse mode: <code>${file:./data.json,parse=json}</code></li> <li>HTTP Resolver (<code>http</code>): Fetch configuration from remote URLs (disabled by default for security)</li> <li>Requires explicit <code>allow_http=true</code> option</li> <li>URL allowlist support with glob patterns</li> <li>Custom Resolvers: Register custom resolver functions via the resolver registry</li> </ul>"},{"location":"changelog/#interpolation-templating","title":"Interpolation &amp; Templating","text":"<ul> <li>String interpolation with resolver calls: <code>${resolver:arg1,arg2,key=value}</code></li> <li>Nested interpolations: <code>${env:VAR,${env:FALLBACK,default}}</code></li> <li>String concatenation: <code>prefix_${env:VAR}_suffix</code></li> <li>Escape sequences: <code>\\${literal}</code> prevents interpolation</li> <li>Keyword argument support for resolver options</li> </ul>"},{"location":"changelog/#schema-validation","title":"Schema Validation","text":"<ul> <li>JSON Schema validation (Draft 2020-12 compatible)</li> <li>Two-phase validation:</li> <li>Structural validation: validates raw config, allows interpolation placeholders</li> <li>Type/value validation: validates fully resolved values</li> <li>Load schemas from YAML or JSON files</li> <li>Collect all validation errors (not just first failure)</li> <li>Support for: <code>type</code>, <code>required</code>, <code>properties</code>, <code>enum</code>, <code>pattern</code>, <code>minimum</code>, <code>maximum</code>, <code>minLength</code>, <code>maxLength</code></li> </ul>"},{"location":"changelog/#configuration-merging","title":"Configuration Merging","text":"<ul> <li>Deep merge multiple configuration files</li> <li>Merge semantics:</li> <li>Mappings: recursively merged (deep merge)</li> <li>Scalars: last-writer-wins</li> <li>Arrays: replaced entirely (not concatenated)</li> <li>Null values: remove keys from result</li> </ul>"},{"location":"changelog/#serialization-export","title":"Serialization &amp; Export","text":"<ul> <li>Export to YAML: <code>to_yaml()</code>, <code>to_yaml_raw()</code>, <code>to_yaml_redacted()</code></li> <li>Export to JSON: <code>to_json()</code>, <code>to_json_raw()</code>, <code>to_json_redacted()</code></li> <li>Export to native values: <code>to_value()</code>, <code>to_dict()</code> (Python)</li> <li>Automatic redaction of sensitive values to <code>[REDACTED]</code></li> </ul>"},{"location":"changelog/#value-resolution-caching","title":"Value Resolution &amp; Caching","text":"<ul> <li>Lazy resolution: values only resolved when accessed</li> <li>Automatic caching of resolved values for performance</li> <li>Resolution stack tracking for circular reference detection</li> <li>Cache clearing on merge operations</li> </ul>"},{"location":"changelog/#cli-holoconf","title":"CLI (<code>holoconf</code>)","text":"<ul> <li><code>holoconf validate</code> - Validate configuration against a schema</li> <li><code>holoconf dump</code> - Export configuration in YAML or JSON format</li> <li><code>holoconf get</code> - Retrieve specific values by path</li> <li><code>holoconf check</code> - Quick syntax validation</li> <li>Output formats: text, JSON, YAML</li> <li>Safe redaction of sensitive values by default</li> </ul>"},{"location":"changelog/#python-bindings","title":"Python Bindings","text":"<ul> <li>Full Python API via PyO3 bindings</li> <li><code>Config.loads()</code>, <code>Config.load()</code>, <code>Config.load_merged()</code></li> <li>Type-safe accessors: <code>get_string()</code>, <code>get_int()</code>, <code>get_float()</code>, <code>get_bool()</code></li> <li>Schema validation: <code>config.validate(schema)</code></li> <li>Export methods: <code>to_yaml()</code>, <code>to_json()</code>, <code>to_dict()</code></li> <li>Python exception hierarchy: <code>HoloconfError</code>, <code>ParseError</code>, <code>ValidationError</code>, <code>ResolverError</code>, <code>PathNotFoundError</code>, <code>CircularReferenceError</code>, <code>TypeCoercionError</code></li> </ul>"},{"location":"changelog/#type-coercion","title":"Type Coercion","text":"<ul> <li>Strict boolean coercion: only <code>\"true\"</code> and <code>\"false\"</code> strings convert to boolean</li> <li>Flexible numeric coercion: string numbers convert to int/float</li> <li>String fallback: any value can be converted to string representation</li> </ul>"},{"location":"changelog/#security-features","title":"Security Features","text":"<ul> <li>HTTP resolver disabled by default with explicit opt-in</li> <li>URL allowlist with glob pattern matching</li> <li>Sensitive value marking and automatic redaction</li> <li>Configurable file roots for sandboxed file access</li> </ul>"},{"location":"changelog/#thread-safety","title":"Thread Safety","text":"<ul> <li>Thread-safe resolution cache with <code>Arc&lt;RwLock&lt;&gt;&gt;</code></li> <li>All resolvers are <code>Send + Sync</code> compatible</li> <li>Safe for concurrent access in multi-threaded applications</li> </ul>"},{"location":"changelog/#error-handling","title":"Error Handling","text":"<ul> <li>Structured error types with context and source location</li> <li>Error categories: Parse, Resolver, Validation, PathNotFound, CircularReference, TypeCoercion, IO</li> <li>Actionable error messages with suggestions</li> <li>Full error context preservation</li> </ul>"},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>Comprehensive documentation site with MkDocs Material</li> <li>Architecture Decision Records (ADRs) for design decisions</li> <li>Feature specifications for planned features</li> <li>API reference documentation</li> <li>Quick start guide and examples</li> </ul>"},{"location":"changelog/#010-unreleased","title":"0.1.0 - Unreleased","text":"<p>Initial release with core functionality.</p>"},{"location":"adr/","title":"Architecture Decision Records","text":"<p>This directory contains Architecture Decision Records (ADRs) for the HoloConf project.</p>"},{"location":"adr/#what-is-an-adr","title":"What is an ADR?","text":"<p>An ADR is a document that captures an important architectural decision made along with its context and consequences. ADRs help us:</p> <ul> <li>Document the reasoning behind decisions</li> <li>Provide context for future developers</li> <li>Track the evolution of the architecture</li> <li>Enable informed discussions about changes</li> </ul>"},{"location":"adr/#adr-status","title":"ADR Status","text":"<ul> <li>Proposed - Under discussion, not yet accepted</li> <li>Accepted - Approved and in effect</li> <li>Superseded - Replaced by a newer ADR</li> <li>Deprecated - No longer relevant</li> </ul>"},{"location":"adr/#architecture-decisions","title":"Architecture Decisions","text":"ADR Title Status ADR-001 Multi-Language Architecture Accepted ADR-002 Resolver Architecture Accepted ADR-003 Async Execution Model Accepted ADR-004 Config Merging Semantics Accepted ADR-005 Resolver Timing (Lazy Resolution) Accepted ADR-006 Repository and Package Structure Accepted ADR-007 Schema and Validation Accepted ADR-008 Error Handling Strategy Accepted ADR-009 Serialization and Export Accepted ADR-010 Thread Safety and Concurrency Accepted ADR-011 Interpolation Syntax Accepted ADR-012 Type Coercion Accepted ADR-013 Testing Architecture Accepted ADR-014 Code Quality Tooling Accepted ADR-015 Documentation Site Accepted ADR-016 PyO3 API Documentation Accepted ADR-017 Release Process Accepted"},{"location":"adr/#creating-a-new-adr","title":"Creating a New ADR","text":"<ol> <li>Copy <code>template.md</code> to <code>ADR-NNN-short-title.md</code></li> <li>Fill in all sections</li> <li>Submit for review</li> <li>Update this index</li> </ol>"},{"location":"adr/#template","title":"Template","text":"<p>See template.md for the ADR template.</p>"},{"location":"adr/ADR-001-multi-language-architecture/","title":"ADR-001: Multi-Language Architecture","text":""},{"location":"adr/ADR-001-multi-language-architecture/#status","title":"Status","text":"<ul> <li>Proposed by: Ryan on 2026-01-07</li> <li>Accepted on: 2026-01-07</li> </ul>"},{"location":"adr/ADR-001-multi-language-architecture/#context","title":"Context","text":"<p>holoconf needs to support multiple programming languages (Python, JavaScript initially; Go, Java, Rust, C later). We need an architecture that:</p> <ul> <li>Ensures consistent behavior across all languages</li> <li>Scales to 6+ languages without re-architecture</li> <li>Supports both x86_64 and aarch64 platforms</li> </ul>"},{"location":"adr/ADR-001-multi-language-architecture/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/ADR-001-multi-language-architecture/#alternative-1-schema-first-json-schema-codegen","title":"Alternative 1: Schema-First (JSON Schema + codegen)","text":"<p>Generate language-specific code from a schema definition.</p> <ul> <li>Pros: Strong typing, schema serves as documentation</li> <li>Cons: Cannot express dynamic resolver behavior, limited runtime flexibility</li> <li>Rejected: Resolvers are inherently runtime/dynamic</li> </ul>"},{"location":"adr/ADR-001-multi-language-architecture/#alternative-2-pure-specification-independent-implementations","title":"Alternative 2: Pure Specification (independent implementations)","text":"<p>Define a spec and implement it independently in each language.</p> <ul> <li>Pros: Language-idiomatic APIs, no FFI complexity</li> <li>Cons: N implementations to maintain, drift risk, duplicated effort scales with languages</li> <li>Rejected: Does not scale to 6+ languages</li> </ul>"},{"location":"adr/ADR-001-multi-language-architecture/#alternative-3-hybrid-specification-spec-optional-shared-components","title":"Alternative 3: Hybrid Specification (spec + optional shared components)","text":"<p>Define a spec with optional shared components that languages can adopt.</p> <ul> <li>Pros: Flexibility, can start simple</li> <li>Cons: Still requires reimplementation when adding languages</li> <li>Rejected: Re-architecture cliff when adding language #3</li> </ul>"},{"location":"adr/ADR-001-multi-language-architecture/#decision","title":"Decision","text":"<p>Rust Core with Language Bindings</p> <p>Implement core configuration logic in Rust with FFI bindings for each target language:</p> <ul> <li>Rust Core (holoconf-core): YAML/JSON parsing, hierarchical merging, interpolation syntax parsing, resolver registry &amp; dispatch</li> <li>Language Bindings: PyO3 (Python), NAPI-RS (JavaScript/Node), cgo (Go), JNI (Java), native (Rust), C headers (C)</li> </ul>"},{"location":"adr/ADR-001-multi-language-architecture/#design","title":"Design","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502              holoconf-core (Rust)                   \u2502\n\u2502  - YAML/JSON parsing                                \u2502\n\u2502  - Hierarchical merge algorithm                     \u2502\n\u2502  - Interpolation syntax parsing ${...}              \u2502\n\u2502  - Resolver registry &amp; dispatch                     \u2502\n\u2502  - Built-in resolvers: env, self-reference          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                         \u2502\n              FFI Bindings (per language)\n                         \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u25bc                    \u25bc                    \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Python  \u2502        \u2502   JS    \u2502         \u2502  Future \u2502\n\u2502 (PyO3)  \u2502        \u2502(NAPI-RS)\u2502         \u2502Languages\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"adr/ADR-001-multi-language-architecture/#rationale","title":"Rationale","text":"<ul> <li>Single implementation guarantees behavioral consistency - All languages use the same parsing, merging, and resolution logic</li> <li>Adding new language = write bindings, not reimplement core - Dramatically reduces effort to add new language support</li> <li>Rust compiles to all target platforms - x86_64, aarch64 supported out of the box</li> <li>WASM compilation possible - Browser support can be added later</li> </ul>"},{"location":"adr/ADR-001-multi-language-architecture/#error-handling","title":"Error Handling","text":"<p>Rust <code>Result&lt;T, E&gt;</code> types are mapped to native exceptions/errors in each language:</p> <pre><code># Python\ntry:\n    config = holoconf.load(\"config.yaml\")\nexcept holoconf.ParseError as e:\n    print(f\"Failed to parse: {e}\")\nexcept holoconf.ResolverError as e:\n    print(f\"Resolver failed: {e}\")\n</code></pre> <pre><code>// JavaScript\ntry {\n    const config = await holoconf.load(\"config.yaml\");\n} catch (e) {\n    if (e instanceof holoconf.ParseError) { ... }\n}\n</code></pre>"},{"location":"adr/ADR-001-multi-language-architecture/#memory-management","title":"Memory Management","text":"<p>Hybrid approach - Config wrapper with copy-on-access for scalars:</p> <ul> <li>Python/JS <code>Config</code> object holds an opaque reference to Rust-owned config data</li> <li>Accessing nested paths (e.g., <code>config.database</code>) returns another wrapper (no copy)</li> <li>Accessing scalar values (strings, numbers, booleans) copies the resolved value to native types</li> <li>Lazy resolution (ADR-005) happens in Rust; only resolved values cross the FFI boundary</li> </ul> <p>This approach: - Works naturally with lazy resolution (unresolved values stay in Rust) - Is memory efficient (large configs aren't duplicated) - Returns native types where it matters (<code>config.database.host</code> returns a native string)</p>"},{"location":"adr/ADR-001-multi-language-architecture/#crate-structure","title":"Crate Structure","text":"<p>See ADR-006 for repository and package structure.</p>"},{"location":"adr/ADR-001-multi-language-architecture/#trade-offs-accepted","title":"Trade-offs Accepted","text":"<ul> <li>Rust expertise required for core development in exchange for single source of truth</li> <li>FFI boundaries add complexity in exchange for guaranteed consistency</li> <li>Language bindings must be maintained per-language in exchange for simpler than full reimplementation</li> </ul>"},{"location":"adr/ADR-001-multi-language-architecture/#migration","title":"Migration","text":"<p>N/A - This is the initial architecture decision.</p>"},{"location":"adr/ADR-001-multi-language-architecture/#consequences","title":"Consequences","text":"<ul> <li>Positive: Consistent behavior across all languages, reduced maintenance burden, scales to many languages</li> <li>Negative: Requires Rust expertise, FFI debugging can be challenging</li> <li>Neutral: Language-specific idioms may need adaptation to fit the binding model</li> </ul>"},{"location":"adr/ADR-002-resolver-architecture/","title":"ADR-002: Resolver Architecture","text":""},{"location":"adr/ADR-002-resolver-architecture/#status","title":"Status","text":"<ul> <li>Proposed by: Ryan on 2026-01-07</li> <li>Accepted on: 2026-01-07</li> </ul>"},{"location":"adr/ADR-002-resolver-architecture/#context","title":"Context","text":"<p>holoconf needs to resolve configuration values from various sources:</p> <ul> <li>Environment variables</li> <li>Self-references (other config values)</li> <li>External services: AWS SSM, S3, CloudFormation outputs</li> <li>Future: Vault, GCP Secret Manager, Azure Key Vault, etc.</li> </ul> <p>We need an architecture that:</p> <ul> <li>Provides consistent resolver behavior across languages</li> <li>Allows users to write custom resolvers without learning Rust</li> <li>Keeps binary size manageable (don't bundle unused resolvers)</li> </ul>"},{"location":"adr/ADR-002-resolver-architecture/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/ADR-002-resolver-architecture/#alternative-1-all-native-resolvers-no-rust-resolver-packages","title":"Alternative 1: All Native Resolvers (no Rust resolver packages)","text":"<p>Implement all resolvers in each language's native SDK.</p> <ul> <li>Pros: Full native SDK access, no FFI for resolvers</li> <li>Cons: Must reimplement SSM/S3/etc. for each language, inconsistent behavior risk</li> <li>Rejected: Defeats purpose of Rust core</li> </ul>"},{"location":"adr/ADR-002-resolver-architecture/#alternative-2-rust-only-resolvers-no-native-callbacks","title":"Alternative 2: Rust-Only Resolvers (no native callbacks)","text":"<p>All resolvers must be written in Rust.</p> <ul> <li>Pros: Maximum consistency, simpler FFI</li> <li>Cons: Users must write Rust to add custom resolvers, high barrier</li> <li>Rejected: Too restrictive for users</li> </ul>"},{"location":"adr/ADR-002-resolver-architecture/#alternative-3-binary-plugin-system-dynamic-library-loading","title":"Alternative 3: Binary Plugin System (dynamic library loading)","text":"<p>Resolvers distributed as platform-specific binary plugins (<code>.so</code>, <code>.dll</code>, <code>.dylib</code>) that holoconf-core discovers and loads at runtime from a plugin directory.</p> <ul> <li>Pros: Language-agnostic plugins, maximum isolation</li> <li>Cons: Complex ABI stability requirements, platform-specific binaries, security concerns with loading arbitrary shared libraries, distribution complexity</li> <li>Rejected: Over-engineering; the native callback mechanism provides plugin-like extensibility without binary distribution challenges</li> </ul>"},{"location":"adr/ADR-002-resolver-architecture/#decision","title":"Decision","text":"<p>Hybrid - Rust Resolver Packages + Native Custom Resolver Callbacks</p> <p>Built-in Resolvers (Rust packages):</p> <ul> <li><code>holoconf-core</code>: env, self-reference resolvers</li> <li><code>holoconf-aws</code>: SSM, S3, CloudFormation (uses aws-sdk-rust)</li> <li><code>holoconf-gcp</code>: Secret Manager, GCS (future)</li> <li><code>holoconf-vault</code>: HashiCorp Vault (future)</li> </ul> <p>Custom Resolvers (native language callbacks):</p> <ul> <li>Users can register custom resolvers in their native language</li> <li>Rust core calls back to native code for custom resolver execution</li> </ul>"},{"location":"adr/ADR-002-resolver-architecture/#design","title":"Design","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 holoconf-core (Rust)                \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502          Resolver Registry                   \u2502   \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502   \u2502\n\u2502  \u2502  \u2502  env    \u2502 \u2502  self   \u2502 \u2502 custom (FFI)  \u2502  \u2502   \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n         \u2502                              \u25b2\n         \u2502 links to                     \u2502 callback\n         \u25bc                              \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  holoconf-aws   \u2502            \u2502  Native Custom     \u2502\n\u2502  (Rust crate)   \u2502            \u2502  Resolver          \u2502\n\u2502  - SSM          \u2502            \u2502  (Python/JS/etc)   \u2502\n\u2502  - S3           \u2502            \u2502                    \u2502\n\u2502  - CloudForm.   \u2502            \u2502  class MyResolver: \u2502\n\u2502  (aws-sdk-rust) \u2502            \u2502    def resolve()   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"adr/ADR-002-resolver-architecture/#resolver-syntax-omegaconf-style","title":"Resolver Syntax (OmegaConf-style)","text":"<p>Two reference types:</p> <ol> <li>Absolute references - from document root: <code>${path.to.value}</code></li> <li>Relative references - from current node: <code>${.sibling}</code> or <code>${..parent.sibling}</code></li> </ol> <p>Resolver prefix is optional for self-references, required for external resolvers.</p> <pre><code>database:\n  host: ${env:DB_HOST}           # env resolver (external)\n  password: ${ssm:/prod/db/password}  # ssm resolver (external)\n  port: ${defaults.port}         # absolute reference (from root)\n  timeout: ${.defaults.timeout}  # relative reference (sibling)\n\ndefaults:\n  port: 5432\n  timeout: 30\n\nnested:\n  level1:\n    level2:\n      value: ${..level1_sibling}     # relative: go up one level\n      root_ref: ${defaults.port}      # absolute: from root\n    level1_sibling: \"hello\"\n</code></pre>"},{"location":"adr/ADR-002-resolver-architecture/#custom-resolver-interface","title":"Custom Resolver Interface","text":"<p>Resolvers support two forms:</p>"},{"location":"adr/ADR-002-resolver-architecture/#simple-function-form","title":"Simple Function Form","text":"<p>For resolvers where all values have the same sensitivity (or none). Returns the value directly.</p> <pre><code># Sync function resolver - values not marked sensitive\ndef my_resolver(key: str) -&gt; str:\n    return lookup_value(key)\n\nholoconf.register(\"myresolver\", my_resolver)\n\n# Async function resolver\nasync def secret_resolver(key: str) -&gt; str:\n    return await fetch_secret(key)\n\nholoconf.register(\"secret\", secret_resolver)\n</code></pre> <pre><code>// JavaScript - async function resolver\nasync function secretResolver(key) {\n    const response = await fetch(`https://secrets.internal/${key}`);\n    return await response.text();\n}\n\nholoconf.register(\"secret\", secretResolver);\n</code></pre>"},{"location":"adr/ADR-002-resolver-architecture/#class-form-with-sensitivity-metadata","title":"Class Form (with Sensitivity Metadata)","text":"<p>For resolvers that need to report per-value sensitivity for redaction (see ADR-009). Returns a <code>ResolvedValue</code> with metadata.</p> <pre><code>from holoconf import Resolver, ResolvedValue\n\nclass SSMResolver(Resolver):\n    def resolve(self, key: str) -&gt; ResolvedValue:\n        param = self.client.get_parameter(Name=key, WithDecryption=True)\n        return ResolvedValue(\n            value=param[\"Parameter\"][\"Value\"],\n            sensitive=(param[\"Parameter\"][\"Type\"] == \"SecureString\")\n        )\n\nholoconf.register(\"ssm\", SSMResolver())\n</code></pre> <pre><code>// JavaScript class form\nclass VaultResolver extends Resolver {\n    async resolve(key) {\n        const secret = await this.client.read(key);\n        return new ResolvedValue({\n            value: secret.data,\n            sensitive: true  // All Vault values are secrets\n        });\n    }\n}\n\nholoconf.register(\"vault\", new VaultResolver());\n</code></pre> <p>The core wraps simple functions internally, defaulting <code>sensitive=False</code>. The class form enables resolver-aware redaction during serialization.</p> <p>Async resolvers enable parallel resolution internally (ADR-003), but access appears synchronous - the value blocks until resolved. For explicit async access, use <code>load_async()</code> and <code>resolve_all()</code>.</p>"},{"location":"adr/ADR-002-resolver-architecture/#resolver-return-types","title":"Resolver Return Types","text":"<p>Resolvers can return scalars or complex types:</p> Resolver returns You get back <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code> Native scalar (copied) <code>dict</code> Config wrapper (dot notation preserved) <code>list</code> Native list (copied) <pre><code># Resolver returning complex type\ndef json_resolver(key: str) -&gt; dict:\n    return {\"nested\": {\"value\": 123}, \"items\": [1, 2, 3]}\n\n# Access with dot notation\nconfig.some_data.nested.value  # 123\nconfig.some_data.items[0]      # 1\n</code></pre>"},{"location":"adr/ADR-002-resolver-architecture/#resolver-package-registration","title":"Resolver Package Registration","text":"<pre><code># Register all resolvers from a package (uses defaults / env vars)\nholoconf.register(holoconf_aws)\n\n# Register with options\nholoconf.register(holoconf_aws, {\"region\": \"us-east-1\", \"endpoint\": \"http://localhost:4566\"})\n\n# Register specific resolvers\nholoconf.register(holoconf_aws.ssm, holoconf_aws.s3)\n</code></pre> <p>Resolver packages expose a standard interface (e.g., <code>__holoconf_resolvers__</code> dict) for discovery. Built-in resolvers use standard credential/config chains by default (env vars, ~/.aws/config) but accept explicit overrides via options.</p>"},{"location":"adr/ADR-002-resolver-architecture/#caching","title":"Caching","text":"<p>Resolved values are memoized per-config-instance (see ADR-005). Resolvers themselves don't cache - that's the Config object's responsibility.</p>"},{"location":"adr/ADR-002-resolver-architecture/#rationale","title":"Rationale","text":"<ul> <li>Rust resolver packages ensure SSM/S3/etc. behave identically across all languages</li> <li>Native callbacks allow users to write custom resolvers without Rust knowledge</li> <li>Separate packages (holoconf-aws) keep core binary small - only pay for what you use</li> <li>aws-sdk-rust is official and well-maintained - reliable foundation</li> </ul>"},{"location":"adr/ADR-002-resolver-architecture/#trade-offs-accepted","title":"Trade-offs Accepted","text":"<ul> <li>Rust AWS SDK may have different defaults than boto3/@aws-sdk (credential chain, retries) in exchange for cross-language consistency</li> <li>Custom resolver callbacks cross FFI boundary (slight overhead) in exchange for native language ergonomics</li> <li>Users wanting Rust-level performance for custom resolvers must write Rust in exchange for lower barrier for simple resolvers</li> </ul>"},{"location":"adr/ADR-002-resolver-architecture/#migration","title":"Migration","text":"<p>N/A - This is the initial architecture decision.</p>"},{"location":"adr/ADR-002-resolver-architecture/#consequences","title":"Consequences","text":"<ul> <li>Positive: Consistent AWS/GCP/Vault behavior across languages, users can write custom resolvers in their preferred language</li> <li>Negative: Built-in resolvers may not expose all native SDK features</li> <li>Neutral: Two paths for resolver implementation (Rust for built-ins, native for custom)</li> </ul>"},{"location":"adr/ADR-003-async-execution-model/","title":"ADR-003: Async Execution Model","text":""},{"location":"adr/ADR-003-async-execution-model/#status","title":"Status","text":"<ul> <li>Proposed by: Ryan on 2026-01-07</li> <li>Accepted on: 2026-01-07</li> </ul>"},{"location":"adr/ADR-003-async-execution-model/#context","title":"Context","text":"<p>Resolvers may need to fetch values from external services (SSM, S3, HTTP endpoints). A configuration file might have many such references. We need to decide how resolver execution works.</p> <p>Key considerations:</p> <ul> <li>Configs with multiple external references should resolve quickly</li> <li>AWS Lambda cold starts are performance-critical</li> <li>Some contexts prefer sync APIs (scripts, CLI tools)</li> </ul>"},{"location":"adr/ADR-003-async-execution-model/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/ADR-003-async-execution-model/#alternative-1-sync-only","title":"Alternative 1: Sync-Only","text":"<p>All resolver execution is synchronous and sequential.</p> <ul> <li>Pros: Simpler FFI, works everywhere</li> <li>Cons: Sequential resolver execution, slow for configs with many external refs</li> <li>Rejected: Performance critical for configs with multiple SSM/S3 lookups</li> </ul>"},{"location":"adr/ADR-003-async-execution-model/#alternative-2-async-only","title":"Alternative 2: Async-Only","text":"<p>Only expose async APIs.</p> <ul> <li>Pros: Maximum parallelism</li> <li>Cons: Some languages/contexts prefer sync (scripts, CLI tools)</li> <li>Rejected: Too restrictive</li> </ul>"},{"location":"adr/ADR-003-async-execution-model/#decision","title":"Decision","text":"<p>Async-First with Parallel Resolution</p> <ul> <li>Rust core uses async (tokio) internally</li> <li>Resolvers execute in parallel when explicitly requested via <code>resolve_all()</code></li> <li>Language bindings expose both sync and async APIs</li> <li>Lazy resolution by default (sequential on access), parallel on demand</li> </ul>"},{"location":"adr/ADR-003-async-execution-model/#design","title":"Design","text":""},{"location":"adr/ADR-003-async-execution-model/#execution-model","title":"Execution Model","text":"<pre><code>Config with 5 SSM references:\n\nSequential access:       resolve_all():\nconfig.a  # SSM1 \u2500\u2500\u2500\u25ba    SSM1 \u2500\u2500\u2510\nconfig.b  # SSM2 \u2500\u2500\u2500\u25ba    SSM2 \u2500\u2500\u253c\u2500\u2500\u25ba All parallel\nconfig.c  # SSM3 \u2500\u2500\u2500\u25ba    SSM3 \u2500\u2500\u2524\nconfig.d  # SSM4 \u2500\u2500\u2500\u25ba    SSM4 \u2500\u2500\u2524\nconfig.e  # SSM5 \u2500\u2500\u2500\u25ba    SSM5 \u2500\u2500\u2518\nTotal: 5 \u00d7 latency       Total: 1 \u00d7 latency\n</code></pre>"},{"location":"adr/ADR-003-async-execution-model/#api-surface","title":"API Surface","text":"<pre><code># Python - lazy access (sequential resolution)\nconfig = Config.load(\"config.yaml\")\nhost = config.database.host  # resolves on access\n\n# Python - explicit parallel resolution\nconfig = Config.load(\"config.yaml\")\nawait config.resolve_all()  # resolve all refs in parallel\nhost = config.database.host  # already resolved, instant\n\n# Python - sync parallel resolution\nconfig = Config.load(\"config.yaml\")\nconfig.resolve_all_sync()  # blocks, but parallel internally\n</code></pre> <pre><code>// JavaScript - lazy access\nconst config = Config.load(\"config.yaml\");\nconst host = config.database.host;  // resolves on access\n\n// JavaScript - explicit parallel resolution\nconst config = Config.load(\"config.yaml\");\nawait config.resolveAll();  // resolve all refs in parallel\nconst host = config.database.host;  // already resolved\n</code></pre>"},{"location":"adr/ADR-003-async-execution-model/#sync-callback-integration","title":"Sync Callback Integration","text":"<p>Sync custom resolver callbacks are wrapped in <code>spawn_blocking</code> to integrate with the async core:</p> <pre><code># User's sync resolver\ndef my_resolver(key: str) -&gt; str:\n    return lookup_value(key)  # sync code\n\n# Internally wrapped as:\n# spawn_blocking(|| callback(key))\n</code></pre> <p>This allows sync callbacks to work without blocking the tokio runtime, while async callbacks run natively.</p>"},{"location":"adr/ADR-003-async-execution-model/#timeout-handling","title":"Timeout Handling","text":"<p>Two levels of timeout control:</p> <ol> <li>Per-invocation timeout (default: 30s) - Individual resolver calls timeout independently</li> <li>Batch timeout (optional) - <code>resolve_all(timeout=5.0)</code> sets a deadline for all resolutions</li> </ol> <pre><code># Per-invocation timeout (configured at resolver registration)\nholoconf.register(\"slow_resolver\", my_resolver, timeout=60.0)\n\n# Batch timeout for resolve_all\nawait config.resolve_all(timeout=10.0)  # all must complete in 10s\n</code></pre>"},{"location":"adr/ADR-003-async-execution-model/#concurrency-limits","title":"Concurrency Limits","text":"<p>Global concurrency limit with sensible default (e.g., 50 concurrent resolver calls):</p> <pre><code># Configure global limit\nholoconf.configure(max_concurrent_resolvers=100)\n\n# Or at resolve_all\nawait config.resolve_all(max_concurrency=20)\n</code></pre> <p>This prevents overwhelming external services when configs have many references.</p>"},{"location":"adr/ADR-003-async-execution-model/#rationale","title":"Rationale","text":"<ul> <li>AWS Lambda cold starts benefit significantly from parallel SSM fetches</li> <li>tokio is the standard async runtime for Rust - mature and well-supported</li> <li>Sync wrapper can use <code>block_on</code> internally while still parallelizing resolver calls</li> <li>Lazy by default follows intuitive semantics - access triggers resolution</li> <li>Explicit <code>resolve_all()</code> gives users control over when parallelism happens</li> <li>Per-invocation + batch timeouts provide flexibility without complexity</li> <li>Global concurrency limits prevent accidental DoS of external services</li> </ul>"},{"location":"adr/ADR-003-async-execution-model/#trade-offs-accepted","title":"Trade-offs Accepted","text":"<ul> <li>tokio dependency adds to binary size in exchange for parallel execution</li> <li>Async FFI is more complex than sync in exchange for better performance</li> <li>Sync resolver callbacks require <code>spawn_blocking</code> in exchange for simple user API</li> <li>Lazy resolution is sequential by default in exchange for intuitive access semantics</li> </ul>"},{"location":"adr/ADR-003-async-execution-model/#migration","title":"Migration","text":"<p>N/A - This is the initial architecture decision.</p>"},{"location":"adr/ADR-003-async-execution-model/#consequences","title":"Consequences","text":"<ul> <li>Positive: Fast config loading with many external references, good Lambda cold start performance, intuitive lazy access semantics</li> <li>Negative: Async complexity in FFI layer, larger binary size, users must call <code>resolve_all()</code> explicitly for parallelism</li> <li>Neutral: Users can choose sync or async API based on their needs</li> </ul>"},{"location":"adr/ADR-004-config-merging/","title":"ADR-004: Config Merging Semantics","text":""},{"location":"adr/ADR-004-config-merging/#status","title":"Status","text":"<ul> <li>Proposed by: Ryan on 2026-01-07</li> <li>Accepted on: 2026-01-07</li> </ul>"},{"location":"adr/ADR-004-config-merging/#context","title":"Context","text":"<p>holoconf supports loading and merging multiple configuration files. Users load configs in a specific order, where later files override earlier ones:</p> <pre><code>config = Config.load(\"base.yaml\", \"environment.yaml\", \"local.yaml\")\n#                    ^ lowest priority              ^ highest priority\n</code></pre> <p>The merge order is determined by the user, not holoconf. Users may organize configs however suits their deployment model (by environment, region, team, feature flags, etc.).</p> <p>We need to define how merging works when the same keys appear in multiple files.</p>"},{"location":"adr/ADR-004-config-merging/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/ADR-004-config-merging/#alternative-1-shallow-merge-top-level-only","title":"Alternative 1: Shallow Merge (top-level only)","text":"<p>Only merge top-level keys; nested objects replace entirely.</p> <ul> <li>Pros: Simple, predictable</li> <li>Cons: Can't override nested values without replacing entire subtree</li> <li>Rejected: Too limiting for real-world hierarchical configs</li> </ul>"},{"location":"adr/ADR-004-config-merging/#alternative-2-list-concatenation-by-default","title":"Alternative 2: List Concatenation by Default","text":"<p>When merging lists, concatenate them.</p> <ul> <li>Pros: Additive, nothing lost</li> <li>Cons: Often not desired (e.g., overriding log handlers), harder to remove items</li> <li>Rejected: Replace is more commonly expected behavior</li> </ul>"},{"location":"adr/ADR-004-config-merging/#alternative-3-json-merge-patch-rfc-7396","title":"Alternative 3: JSON Merge Patch (RFC 7396)","text":"<p>Use the standard JSON Merge Patch algorithm.</p> <ul> <li>Pros: Standard</li> <li>Cons: Limited (no way to append to arrays, null removes keys)</li> <li>Rejected: Too limited, but we adopt null-removes-key from it</li> </ul>"},{"location":"adr/ADR-004-config-merging/#decision","title":"Decision","text":"<p>Deep Merge with Last-Writer-Wins for Scalars</p> <p>Merging follows these rules:</p> <ol> <li>Dictionaries/Objects: Deep merge recursively</li> <li>Scalars (strings, numbers, booleans): Last value wins (later config overrides earlier)</li> <li>Lists/Arrays: Replace (later list replaces earlier list entirely)</li> <li>Null values: Explicit null removes key from merged result</li> <li>Type mismatches: Last value wins (later value replaces entirely)</li> </ol>"},{"location":"adr/ADR-004-config-merging/#design","title":"Design","text":""},{"location":"adr/ADR-004-config-merging/#basic-merging","title":"Basic Merging","text":"<pre><code># base.yaml (loaded first)\ndatabase:\n  host: localhost\n  port: 5432\n  options:\n    timeout: 30\n    retries: 3\nlogging:\n  level: info\n  handlers:\n    - console\n\n# override.yaml (loaded second, higher priority)\ndatabase:\n  host: prod-db.example.com    # overrides scalar\n  options:\n    timeout: 60                 # overrides nested scalar\n    pool_size: 10               # adds new key\nlogging:\n  level: debug                  # overrides scalar\n  handlers:                     # replaces list (default behavior)\n    - file\n    - syslog\n\n# Result after merge:\ndatabase:\n  host: prod-db.example.com    # from override\n  port: 5432                    # from base (preserved)\n  options:\n    timeout: 60                 # from override\n    retries: 3                  # from base (preserved)\n    pool_size: 10               # from override (added)\nlogging:\n  level: debug\n  handlers:\n    - file\n    - syslog\n</code></pre>"},{"location":"adr/ADR-004-config-merging/#null-removes-key","title":"Null Removes Key","text":"<pre><code># base.yaml\nfeature:\n  enabled: true\n  config:\n    setting: value\n\n# override.yaml\nfeature:\n  config: null   # removes 'config' entirely\n\n# Result:\nfeature:\n  enabled: true\n  # config is removed\n</code></pre>"},{"location":"adr/ADR-004-config-merging/#type-mismatch-handling","title":"Type Mismatch Handling","text":"<p>When types don't match, the later value wins entirely (replacement, not merge):</p> <pre><code># base.yaml\ndatabase:\n  host: localhost\n  port: 5432\n\n# override.yaml\ndatabase: \"postgresql://prod-db/app\"   # scalar replaces dict\n\n# Result:\ndatabase: \"postgresql://prod-db/app\"\n</code></pre> <pre><code># base.yaml\ndatabase: \"postgresql://localhost/app\"\n\n# override.yaml\ndatabase:                              # dict replaces scalar\n  host: prod-db\n  port: 5432\n\n# Result:\ndatabase:\n  host: prod-db\n  port: 5432\n</code></pre> <p>This behavior is consistent with last-writer-wins and allows users to restructure configs at higher hierarchy levels.</p>"},{"location":"adr/ADR-004-config-merging/#rationale","title":"Rationale","text":"<ul> <li>Deep merge preserves base config while allowing targeted overrides</li> <li>Last-writer-wins is intuitive for operators (\"my override file wins\")</li> <li>List replacement avoids surprising concatenation behavior</li> <li>Type mismatch replacement is consistent with last-writer-wins semantics</li> <li>No strict mode for v1 - keeps the API simple; can be added if users request it</li> <li>Future: append/prepend could be implemented as resolvers if needed</li> </ul>"},{"location":"adr/ADR-004-config-merging/#trade-offs-accepted","title":"Trade-offs Accepted","text":"<ul> <li>List replacement may surprise users expecting concatenation in exchange for simpler mental model</li> <li>No automatic conflict detection (last writer silently wins) in exchange for predictable behavior</li> <li>Type mismatches silently replace in exchange for flexibility in restructuring configs</li> </ul>"},{"location":"adr/ADR-004-config-merging/#migration","title":"Migration","text":"<p>N/A - This is the initial architecture decision.</p>"},{"location":"adr/ADR-004-config-merging/#consequences","title":"Consequences","text":"<ul> <li>Positive: Intuitive override behavior, nested configs work naturally, flexible restructuring at higher levels</li> <li>Negative: List operations require workarounds (future resolver-based append), type changes may be unintentional</li> <li>Neutral: Matches common YAML config tooling behavior (Helm, Kustomize)</li> </ul>"},{"location":"adr/ADR-005-resolver-timing/","title":"ADR-005: Resolver Timing (Lazy Resolution)","text":""},{"location":"adr/ADR-005-resolver-timing/#status","title":"Status","text":"<ul> <li>Proposed by: Ryan on 2026-01-07</li> <li>Accepted on: 2026-01-07</li> </ul>"},{"location":"adr/ADR-005-resolver-timing/#context","title":"Context","text":"<p>OmegaConf resolves interpolations at parse time, before configs are merged. This causes issues:</p> <ul> <li>Resolvers run even if the value is later overridden</li> <li>External resolver calls (SSM, S3) happen at import time, slowing startup</li> <li>Errors occur for values that would be overridden anyway</li> <li>No way to inspect unresolved config structure</li> </ul> <p>We need to decide when resolution occurs.</p>"},{"location":"adr/ADR-005-resolver-timing/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/ADR-005-resolver-timing/#alternative-1-parse-time-resolution-omegaconf-behavior","title":"Alternative 1: Parse-Time Resolution (OmegaConf behavior)","text":"<p>Resolve all interpolations when the config is parsed.</p> <ul> <li>Pros: Simple mental model, all values ready immediately</li> <li>Cons: Slow startup, resolves overridden values, errors on unused invalid refs</li> <li>Rejected: This is the pain point we're solving</li> </ul>"},{"location":"adr/ADR-005-resolver-timing/#alternative-2-explicit-resolution-step","title":"Alternative 2: Explicit Resolution Step","text":"<p>Require users to call <code>config.resolve()</code> explicitly.</p> <ul> <li>Pros: Clear when resolution happens</li> <li>Cons: Extra boilerplate, easy to forget</li> <li>Rejected: Lazy is more ergonomic</li> </ul>"},{"location":"adr/ADR-005-resolver-timing/#alternative-3-no-memoization-resolve-every-access","title":"Alternative 3: No Memoization (resolve every access)","text":"<p>Resolve values fresh on every access.</p> <ul> <li>Pros: Always fresh values</li> <li>Cons: Performance disaster, inconsistent values during execution</li> <li>Rejected: Memoization is essential</li> </ul>"},{"location":"adr/ADR-005-resolver-timing/#decision","title":"Decision","text":"<p>Lazy Resolution with Memoization</p> <p>Resolvers execute lazily when values are accessed, not at parse/merge time. Resolved values are memoized so each resolver runs exactly once per key.</p> <p>Key decisions: - No TTL/expiry - Config values are stable for the lifetime of the Config object - Circular reference detection at access time - Detected during lazy evaluation, not at parse - <code>resolve_all()</code> is eager - Resolves all pending interpolations in parallel</p>"},{"location":"adr/ADR-005-resolver-timing/#design","title":"Design","text":""},{"location":"adr/ADR-005-resolver-timing/#timeline","title":"Timeline","text":"<pre><code>Parse time:     config = Config.load(\"base.yaml\", \"override.yaml\")\n                -&gt; Config object created with unresolved interpolations\n                -&gt; No resolver calls yet\n                -&gt; Merge happens on raw structures\n\nAccess time:    value = config.database.password\n                -&gt; Resolver executes: ${ssm:/prod/db/password}\n                -&gt; Result memoized in config object\n\nSecond access:  value2 = config.database.password\n                -&gt; Returns memoized value (no resolver call)\n</code></pre>"},{"location":"adr/ADR-005-resolver-timing/#benefits","title":"Benefits","text":"<pre><code># With lazy resolution:\n\n# 1. Fast startup - no resolver calls at parse time\nconfig = Config.load(\"base.yaml\", \"prod.yaml\")  # Instant\n\n# 2. Override works correctly\n# base.yaml:   password: ${ssm:/base/password}\n# prod.yaml:   password: ${ssm:/prod/password}\n# Only /prod/password is ever resolved (base was overridden)\n\n# 3. Can inspect unresolved structure\nconfig.to_yaml(resolve=False)  # Shows ${...} placeholders\n\n# 4. Unused values never resolved\n# If config.unused_feature.api_key is never accessed,\n# that SSM call never happens\n</code></pre>"},{"location":"adr/ADR-005-resolver-timing/#api-surface","title":"API Surface","text":"<pre><code># Python\nconfig = Config.load(\"config.yaml\")\n\n# Lazy access (resolves on demand)\npassword = config.database.password\n\n# Force resolution of entire config (parallel, see ADR-003)\nawait config.resolve_all()\n\n# Get unresolved value (for debugging/inspection)\nraw = config.get_raw(\"database.password\")  # Returns \"${ssm:/path}\"\n\n# Check if resolved\nconfig.is_resolved(\"database.password\")  # True/False\n</code></pre>"},{"location":"adr/ADR-005-resolver-timing/#memoization-semantics","title":"Memoization Semantics","text":"<ul> <li>Values are memoized per-Config-instance</li> <li>No TTL/expiry - values remain stable for the Config object's lifetime</li> <li>To get fresh values, create a new Config object (reload the config)</li> <li>This ensures consistent behavior during application execution</li> </ul> <pre><code># Values are stable within a Config instance\nconfig = Config.load(\"config.yaml\")\nv1 = config.api.key  # resolves ${ssm:/api/key}\n# ... SSM value changes externally ...\nv2 = config.api.key  # returns same memoized value as v1\n\n# To get fresh values, reload\nconfig = Config.load(\"config.yaml\")  # new instance\nv3 = config.api.key  # re-resolves, gets new value\n</code></pre>"},{"location":"adr/ADR-005-resolver-timing/#circular-reference-detection","title":"Circular Reference Detection","text":"<p>Circular references are detected at access time during lazy evaluation:</p> <pre><code># config.yaml\na: ${b}\nb: ${a}\n</code></pre> <pre><code>config = Config.load(\"config.yaml\")  # OK - no resolution yet\nconfig.a  # raises CircularReferenceError: a -&gt; b -&gt; a\n</code></pre> <p>Detection works by tracking the resolution stack. If a key is encountered that's already being resolved, it's a circular reference.</p>"},{"location":"adr/ADR-005-resolver-timing/#interaction-with-async-adr-003","title":"Interaction with Async (ADR-003)","text":"<ul> <li>Lazy resolution integrates naturally with async</li> <li>Individual access resolves sequentially (lazy behavior)</li> <li><code>resolve_all()</code> parallelizes all pending resolutions</li> <li>See ADR-003 for parallelism semantics</li> </ul>"},{"location":"adr/ADR-005-resolver-timing/#rationale","title":"Rationale","text":"<ul> <li>Lazy resolution avoids wasted work on overridden/unused values</li> <li>Memoization ensures consistency and performance</li> <li>No TTL keeps the model simple - reload for fresh values</li> <li>Access-time circular detection is consistent with lazy philosophy</li> <li>Matches how most developers expect config access to work</li> <li>Enables fast startup (critical for Lambda, CLI tools)</li> </ul>"},{"location":"adr/ADR-005-resolver-timing/#trade-offs-accepted","title":"Trade-offs Accepted","text":"<ul> <li>First access to a value may be slow (resolver runs) in exchange for fast startup</li> <li>Memoization means value won't update if external source changes in exchange for consistency during execution</li> <li>Debugging requires understanding lazy evaluation in exchange for performance benefits</li> <li>Circular reference detection happens at access time, not parse time in exchange for avoiding unnecessary resolution</li> </ul>"},{"location":"adr/ADR-005-resolver-timing/#migration","title":"Migration","text":"<p>N/A - This is the initial architecture decision.</p>"},{"location":"adr/ADR-005-resolver-timing/#consequences","title":"Consequences","text":"<ul> <li>Positive: Fast startup, no wasted resolver calls, clean override semantics, stable values during execution</li> <li>Negative: First access latency, debugging lazy values can be confusing, must reload for fresh values</li> <li>Neutral: Different mental model than OmegaConf (but better for our use case)</li> </ul>"},{"location":"adr/ADR-006-repository-package-structure/","title":"ADR-006: Repository and Package Structure","text":""},{"location":"adr/ADR-006-repository-package-structure/#status","title":"Status","text":"<ul> <li>Proposed by: Ryan on 2026-01-07</li> <li>Accepted on: 2026-01-07</li> </ul>"},{"location":"adr/ADR-006-repository-package-structure/#context","title":"Context","text":"<p>holoconf is a multi-language configuration library with:</p> <ul> <li>A Rust core (<code>holoconf-core</code>)</li> <li>Rust resolver packages (<code>holoconf-aws</code>, <code>holoconf-vault</code>, etc.)</li> <li>Language bindings (Python, JavaScript, Go, etc.)</li> <li>Language-specific resolver wrapper packages</li> </ul> <p>We need to define how the repository is organized and how packages relate to each other.</p>"},{"location":"adr/ADR-006-repository-package-structure/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/ADR-006-repository-package-structure/#alternative-1-polyrepo-separate-repositories","title":"Alternative 1: Polyrepo (separate repositories)","text":"<p>Each component in its own repository: - <code>holoconf-core</code> repo - <code>holoconf-python</code> repo - <code>holoconf-js</code> repo - <code>holoconf-aws</code> repo</p> <ul> <li>Pros: Independent versioning, clear ownership, smaller clones</li> <li>Cons: Cross-repo changes are painful, version coordination is complex, harder to ensure consistency</li> <li>Rejected: Too much coordination overhead for a project where core changes often require binding updates</li> </ul>"},{"location":"adr/ADR-006-repository-package-structure/#alternative-2-language-first-monorepo","title":"Alternative 2: Language-first monorepo","text":"<p>Organize by language: <pre><code>python/\n  holoconf/\n  holoconf-aws/\njavascript/\n  holoconf/\n  holoconf-aws/\nrust/\n  holoconf-core/\n</code></pre></p> <ul> <li>Pros: Language teams can work independently</li> <li>Cons: Duplicates resolver logic across languages, harder to see the full picture</li> <li>Rejected: Resolvers are Rust crates shared across languages, not per-language</li> </ul>"},{"location":"adr/ADR-006-repository-package-structure/#decision","title":"Decision","text":"<p>Component-first monorepo with Cargo workspace</p> <p>All code lives in a single repository, organized by component type.</p> <p>Key decisions: - Conformance tests at top-level in <code>tests/conformance/</code> with shared fixtures - Language-specific resolver wrappers in <code>packages/&lt;language&gt;/holoconf-&lt;resolver&gt;/</code> that re-export Rust resolvers</p>"},{"location":"adr/ADR-006-repository-package-structure/#design","title":"Design","text":""},{"location":"adr/ADR-006-repository-package-structure/#repository-layout","title":"Repository Layout","text":"<pre><code>holoconf/\n\u251c\u2500\u2500 docs/                          # Documentation (exists)\n\u2502   \u251c\u2500\u2500 adr/                       # Architecture Decision Records\n\u2502   \u251c\u2500\u2500 specs/features/            # Feature specifications\n\u2502   \u251c\u2500\u2500 PROBLEM_STATEMENT.md\n\u2502   \u251c\u2500\u2500 REQUIREMENTS.md\n\u2502   \u2514\u2500\u2500 CONSTRAINTS.md\n\u2502\n\u251c\u2500\u2500 crates/                        # Rust crates (Cargo workspace)\n\u2502   \u251c\u2500\u2500 holoconf-core/             # Core library: parsing, merging, resolution\n\u2502   \u251c\u2500\u2500 holoconf-aws/              # AWS resolvers (SSM, S3, CloudFormation)\n\u2502   \u251c\u2500\u2500 holoconf-gcp/              # GCP resolvers (future)\n\u2502   \u251c\u2500\u2500 holoconf-vault/            # HashiCorp Vault resolvers (future)\n\u2502   \u251c\u2500\u2500 holoconf-python/           # Python bindings (PyO3)\n\u2502   \u2514\u2500\u2500 holoconf-js/               # JavaScript bindings (NAPI-RS)\n\u2502\n\u251c\u2500\u2500 packages/                      # Language-specific package metadata/wrappers\n\u2502   \u251c\u2500\u2500 python/                    # Python package (pyproject.toml, re-exports)\n\u2502   \u2502   \u251c\u2500\u2500 holoconf/              # Main Python package\n\u2502   \u2502   \u2514\u2500\u2500 holoconf-aws/          # AWS resolver Python wrapper\n\u2502   \u2514\u2500\u2500 javascript/                # npm packages\n\u2502       \u251c\u2500\u2500 holoconf/              # Main npm package\n\u2502       \u2514\u2500\u2500 holoconf-aws/          # AWS resolver npm wrapper\n\u2502\n\u251c\u2500\u2500 tests/                         # Cross-language conformance tests\n\u2502   \u2514\u2500\u2500 conformance/               # Shared test fixtures (YAML in, expected out)\n\u2502\n\u251c\u2500\u2500 examples/                      # Usage examples per language\n\u2502   \u251c\u2500\u2500 python/\n\u2502   \u2514\u2500\u2500 javascript/\n\u2502\n\u251c\u2500\u2500 Cargo.toml                     # Cargo workspace root\n\u251c\u2500\u2500 Cargo.lock\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"adr/ADR-006-repository-package-structure/#conformance-tests","title":"Conformance Tests","text":"<p>Conformance tests ensure all language bindings behave identically. They live at the top level (<code>tests/conformance/</code>) rather than under each binding because:</p> <ul> <li>Shared fixtures - Same YAML input files and expected outputs for all languages</li> <li>Cross-language validation - Easy to verify Python and JS produce identical results</li> <li>Single source of truth - Adding a test case automatically applies to all languages</li> </ul> <pre><code>tests/conformance/\n\u251c\u2500\u2500 fixtures/\n\u2502   \u251c\u2500\u2500 basic/\n\u2502   \u2502   \u251c\u2500\u2500 input.yaml\n\u2502   \u2502   \u2514\u2500\u2500 expected.json\n\u2502   \u251c\u2500\u2500 merging/\n\u2502   \u2502   \u251c\u2500\u2500 base.yaml\n\u2502   \u2502   \u251c\u2500\u2500 override.yaml\n\u2502   \u2502   \u2514\u2500\u2500 expected.json\n\u2502   \u2514\u2500\u2500 resolvers/\n\u2502       \u251c\u2500\u2500 env/\n\u2502       \u2514\u2500\u2500 self-ref/\n\u251c\u2500\u2500 python/\n\u2502   \u2514\u2500\u2500 test_conformance.py      # Runs fixtures against Python binding\n\u2514\u2500\u2500 javascript/\n    \u2514\u2500\u2500 conformance.test.js      # Runs fixtures against JS binding\n</code></pre>"},{"location":"adr/ADR-006-repository-package-structure/#language-specific-resolver-wrappers","title":"Language-Specific Resolver Wrappers","text":"<p>Resolver wrappers (e.g., <code>holoconf-aws</code> on PyPI) are thin packages that: 1. Depend on the main <code>holoconf</code> package 2. Re-export the Rust resolver registrations 3. Provide language-idiomatic installation (<code>pip install holoconf-aws</code>)</p> <pre><code># packages/python/holoconf-aws/src/holoconf_aws/__init__.py\nfrom holoconf._native import aws_resolvers\n\n# Re-export resolver registration functions\nssm = aws_resolvers.ssm\ns3 = aws_resolvers.s3\ncloudformation = aws_resolvers.cloudformation\n\n# For package-level registration\n__holoconf_resolvers__ = {\n    \"ssm\": ssm,\n    \"s3\": s3,\n    \"cfn\": cloudformation,\n}\n</code></pre> <p>This approach: - Keeps resolver logic in Rust (consistent behavior) - Provides familiar package installation patterns per language - Allows <code>holoconf.register(holoconf_aws)</code> pattern from ADR-002</p>"},{"location":"adr/ADR-006-repository-package-structure/#package-relationships","title":"Package Relationships","text":"<pre><code>                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502   holoconf-core     \u2502\n                    \u2502   (Rust crate)      \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                               \u2502\n           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n           \u2502                   \u2502                   \u2502\n           \u25bc                   \u25bc                   \u25bc\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502 holoconf-aws  \u2502   \u2502holoconf-python\u2502   \u2502  holoconf-js  \u2502\n   \u2502 (Rust crate)  \u2502   \u2502 (Rust crate)  \u2502   \u2502 (Rust crate)  \u2502\n   \u2502 SSM, S3, CF   \u2502   \u2502 PyO3 bindings \u2502   \u2502 NAPI bindings \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502                   \u2502                   \u2502\n           \u2502           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u2502\n           \u2502           \u25bc               \u25bc           \u2502\n           \u2502   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\n           \u2502   \u2502  holoconf   \u2502 \u2502  holoconf   \u2502     \u2502\n           \u2502   \u2502  (PyPI)     \u2502 \u2502  (npm)      \u2502\u25c4\u2500\u2500\u2500\u2500\u2518\n           \u2502   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502          \u2502\n           \u25bc          \u25bc\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n   \u2502     holoconf-aws        \u2502\n   \u2502  (PyPI) - re-exports    \u2502\n   \u2502  Rust AWS resolvers     \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"adr/ADR-006-repository-package-structure/#package-naming-convention","title":"Package Naming Convention","text":"Component Rust Crate PyPI Package npm Package Core <code>holoconf-core</code> <code>holoconf</code> <code>holoconf</code> Python bindings <code>holoconf-python</code> (built into <code>holoconf</code>) - JS bindings <code>holoconf-js</code> - (built into <code>holoconf</code>) AWS resolvers <code>holoconf-aws</code> <code>holoconf-aws</code> <code>@holoconf/aws</code> GCP resolvers <code>holoconf-gcp</code> <code>holoconf-gcp</code> <code>@holoconf/gcp</code> Vault resolvers <code>holoconf-vault</code> <code>holoconf-vault</code> <code>@holoconf/vault</code>"},{"location":"adr/ADR-006-repository-package-structure/#cargo-workspace","title":"Cargo Workspace","text":"<pre><code># /Cargo.toml\n[workspace]\nmembers = [\n    \"crates/holoconf-core\",\n    \"crates/holoconf-aws\",\n    \"crates/holoconf-python\",\n    \"crates/holoconf-js\",\n]\n\n[workspace.package]\nversion = \"0.1.0\"\nedition = \"2021\"\nlicense = \"MIT OR Apache-2.0\"\nrepository = \"https://github.com/org/holoconf\"\n</code></pre>"},{"location":"adr/ADR-006-repository-package-structure/#python-package-structure","title":"Python Package Structure","text":"<pre><code>packages/python/holoconf/\n\u251c\u2500\u2500 pyproject.toml          # maturin build config\n\u251c\u2500\u2500 src/\n\u2502   \u2514\u2500\u2500 holoconf/\n\u2502       \u251c\u2500\u2500 __init__.py     # Re-exports from Rust binding\n\u2502       \u2514\u2500\u2500 py.typed        # PEP 561 marker\n\u2514\u2500\u2500 tests/\n</code></pre> <pre><code># pyproject.toml\n[build-system]\nrequires = [\"maturin&gt;=1.0,&lt;2.0\"]\nbuild-backend = \"maturin\"\n\n[project]\nname = \"holoconf\"\nrequires-python = \"&gt;=3.9\"\n\n[tool.maturin]\nmanifest-path = \"../../crates/holoconf-python/Cargo.toml\"\n</code></pre>"},{"location":"adr/ADR-006-repository-package-structure/#javascript-package-structure","title":"JavaScript Package Structure","text":"<pre><code>packages/javascript/holoconf/\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 index.js                # Re-exports from Rust binding\n\u251c\u2500\u2500 index.d.ts              # TypeScript definitions\n\u2514\u2500\u2500 tests/\n</code></pre>"},{"location":"adr/ADR-006-repository-package-structure/#rationale","title":"Rationale","text":"<ul> <li>Single repo enables atomic changes across core + bindings</li> <li><code>crates/</code> directory keeps Rust code together, managed by Cargo workspace</li> <li><code>packages/</code> directory holds language-specific packaging (pyproject.toml, package.json)</li> <li>Top-level conformance tests ensure cross-language consistency</li> <li>Resolver crates are separate from core to keep binary size small</li> <li>Language bindings are Rust crates that compile to native extensions</li> <li>Thin resolver wrappers provide idiomatic installation while keeping logic in Rust</li> <li>npm scoped packages (<code>@holoconf/aws</code>) prevent naming conflicts</li> </ul>"},{"location":"adr/ADR-006-repository-package-structure/#trade-offs-accepted","title":"Trade-offs Accepted","text":"<ul> <li>Larger repository with all languages in exchange for atomic cross-language changes</li> <li>More complex CI (must test all languages) in exchange for consistency guarantees</li> <li>Single version number across packages in exchange for simpler dependency management</li> <li>Thin wrapper packages add indirection in exchange for idiomatic installation patterns</li> </ul>"},{"location":"adr/ADR-006-repository-package-structure/#migration","title":"Migration","text":"<p>N/A - This is the initial structure decision.</p>"},{"location":"adr/ADR-006-repository-package-structure/#consequences","title":"Consequences","text":"<ul> <li>Positive: Easy to make coordinated changes, single source of truth, shared CI/CD, conformance testing built-in</li> <li>Negative: Contributors need familiarity with monorepo tooling, larger clone size</li> <li>Neutral: Requires workspace-aware tooling (Cargo workspaces, potentially nx/turborepo for JS)</li> </ul>"},{"location":"adr/ADR-007-schema-validation/","title":"ADR-007: Schema and Validation","text":""},{"location":"adr/ADR-007-schema-validation/#status","title":"Status","text":"<ul> <li>Proposed by: Ryan on 2026-01-07</li> <li>Accepted on: 2026-01-07</li> </ul>"},{"location":"adr/ADR-007-schema-validation/#context","title":"Context","text":"<p>Users need a way to define and enforce the expected shape of their configuration. This includes:</p> <ul> <li>Documenting what keys exist and what they mean</li> <li>Specifying types, allowed values, ranges, and patterns</li> <li>Providing example values and descriptions</li> <li>Validating configs at runtime with helpful error messages</li> </ul> <p>Key constraints:</p> <ul> <li>The schema format must be language-agnostic (not Python-specific, not JS-specific)</li> <li>Must work with multiple input formats (YAML, JSON)</li> <li>Should be simple and intuitive to write</li> <li>Must interact sensibly with lazy resolution (ADR-005)</li> </ul>"},{"location":"adr/ADR-007-schema-validation/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/ADR-007-schema-validation/#alternative-1-json-schema","title":"Alternative 1: JSON Schema","text":"<p>Use the industry-standard JSON Schema format.</p> <pre><code>{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"database\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"host\": { \"type\": \"string\", \"description\": \"Database hostname\" },\n        \"port\": { \"type\": \"integer\", \"minimum\": 1, \"maximum\": 65535 }\n      },\n      \"required\": [\"host\"]\n    }\n  }\n}\n</code></pre> <ul> <li>Pros: Industry standard, extensive tooling, editor support, language-agnostic</li> <li>Cons: Verbose, JSON syntax is tedious to write by hand, advanced features are complex</li> <li>Status: Under consideration</li> </ul>"},{"location":"adr/ADR-007-schema-validation/#alternative-2-yaml-schema-json-schema-in-yaml","title":"Alternative 2: YAML Schema (JSON Schema in YAML)","text":"<p>JSON Schema but written in YAML for readability.</p> <pre><code>type: object\nproperties:\n  database:\n    type: object\n    description: Database connection settings\n    properties:\n      host:\n        type: string\n        description: Database hostname\n        examples: [\"localhost\", \"db.example.com\"]\n      port:\n        type: integer\n        minimum: 1\n        maximum: 65535\n        default: 5432\n    required: [host]\n</code></pre> <ul> <li>Pros: Same power as JSON Schema, more readable, language-agnostic</li> <li>Cons: Still verbose for simple cases, learning curve for JSON Schema concepts</li> <li>Status: Under consideration</li> </ul>"},{"location":"adr/ADR-007-schema-validation/#alternative-3-inline-schema-schema-in-config-file","title":"Alternative 3: Inline Schema (schema in config file)","text":"<p>Define schema inline within the config file itself using special syntax.</p> <pre><code># @schema: { type: string, description: \"Database hostname\" }\nhost: localhost\n\n# @schema: { type: integer, min: 1, max: 65535 }\nport: 5432\n</code></pre> <ul> <li>Pros: Schema lives with the config, no separate file</li> <li>Cons: Clutters config files, awkward for nested structures, non-standard</li> <li>Rejected: Mixes concerns, makes configs harder to read</li> </ul>"},{"location":"adr/ADR-007-schema-validation/#alternative-4-schema-as-config-holoconf-native-format","title":"Alternative 4: Schema-as-Config (holoconf-native format)","text":"<p>A custom schema format designed specifically for holoconf, optimized for the common case.</p> <pre><code># schema.holoconf.yaml\ndatabase:\n  _description: Database connection settings\n  host:\n    _type: string\n    _required: true\n    _description: Database hostname\n    _examples: [localhost, db.example.com]\n  port:\n    _type: integer\n    _range: [1, 65535]\n    _default: 5432\n  password:\n    _type: string\n    _description: Database password (typically from SSM)\n</code></pre> <ul> <li>Pros: Mirrors config structure exactly, easy to understand, minimal syntax</li> <li>Cons: Yet another schema format, no existing tooling</li> <li>Status: Under consideration</li> </ul>"},{"location":"adr/ADR-007-schema-validation/#alternative-5-language-native-types-codegen","title":"Alternative 5: Language-Native Types (codegen)","text":"<p>Generate schemas from language-native type definitions.</p> <pre><code># Python\n@holoconf.schema\nclass DatabaseConfig:\n    host: str\n    port: int = 5432\n    password: str | None = None\n</code></pre> <pre><code>// TypeScript\ninterface DatabaseConfig {\n  host: string;\n  port?: number;\n  password?: string;\n}\n</code></pre> <ul> <li>Pros: Type-safe access in each language, IDE autocomplete</li> <li>Cons: Language-specific, requires codegen step, schema not portable</li> <li>Rejected: Violates language-agnostic constraint</li> </ul>"},{"location":"adr/ADR-007-schema-validation/#open-questions-proposal-phase","title":"Open Questions (Proposal Phase)","text":"<p>All resolved - see Decision section.</p>"},{"location":"adr/ADR-007-schema-validation/#next-steps-proposal-phase","title":"Next Steps (Proposal Phase)","text":"<ul> <li>[ ] Prototype JSON Schema validation in holoconf-core (using a Rust JSON Schema library)</li> <li>[ ] Implement <code>$ref</code> resolution for schema composition</li> <li>[ ] Test two-phase validation with real-world configs</li> <li>[ ] Design error message format for validation failures</li> </ul>"},{"location":"adr/ADR-007-schema-validation/#decision","title":"Decision","text":"<p>JSON Schema (YAML-serialized) with Two-Phase Validation</p> <ul> <li>Schema format: JSON Schema (Draft 2020-12), written in YAML or JSON</li> <li>Schema composition: Support <code>$ref</code> for splitting schemas across files</li> <li>Validation timing: Two-phase (structural after merge, type/value after resolution)</li> <li><code>additionalProperties</code>: Use JSON Schema default behavior (permissive unless explicitly set to <code>false</code>)</li> <li>Interpolation in schemas: Not explicitly supported or documented, but not disabled (schemas are parsed like any YAML file)</li> <li>Language-native type generation: Out of scope for core; may be added as language-specific tooling later</li> </ul>"},{"location":"adr/ADR-007-schema-validation/#design","title":"Design","text":""},{"location":"adr/ADR-007-schema-validation/#schema-format","title":"Schema Format","text":"<p>Schemas use standard JSON Schema, but can be written in any format holoconf supports (YAML, JSON):</p> <pre><code># schema.yaml\ntype: object\nrequired: [database, api]\nproperties:\n  database:\n    type: object\n    description: Database connection settings\n    required: [host]\n    properties:\n      host:\n        type: string\n        description: Database hostname\n        examples: [\"localhost\", \"db.example.com\"]\n      port:\n        type: integer\n        minimum: 1\n        maximum: 65535\n        default: 5432\n      password:\n        type: string\n        description: Database password (typically from SSM resolver)\n  api:\n    type: object\n    properties:\n      timeout:\n        type: number\n        minimum: 0\n        description: Request timeout in seconds\n</code></pre>"},{"location":"adr/ADR-007-schema-validation/#schema-composition-with-ref","title":"Schema Composition with $ref","text":"<p>Large schemas can be split across files using JSON Schema's <code>$ref</code>:</p> <pre><code># schema.yaml (main schema)\ntype: object\nproperties:\n  networking:\n    $ref: \"./schemas/networking.yaml\"\n  application:\n    $ref: \"./schemas/application.yaml\"\n  database:\n    $ref: \"./schemas/database.yaml\"\n</code></pre> <pre><code># schemas/networking.yaml\ntype: object\nrequired: [vpc_id]\nproperties:\n  vpc_id:\n    type: string\n    pattern: \"^vpc-[a-f0-9]+$\"\n  subnets:\n    type: array\n    items:\n      type: string\n      pattern: \"^subnet-[a-f0-9]+$\"\n</code></pre> <pre><code># schemas/database.yaml\ntype: object\nrequired: [host]\nproperties:\n  host:\n    type: string\n  port:\n    type: integer\n    default: 5432\n</code></pre> <p>Refs are resolved relative to the schema file's location.</p>"},{"location":"adr/ADR-007-schema-validation/#two-phase-validation","title":"Two-Phase Validation","text":"<p>Validation happens in two phases to accommodate lazy resolution:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Config.load(\"base.yaml\", \"env.yaml\", schema=\"schema.yaml\")     \u2502\n\u2502                                                                 \u2502\n\u2502  1. Parse all config files                                      \u2502\n\u2502  2. Merge configs (ADR-004)                                     \u2502\n\u2502  3. PHASE 1: Structural validation                              \u2502\n\u2502     - Required keys present (after merge)                       \u2502\n\u2502     - Nesting structure correct                                 \u2502\n\u2502     - No unknown keys (if additionalProperties: false)          \u2502\n\u2502     - Interpolations like ${...} are allowed (not yet resolved) \u2502\n\u2502                                                                 \u2502\n\u2502  Returns Config object (or raises StructuralValidationError)    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              \u2502\n                              \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  config.database.port  (access triggers resolution)             \u2502\n\u2502                                                                 \u2502\n\u2502  1. Resolve interpolation: ${env:DB_PORT} -&gt; \"5432\"             \u2502\n\u2502  2. PHASE 2: Type/value validation                              \u2502\n\u2502     - Type check (is it an integer?)                            \u2502\n\u2502     - Constraints (minimum: 1, maximum: 65535)                  \u2502\n\u2502     - Pattern matching (if specified)                           \u2502\n\u2502                                                                 \u2502\n\u2502  Returns resolved value (or raises TypeValidationError)         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Phase 1 (Structural) - Runs after merge, before any resolution: - Validates required keys are present - Validates object/array nesting matches schema - Validates <code>additionalProperties</code> constraints - Treats <code>${...}</code> interpolations as valid placeholders (any type)</p> <p>Phase 2 (Type/Value) - Runs after each value is resolved: - Validates resolved value matches declared type - Validates constraints (minimum, maximum, pattern, enum, etc.) - Runs automatically when accessing values with lazy resolution</p>"},{"location":"adr/ADR-007-schema-validation/#api-surface","title":"API Surface","text":"<pre><code># Load with schema (structural validation on load)\nconfig = Config.load(\n    \"base.yaml\", \"environment.yaml\",\n    schema=\"schema.yaml\"\n)\n\n# Access triggers resolution + type validation\nport = config.database.port  # Validates integer, range\n\n# Validate entire config explicitly (resolves all + validates all)\nawait config.resolve_all()\nconfig.validate()  # Re-runs full validation on resolved values\n\n# Load without schema, validate later\nconfig = Config.load(\"config.yaml\")\nconfig.validate(schema=\"schema.yaml\")  # Both phases at once\n</code></pre>"},{"location":"adr/ADR-007-schema-validation/#error-messages","title":"Error Messages","text":"<p>Validation errors include path and context:</p> <pre><code>StructuralValidationError: Missing required key\n  Path: database.host\n  Schema: schema.yaml#/properties/database/required\n  Help: Add 'host' key to database section\n\nTypeValidationError: Invalid type after resolution\n  Path: database.port\n  Expected: integer\n  Got: string (\"not-a-number\")\n  Resolved from: ${env:DB_PORT}\n  Schema: schema.yaml#/properties/database/properties/port\n</code></pre>"},{"location":"adr/ADR-007-schema-validation/#rationale","title":"Rationale","text":"<ul> <li>JSON Schema is an industry standard with existing tooling, documentation, and developer familiarity</li> <li>YAML serialization makes schemas readable and consistent with config file format</li> <li>Two-phase validation accommodates lazy resolution while still catching structural errors early</li> <li>Schema composition via <code>$ref</code> enables teams to share and reuse schema definitions</li> <li>Permissive by default avoids surprising users with strict validation they didn't opt into</li> </ul>"},{"location":"adr/ADR-007-schema-validation/#trade-offs-accepted","title":"Trade-offs Accepted","text":"<ul> <li>JSON Schema verbosity in exchange for standard format with existing tooling</li> <li>Two-phase validation adds complexity in exchange for correct handling of lazy resolution</li> <li>No language-native type generation in core in exchange for keeping core language-agnostic</li> </ul>"},{"location":"adr/ADR-007-schema-validation/#migration","title":"Migration","text":"<p>N/A - This is a new feature.</p>"},{"location":"adr/ADR-007-schema-validation/#consequences","title":"Consequences","text":"<ul> <li>Positive: Clear config documentation, early error detection, consistent validation across languages</li> <li>Negative: Additional file to maintain (schema), learning curve for JSON Schema</li> <li>Neutral: Schema validation is optional - configs work without schemas</li> </ul>"},{"location":"adr/ADR-008-error-handling/","title":"ADR-008: Error Handling Strategy","text":""},{"location":"adr/ADR-008-error-handling/#status","title":"Status","text":"<ul> <li>Proposed by: Ryan on 2026-01-07</li> <li>Accepted on: 2026-01-07</li> </ul>"},{"location":"adr/ADR-008-error-handling/#context","title":"Context","text":"<p>holoconf operations can fail in various ways:</p> <ul> <li>Config file not found or unreadable</li> <li>YAML/JSON parse errors</li> <li>Invalid interpolation syntax</li> <li>Resolver failures (network errors, missing secrets, etc.)</li> <li>Schema validation failures</li> <li>Circular reference detection</li> <li>Type coercion failures</li> </ul> <p>We need a consistent error handling strategy that:</p> <ul> <li>Provides clear, actionable error messages</li> <li>Works across FFI boundaries (Rust \u2192 Python/JS/etc.)</li> <li>Helps users quickly identify and fix problems</li> <li>Distinguishes between different failure modes</li> </ul>"},{"location":"adr/ADR-008-error-handling/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/ADR-008-error-handling/#alternative-1-single-error-type","title":"Alternative 1: Single Error Type","text":"<p>All errors are the same type with an error code/message.</p> <pre><code>try:\n    config = Config.load(\"config.yaml\")\nexcept holoconf.Error as e:\n    print(e.code, e.message)\n</code></pre> <ul> <li>Pros: Simple FFI, easy to implement</li> <li>Cons: Hard to handle specific errors programmatically</li> <li>Rejected: Users need to distinguish resolver failures from parse errors</li> </ul>"},{"location":"adr/ADR-008-error-handling/#alternative-2-error-hierarchy-inheritance","title":"Alternative 2: Error Hierarchy (Inheritance)","text":"<p>Structured error types with inheritance.</p> <pre><code>try:\n    config = Config.load(\"config.yaml\")\nexcept holoconf.ResolverError as e:\n    # Handle resolver-specific failure\nexcept holoconf.ParseError as e:\n    # Handle parse failure\nexcept holoconf.Error as e:\n    # Catch-all\n</code></pre> <ul> <li>Pros: Familiar pattern, selective catching, type-safe</li> <li>Cons: More complex FFI mapping</li> <li>Chosen: Best balance of usability and type safety</li> </ul>"},{"location":"adr/ADR-008-error-handling/#alternative-3-result-type-no-exceptions","title":"Alternative 3: Result Type (No Exceptions)","text":"<p>Return result objects instead of throwing.</p> <pre><code>result = Config.load(\"config.yaml\")\nif result.is_err():\n    print(result.error)\nelse:\n    config = result.value\n</code></pre> <ul> <li>Pros: Explicit error handling, no hidden control flow</li> <li>Cons: Unfamiliar in Python/JS, verbose</li> <li>Rejected: Not idiomatic for target languages</li> </ul>"},{"location":"adr/ADR-008-error-handling/#open-questions-proposal-phase","title":"Open Questions (Proposal Phase)","text":"<p>All resolved - see Decision section.</p>"},{"location":"adr/ADR-008-error-handling/#next-steps-proposal-phase","title":"Next Steps (Proposal Phase)","text":"<ul> <li>[ ] Implement error types in holoconf-core</li> <li>[ ] Prototype FFI error mapping in PyO3 and NAPI-RS</li> <li>[ ] Add help text for common error scenarios</li> </ul>"},{"location":"adr/ADR-008-error-handling/#decision","title":"Decision","text":"<p>Error Hierarchy with Rich Context</p> <ul> <li>Use inheritance-based error hierarchy for type-safe selective catching</li> <li>Include rich context: message, code, path, source file/line, cause chain, help text</li> <li>Help text included for common errors; defaults to message when not provided</li> <li>Errors map to native exceptions in each language binding</li> </ul>"},{"location":"adr/ADR-008-error-handling/#design","title":"Design","text":""},{"location":"adr/ADR-008-error-handling/#error-hierarchy","title":"Error Hierarchy","text":"<pre><code>HoloconfError (base)\n\u251c\u2500\u2500 ConfigError\n\u2502   \u251c\u2500\u2500 FileNotFoundError\n\u2502   \u251c\u2500\u2500 ParseError (YAML/JSON syntax)\n\u2502   \u2514\u2500\u2500 MergeError\n\u251c\u2500\u2500 InterpolationError\n\u2502   \u251c\u2500\u2500 SyntaxError (malformed ${...})\n\u2502   \u251c\u2500\u2500 CircularReferenceError\n\u2502   \u2514\u2500\u2500 UnknownResolverError\n\u251c\u2500\u2500 ResolverError\n\u2502   \u251c\u2500\u2500 TimeoutError\n\u2502   \u251c\u2500\u2500 NetworkError\n\u2502   \u2514\u2500\u2500 NotFoundError (SSM key doesn't exist, etc.)\n\u2514\u2500\u2500 ValidationError\n    \u251c\u2500\u2500 StructuralValidationError\n    \u2514\u2500\u2500 TypeValidationError\n</code></pre>"},{"location":"adr/ADR-008-error-handling/#error-information","title":"Error Information","text":"<p>Each error includes:</p> <pre><code>class HoloconfError(Exception):\n    message: str          # Human-readable description\n    code: str             # Machine-readable code (e.g., \"RESOLVER_TIMEOUT\")\n    path: str | None      # Config path where error occurred (e.g., \"database.password\")\n    source_file: str | None  # Which config file\n    source_line: int | None  # Line number if applicable\n    cause: Exception | None  # Underlying error (e.g., network error)\n    help: str | None      # Recovery suggestion\n</code></pre>"},{"location":"adr/ADR-008-error-handling/#error-message-format","title":"Error Message Format","text":"<pre><code>ResolverError: Failed to resolve SSM parameter\n  Path: database.password\n  Resolver: ssm\n  Key: /prod/db/password\n  Source: config.yaml:15\n  Cause: AccessDeniedException - User lacks ssm:GetParameter permission\n  Help: Ensure IAM role has ssm:GetParameter permission for /prod/db/*\n</code></pre>"},{"location":"adr/ADR-008-error-handling/#ffi-mapping","title":"FFI Mapping","text":"<p>Rust errors map to native exceptions:</p> <pre><code>// Rust\n#[derive(Error, Debug)]\npub enum HoloconfError {\n    #[error(\"Failed to parse config: {message}\")]\n    ParseError { message: String, line: Option&lt;u32&gt; },\n\n    #[error(\"Resolver failed: {message}\")]\n    ResolverError { message: String, path: String, cause: Option&lt;String&gt; },\n    // ...\n}\n</code></pre> <pre><code># Python (via PyO3)\nclass ParseError(HoloconfError):\n    pass\n\nclass ResolverError(HoloconfError):\n    pass\n</code></pre> <pre><code>// JavaScript (via NAPI-RS)\nclass ParseError extends HoloconfError {}\nclass ResolverError extends HoloconfError {}\n</code></pre>"},{"location":"adr/ADR-008-error-handling/#rationale","title":"Rationale","text":"<ul> <li>Error hierarchy is idiomatic in Python and JavaScript, enabling selective catching</li> <li>Rich context helps debugging - users can see exactly where and why errors occurred</li> <li>Help text reduces support burden - common mistakes get actionable suggestions</li> <li>Cause chain preserves information - underlying errors aren't lost</li> </ul>"},{"location":"adr/ADR-008-error-handling/#trade-offs-accepted","title":"Trade-offs Accepted","text":"<ul> <li>More complex FFI mapping in exchange for type-safe error handling</li> <li>Larger error objects in exchange for better debugging experience</li> <li>Help text maintenance burden in exchange for better user experience</li> </ul>"},{"location":"adr/ADR-008-error-handling/#migration","title":"Migration","text":"<p>N/A - This is the initial architecture decision.</p>"},{"location":"adr/ADR-008-error-handling/#consequences","title":"Consequences","text":"<ul> <li>Positive: Clear error identification, actionable messages, familiar exception patterns</li> <li>Negative: More code to maintain in FFI layer, help text needs curation</li> <li>Neutral: Error hierarchy may evolve as new error cases are discovered</li> </ul>"},{"location":"adr/ADR-009-serialization-export/","title":"ADR-009: Serialization and Export","text":""},{"location":"adr/ADR-009-serialization-export/#status","title":"Status","text":"<ul> <li>Proposed by: Ryan on 2026-01-07</li> <li>Accepted on: 2026-01-07</li> </ul>"},{"location":"adr/ADR-009-serialization-export/#context","title":"Context","text":"<p>Users may need to export configuration data for various purposes:</p> <ul> <li>Debugging: See the fully resolved config</li> <li>Auditing: Log what config was used for a deployment</li> <li>Templating: Generate config files for other tools</li> <li>Inspection: View merged config before resolution</li> </ul> <p>We need to decide what export capabilities holoconf provides and how they handle sensitive data.</p>"},{"location":"adr/ADR-009-serialization-export/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/ADR-009-serialization-export/#alternative-1-no-export-read-only","title":"Alternative 1: No Export (Read-Only)","text":"<p>Config objects are read-only; no serialization back to YAML/JSON.</p> <ul> <li>Pros: Simpler implementation, no secrets-in-logs risk</li> <li>Cons: Users can't debug or audit configs easily</li> <li>Rejected: Export is essential for debugging and operational visibility</li> </ul>"},{"location":"adr/ADR-009-serialization-export/#alternative-2-full-export-no-redaction","title":"Alternative 2: Full Export (No Redaction)","text":"<p>Export everything as-is, including resolved secrets.</p> <pre><code>config.to_yaml()  # Includes passwords, API keys, etc.\n</code></pre> <ul> <li>Pros: Simple, complete</li> <li>Cons: Security risk - secrets in logs/files</li> <li>Rejected: Too dangerous as default behavior</li> </ul>"},{"location":"adr/ADR-009-serialization-export/#alternative-3-export-with-redaction-options","title":"Alternative 3: Export with Redaction Options","text":"<p>Provide export with configurable handling of sensitive values.</p> <pre><code>config.to_yaml(redact=True)      # Replaces secrets with \"[REDACTED]\"\nconfig.to_yaml(resolve=False)    # Shows ${...} placeholders\n</code></pre> <ul> <li>Pros: Flexible, safe defaults possible</li> <li>Cons: More complex API</li> <li>Chosen: Best balance of safety and usability</li> </ul>"},{"location":"adr/ADR-009-serialization-export/#open-questions-proposal-phase","title":"Open Questions (Proposal Phase)","text":"<p>All resolved - see Decision section.</p>"},{"location":"adr/ADR-009-serialization-export/#next-steps-proposal-phase","title":"Next Steps (Proposal Phase)","text":"<ul> <li>[ ] Implement export methods in holoconf-core</li> <li>[ ] Implement resolver-aware redaction logic</li> <li>[ ] Add schema-based and pattern-based redaction (future enhancement)</li> </ul>"},{"location":"adr/ADR-009-serialization-export/#decision","title":"Decision","text":"<p>Export with Resolver-Aware Redaction</p> <ul> <li>Output formats: YAML and JSON</li> <li>Default behavior: <code>resolve=False</code> (shows <code>${...}</code> placeholders, safest and fastest)</li> <li>Redaction: Resolver-implementation-aware (e.g., SSM <code>SecureString</code> types redacted, regular <code>String</code> types not)</li> <li>Redaction scope: Only affects serialization methods, not value access</li> <li>Flattened export: Out of scope for v1; can be added later if needed</li> <li>Future enhancements: Key pattern redaction, schema-based redaction (<code>x-sensitive</code>)</li> </ul>"},{"location":"adr/ADR-009-serialization-export/#design","title":"Design","text":""},{"location":"adr/ADR-009-serialization-export/#export-api","title":"Export API","text":"<pre><code># Export as YAML (default: unresolved, shows ${...} placeholders)\nyaml_str = config.to_yaml()\n\n# Export resolved values with automatic redaction of secrets\nyaml_str = config.to_yaml(resolve=True, redact=True)\n\n# Export resolved values WITHOUT redaction (use with caution)\nyaml_str = config.to_yaml(resolve=True, redact=False)\n\n# Export as JSON\njson_str = config.to_json()\njson_str = config.to_json(resolve=True, redact=True)\n\n# Export as dict (for programmatic use)\ndata = config.to_dict()\ndata = config.to_dict(resolve=True, redact=True)\n</code></pre>"},{"location":"adr/ADR-009-serialization-export/#export-modes","title":"Export Modes","text":"Mode <code>resolve</code> <code>redact</code> Output Default (safe) <code>False</code> N/A Shows <code>${ssm:/path}</code> placeholders Debug (resolved) <code>True</code> <code>True</code> Shows resolved values, secrets redacted Full export <code>True</code> <code>False</code> Shows everything including secrets"},{"location":"adr/ADR-009-serialization-export/#resolver-aware-redaction","title":"Resolver-Aware Redaction","text":"<p>Redaction is determined by the resolver implementation, not just the resolver name:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Redaction Decision Tree                       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                 \u2502\n\u2502  SSM Resolver:                                                  \u2502\n\u2502  \u251c\u2500\u2500 Parameter type is SecureString? \u2192 REDACT                   \u2502\n\u2502  \u251c\u2500\u2500 Value is Secrets Manager reference? \u2192 REDACT               \u2502\n\u2502  \u2514\u2500\u2500 Regular String parameter? \u2192 DO NOT REDACT                  \u2502\n\u2502                                                                 \u2502\n\u2502  Vault Resolver:                                                \u2502\n\u2502  \u2514\u2500\u2500 All values \u2192 REDACT (it's a secrets manager)               \u2502\n\u2502                                                                 \u2502\n\u2502  Secrets Manager Resolver:                                      \u2502\n\u2502  \u2514\u2500\u2500 All values \u2192 REDACT                                        \u2502\n\u2502                                                                 \u2502\n\u2502  Env Resolver:                                                  \u2502\n\u2502  \u2514\u2500\u2500 All values \u2192 DO NOT REDACT (by default)                    \u2502\n\u2502                                                                 \u2502\n\u2502  Self-Reference Resolver:                                       \u2502\n\u2502  \u2514\u2500\u2500 Inherits sensitivity from source value                     \u2502\n\u2502                                                                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Example:</p> <pre><code># config.yaml\ndatabase:\n  host: ${ssm:/prod/db/host}          # SSM String \u2192 not redacted\n  password: ${ssm:/prod/db/password}  # SSM SecureString \u2192 redacted\n  api_key: ${vault:secret/api/key}    # Vault \u2192 redacted\n  vpc_id: ${ssm:/prod/vpc-id}         # SSM String \u2192 not redacted\n\n# Output with resolve=True, redact=True\ndatabase:\n  host: \"db.prod.example.com\"\n  password: \"[REDACTED]\"\n  api_key: \"[REDACTED]\"\n  vpc_id: \"vpc-abc123\"\n</code></pre>"},{"location":"adr/ADR-009-serialization-export/#binary-data-handling","title":"Binary Data Handling","text":"<p>Binary data (from the file resolver with <code>encoding=binary</code>) is handled as follows:</p> <ul> <li>YAML/JSON serialization: Binary data is encoded as base64 strings</li> <li>Python <code>to_dict()</code>: Binary data is returned as native Python <code>bytes</code> objects</li> <li>CLI text output: Binary data is printed as base64-encoded strings</li> </ul> <p>Example: <pre><code># config.yaml\ncertificate: ${file:cert.der,encoding=binary}\n\n# Output with to_yaml(resolve=True)\ncertificate: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0t...\n\n# Python to_dict()\n{\"certificate\": b'\\x30\\x82\\x03\\x75...'}  # Native bytes\n</code></pre></p>"},{"location":"adr/ADR-009-serialization-export/#redaction-scope","title":"Redaction Scope","text":"<p>Important: Redaction only applies to serialization methods. Once a value is accessed programmatically, holoconf cannot prevent it from being logged or printed.</p> <pre><code># Redaction works here:\nconfig.to_yaml(resolve=True, redact=True)  # \"[REDACTED]\"\n\n# Redaction does NOT apply here - user has the raw value:\npassword = config.database.password  # Returns actual secret string\nprint(password)                      # User's responsibility\n</code></pre> <p>This is intentional - holoconf is a configuration library, not a secrets management SDK. Users who need value-level protection (e.g., types that refuse to print themselves) should use dedicated secrets libraries.</p>"},{"location":"adr/ADR-009-serialization-export/#future-enhancements-out-of-scope-for-v1","title":"Future Enhancements (Out of Scope for v1)","text":"<p>Key pattern redaction: <pre><code>config.to_yaml(resolve=True, redact=True, redact_patterns=[\"*password*\", \"*secret*\"])\n</code></pre></p> <p>Schema-based redaction: <pre><code># schema.yaml\nproperties:\n  custom_secret:\n    type: string\n    x-sensitive: true  # JSON Schema extension\n</code></pre></p> <p>Flattened export: <pre><code>config.to_flat_dict()  # {\"database.host\": \"...\", \"database.port\": 5432}\n</code></pre></p>"},{"location":"adr/ADR-009-serialization-export/#rationale","title":"Rationale","text":"<ul> <li><code>resolve=False</code> as default is safest - no secrets exposed, no resolver calls needed</li> <li>Resolver-aware redaction is smarter than blanket resolver-name redaction (not all SSM values are secrets)</li> <li>YAML + JSON covers the input formats; TOML can be added if demand exists</li> <li>No value-level protection keeps the API simple and expectations clear</li> </ul>"},{"location":"adr/ADR-009-serialization-export/#trade-offs-accepted","title":"Trade-offs Accepted","text":"<ul> <li>Redaction only at serialization in exchange for simple, predictable value access</li> <li>Resolver must report sensitivity in exchange for accurate redaction</li> <li>No flattened export initially in exchange for simpler initial implementation</li> </ul>"},{"location":"adr/ADR-009-serialization-export/#migration","title":"Migration","text":"<p>N/A - This is a new feature.</p>"},{"location":"adr/ADR-009-serialization-export/#consequences","title":"Consequences","text":"<ul> <li>Positive: Safe debugging, audit trails, operational visibility without secret exposure</li> <li>Negative: Users must be careful with <code>redact=False</code>; resolver implementations must track sensitivity</li> <li>Neutral: Future pattern/schema-based redaction can be added without breaking changes</li> </ul>"},{"location":"adr/ADR-010-thread-safety/","title":"ADR-010: Thread Safety and Concurrency","text":""},{"location":"adr/ADR-010-thread-safety/#status","title":"Status","text":"<ul> <li>Proposed by: Ryan on 2026-01-07</li> <li>Accepted on: 2026-01-07</li> </ul>"},{"location":"adr/ADR-010-thread-safety/#context","title":"Context","text":"<p>The Config object may be accessed from multiple threads/contexts:</p> <ul> <li>Python: Multiple threads (with GIL), async tasks</li> <li>JavaScript: Event loop, worker threads</li> <li>Go: Multiple goroutines</li> <li>Java: Multiple threads</li> <li>Rust: Multiple threads</li> </ul> <p>Key questions:</p> <ul> <li>Can a Config object be safely shared across threads?</li> <li>What happens if two threads access the same unresolved value simultaneously?</li> <li>How does lazy resolution interact with concurrent access?</li> <li>How does memoization work under concurrent access?</li> </ul>"},{"location":"adr/ADR-010-thread-safety/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/ADR-010-thread-safety/#alternative-1-single-threaded-only","title":"Alternative 1: Single-Threaded Only","text":"<p>Config objects are not thread-safe; users must not share across threads.</p> <ul> <li>Pros: Simpler implementation, no synchronization overhead</li> <li>Cons: Limits use cases, error-prone (silent data races)</li> <li>Rejected: Multi-threaded access is a common pattern</li> </ul>"},{"location":"adr/ADR-010-thread-safety/#alternative-2-full-thread-safety-internal-locking","title":"Alternative 2: Full Thread Safety (Internal Locking)","text":"<p>Config objects are fully thread-safe with internal synchronization.</p> <pre><code># Safe to do from multiple threads\nconfig = Config.load(\"config.yaml\")\n# Thread 1: config.database.host\n# Thread 2: config.database.port\n# Thread 3: config.api.timeout\n</code></pre> <ul> <li>Pros: Users don't need to think about synchronization</li> <li>Cons: Synchronization overhead, potential for deadlocks</li> <li>Chosen: With per-value locking (not whole-config locking) to minimize contention</li> </ul>"},{"location":"adr/ADR-010-thread-safety/#alternative-3-clone-for-thread-transfer","title":"Alternative 3: Clone for Thread Transfer","text":"<p>Config objects are not thread-safe, but cheap to clone.</p> <pre><code>config = Config.load(\"config.yaml\")\n# Pass clone to each thread\nthread1_config = config.clone()\nthread2_config = config.clone()\n</code></pre> <ul> <li>Pros: No synchronization overhead during access, clear ownership</li> <li>Cons: Memory duplication, resolved values not shared</li> <li>Rejected: Wastes memory and resolver calls; shared cache is more efficient</li> </ul>"},{"location":"adr/ADR-010-thread-safety/#alternative-4-read-only-after-load","title":"Alternative 4: Read-Only After Load","text":"<p>Config becomes immutable and thread-safe after initial resolution.</p> <pre><code>config = Config.load(\"config.yaml\")\nawait config.resolve_all()  # After this, config is read-only and thread-safe\n# Now safe to share across threads\n</code></pre> <ul> <li>Pros: Clear lifecycle, no synchronization during reads</li> <li>Cons: Forces eager resolution, doesn't work with lazy access pattern</li> <li>Rejected: Conflicts with lazy resolution (ADR-005)</li> </ul>"},{"location":"adr/ADR-010-thread-safety/#open-questions-proposal-phase","title":"Open Questions (Proposal Phase)","text":"<p>All resolved - see Decision section.</p>"},{"location":"adr/ADR-010-thread-safety/#next-steps-proposal-phase","title":"Next Steps (Proposal Phase)","text":"<ul> <li>[ ] Implement <code>Arc&lt;RwLock&lt;Cache&gt;&gt;</code> pattern in holoconf-core</li> <li>[ ] Add async variants to language bindings (Python awaitable, JS Promise)</li> <li>[ ] Benchmark locking overhead vs no-locking baseline</li> <li>[ ] Test with Python GIL, JS event loop, Go goroutines</li> </ul>"},{"location":"adr/ADR-010-thread-safety/#decision","title":"Decision","text":"<p>Thread-Safe Config with Per-Value Locking and Shared Cache</p> <ul> <li>Locking granularity: Per-value locking; first accessor resolves, others wait for cached result</li> <li>Clone semantics: Shared cache via <code>Arc</code> - clones share resolved values, memory efficient</li> <li><code>resolve_all()</code> pattern: Supported - after completion, all access is cache reads with no blocking</li> <li>Language runtimes: Async handled in Rust (tokio); bindings expose both sync and async APIs</li> <li>Config implements <code>Send + Sync</code> in Rust</li> </ul>"},{"location":"adr/ADR-010-thread-safety/#design","title":"Design","text":""},{"location":"adr/ADR-010-thread-safety/#thread-safe-with-per-value-locking","title":"Thread-Safe with Per-Value Locking","text":"<p>Config objects are thread-safe with fine-grained locking:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     Config Object                            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502              Resolved Value Cache                    \u2502    \u2502\n\u2502  \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510             \u2502    \u2502\n\u2502  \u2502  \u2502 db.host \u2502  \u2502 db.port \u2502  \u2502 api.key \u2502  ...        \u2502    \u2502\n\u2502  \u2502  \u2502 [Lock]  \u2502  \u2502 [Lock]  \u2502  \u2502 [Lock]  \u2502             \u2502    \u2502\n\u2502  \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"adr/ADR-010-thread-safety/#concurrent-resolution-behavior","title":"Concurrent Resolution Behavior","text":"<p>When two threads access the same unresolved value simultaneously:</p> <pre><code>Thread 1: config.database.password\nThread 2: config.database.password\n\nTimeline:\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\nT1: Check cache (miss) \u2192 Acquire lock \u2192 Start resolution\nT2: Check cache (miss) \u2192 Wait on lock...\nT1: Resolution complete \u2192 Store in cache \u2192 Release lock\nT2: Acquire lock \u2192 Check cache (hit!) \u2192 Release lock \u2192 Return cached value\n</code></pre> <p>Only one resolution occurs; the second thread waits and gets the cached result.</p>"},{"location":"adr/ADR-010-thread-safety/#language-specific-considerations","title":"Language-Specific Considerations","text":"<p>Python (GIL) - GIL provides some protection, but async and thread pools need explicit safety - PyO3 releases GIL during Rust operations; re-acquire for callbacks</p> <p>JavaScript (Event Loop) - Single-threaded event loop; concurrency via async - Worker threads are separate isolates (would need separate Config instances) - Main concern: async resolution interleaving</p> <p>Go (Goroutines) - True parallelism; needs proper synchronization - cgo boundary considerations</p> <p>Rust (Native) - <code>Config</code> implements <code>Send + Sync</code> - Internal <code>RwLock</code> or similar for cache access</p>"},{"location":"adr/ADR-010-thread-safety/#api-surface","title":"API Surface","text":"<pre><code># Thread-safe by default\nconfig = Config.load(\"config.yaml\")\n\n# Explicit clone if needed (shares resolved cache via Arc)\nconfig_clone = config.clone()  # Cheap, shares underlying data\n\n# Check if a value is already resolved (non-blocking)\nif config.is_resolved(\"database.password\"):\n    # Will not trigger resolution or block\n    password = config.database.password\n</code></pre>"},{"location":"adr/ADR-010-thread-safety/#resolution-lock-semantics","title":"Resolution Lock Semantics","text":"Operation Locking Behavior Access resolved value Read lock (concurrent reads OK) Access unresolved value Write lock (blocks other accessors of same key) <code>resolve_all()</code> Acquires locks per-key as needed <code>to_yaml()</code> / <code>to_dict()</code> Read locks on accessed values"},{"location":"adr/ADR-010-thread-safety/#rationale","title":"Rationale","text":"<ul> <li>Per-value locking avoids duplicate resolver calls - if two threads access the same unresolved value, only one calls the resolver</li> <li>Shared cache via Arc is idiomatic Rust - cheap clones, memory efficient, resolved values available to all clones</li> <li><code>resolve_all()</code> enables contention-free sharing - users who want zero blocking during access can resolve upfront</li> <li>Async in Rust, sync+async bindings - keeps complexity in one place, language bindings stay simple</li> </ul>"},{"location":"adr/ADR-010-thread-safety/#trade-offs-accepted","title":"Trade-offs Accepted","text":"<ul> <li>Per-value locking overhead in exchange for preventing duplicate resolver calls</li> <li>Shared cache means clones aren't isolated in exchange for memory efficiency and shared resolution work</li> <li>Blocking on unresolved values in exchange for simple, predictable API (use <code>resolve_all()</code> to avoid)</li> </ul>"},{"location":"adr/ADR-010-thread-safety/#migration","title":"Migration","text":"<p>N/A - This is the initial architecture decision.</p>"},{"location":"adr/ADR-010-thread-safety/#consequences","title":"Consequences","text":"<ul> <li>Positive: Safe concurrent access, no duplicate resolver calls, efficient memory usage</li> <li>Negative: Threads may block waiting for resolution; requires understanding of lazy resolution behavior</li> <li>Neutral: Users wanting full isolation can load separate Config instances instead of cloning</li> </ul>"},{"location":"adr/ADR-011-interpolation-syntax/","title":"ADR-011: Interpolation Syntax","text":""},{"location":"adr/ADR-011-interpolation-syntax/#status","title":"Status","text":"<ul> <li>Proposed by: Ryan on 2026-01-07</li> <li>Accepted on: 2026-01-07</li> </ul>"},{"location":"adr/ADR-011-interpolation-syntax/#context","title":"Context","text":"<p>ADR-002 established the basic interpolation syntax (<code>${resolver:key}</code> for external, <code>${path}</code> for self-reference). However, several edge cases and advanced features need to be defined:</p> <ul> <li>How to escape interpolation syntax (literal <code>${...}</code>)</li> <li>Whether nested interpolations are supported</li> <li>Default/fallback values when resolution fails</li> <li>String concatenation with interpolations</li> </ul> <p>These decisions affect the parser implementation in holoconf-core and user experience.</p>"},{"location":"adr/ADR-011-interpolation-syntax/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/ADR-011-interpolation-syntax/#escaping","title":"Escaping","text":"<p>Option A: Double dollar sign <pre><code>literal: $${not_interpolated}  # Outputs: ${not_interpolated}\n</code></pre> - Rejected: Not OmegaConf-compatible</p> <p>Option B: Backslash escape <pre><code>literal: \\${not_interpolated}  # Outputs: ${not_interpolated}\n</code></pre> - Chosen: Matches OmegaConf</p> <p>Option C: No escaping (use quotes or different key) <pre><code>literal: \"${not_interpolated}\"  # Still interpolated in most systems\n</code></pre> - Rejected: Not practical</p>"},{"location":"adr/ADR-011-interpolation-syntax/#nested-interpolations","title":"Nested Interpolations","text":"<p>Option A: Not supported <pre><code># Invalid - parse error\npath: ${ssm:${env:SSM_PREFIX}/password}\n</code></pre> - Rejected: Limits flexibility</p> <p>Option B: Supported (inside-out resolution) <pre><code># Valid - resolves env:SSM_PREFIX first, then ssm:\npath: ${ssm:${env:SSM_PREFIX}/password}\n# If SSM_PREFIX=/prod \u2192 resolves ${ssm:/prod/password}\n</code></pre> - Chosen: Matches OmegaConf, enables dynamic key construction</p>"},{"location":"adr/ADR-011-interpolation-syntax/#default-values","title":"Default Values","text":"<p>Option A: Colon syntax (shell-style) <pre><code>port: ${env:PORT:8080}           # Use 8080 if PORT not set\nhost: ${env:HOST:localhost}      # Use localhost if HOST not set\n</code></pre> - Rejected: Conflicts with resolver:key syntax</p> <p>Option B: Pipe syntax <pre><code>port: ${env:PORT | 8080}\nhost: ${env:HOST | localhost}\n</code></pre> - Rejected: Non-standard syntax</p> <p>Option C: Positional comma syntax (OmegaConf-style) <pre><code>port: ${env:PORT,8080}           # Use 8080 if PORT not set\nhost: ${env:HOST,localhost}      # Use localhost if HOST not set\n</code></pre> - Rejected: Ambiguous when default contains commas, requires each resolver to implement default handling</p> <p>Option D: Keyword argument syntax <pre><code>port: ${env:PORT,default=8080}           # Use 8080 if PORT not set\nhost: ${env:HOST,default=localhost}      # Use localhost if HOST not set\n</code></pre> - Chosen: Explicit, unambiguous, handled by framework (not individual resolvers)</p> <p>Option E: Not supported (fail if missing) <pre><code>port: ${env:PORT}  # Error if PORT not set\n</code></pre> - Rejected: Too inflexible</p>"},{"location":"adr/ADR-011-interpolation-syntax/#string-concatenation","title":"String Concatenation","text":"<p>Option A: Inline interpolation <pre><code>url: \"https://${host}:${port}/api\"\nconnection: \"postgresql://${db.user}:${db.password}@${db.host}/${db.name}\"\n</code></pre> - Chosen: Matches OmegaConf, intuitive syntax</p> <p>Option B: Explicit concat resolver <pre><code>url: ${concat:https://,${host},:,${port},/api}\n</code></pre> - Rejected: Verbose, not needed when inline interpolation works</p>"},{"location":"adr/ADR-011-interpolation-syntax/#open-questions-proposal-phase","title":"Open Questions (Proposal Phase)","text":"<p>All resolved - see Decision section.</p>"},{"location":"adr/ADR-011-interpolation-syntax/#next-steps-proposal-phase","title":"Next Steps (Proposal Phase)","text":"<ul> <li>[ ] Implement parser in holoconf-core matching OmegaConf grammar</li> <li>[ ] Test edge cases (nested quotes, special characters, escaping)</li> <li>[ ] Validate compatibility with existing OmegaConf configs</li> </ul>"},{"location":"adr/ADR-011-interpolation-syntax/#decision","title":"Decision","text":"<p>OmegaConf-Inspired Interpolation Syntax with Framework-Level Keywords</p> <p>Align with OmegaConf syntax where practical, with improvements for clarity and consistency:</p> <ul> <li>Escaping: <code>\\${...}</code> (backslash) to output literal <code>${...}</code></li> <li>Nested interpolations: Supported, resolve inside-out</li> <li>Self-references: <code>${path.to.value}</code> (absolute) and <code>${..relative}</code> (relative)</li> <li>Resolver syntax: <code>${resolver:arg,key=value,...}</code> with positional args and keyword arguments</li> <li>Framework keywords: <code>default</code> and <code>sensitive</code> are handled by the resolver framework, not individual resolvers</li> <li>Limits: 10 nesting levels, 100 interpolations per value, 10,000 characters (safety limits)</li> </ul>"},{"location":"adr/ADR-011-interpolation-syntax/#design","title":"Design","text":""},{"location":"adr/ADR-011-interpolation-syntax/#syntax-omegaconf-compatible","title":"Syntax (OmegaConf-Compatible)","text":""},{"location":"adr/ADR-011-interpolation-syntax/#basic-interpolation","title":"Basic Interpolation","text":"<pre><code># Self-reference (absolute path from root)\ntimeout: ${defaults.timeout}\n\n# Self-reference (relative path)\ntimeout: ${.sibling_key}\ntimeout: ${..parent.sibling}\n\n# External resolver\npassword: ${ssm:/prod/db/password}\napi_key: ${env:API_KEY}\n</code></pre>"},{"location":"adr/ADR-011-interpolation-syntax/#escaping_1","title":"Escaping","text":"<pre><code># Backslash to escape (OmegaConf-compatible)\nliteral: \\${this_is_not_interpolated}\n# Resolves to: ${this_is_not_interpolated}\n\n# Backslash before interpolation that should resolve\npath: \"C:\\\\${dir}\"\n# Resolves to: C:\\&lt;resolved value of dir&gt;\n\n# In strings\nmessage: \"Cost is \\${price} dollars\"\n# Resolves to: Cost is ${price} dollars\n</code></pre>"},{"location":"adr/ADR-011-interpolation-syntax/#default-values_1","title":"Default Values","text":"<pre><code># Keyword syntax for defaults (framework-handled)\nport: ${env:PORT,default=8080}\nhost: ${env:HOST,default=localhost}\nlog_level: ${env:LOG_LEVEL,default=info}\n\n# Default can be another interpolation\npassword: ${env:DB_PASSWORD,default=${ssm:/default/db/password}}\n\n# Self-references also support default\ntimeout: ${settings.timeout,default=30}\n\n# Cascading defaults with nested interpolations\nport: ${env:PORT,default=${env:DEFAULT_PORT,default=8080}}\n</code></pre>"},{"location":"adr/ADR-011-interpolation-syntax/#string-concatenation_1","title":"String Concatenation","text":"<pre><code># Interpolations within strings\ndatabase_url: \"postgresql://${db.host}:${db.port}/${db.name}\"\napi_endpoint: \"https://${api.host}/v${api.version}/users\"\nlog_prefix: \"[${app.name}] \"\n</code></pre>"},{"location":"adr/ADR-011-interpolation-syntax/#nested-interpolations_1","title":"Nested Interpolations","text":"<pre><code># Nested interpolations resolve inside-out\n# Step 1: ${env:ENV} \u2192 \"prod\"\n# Step 2: ${ssm:/prod/db/password} \u2192 \"secret123\"\npassword: ${ssm:/${env:ENV}/db/password}\n\n# More complex nesting\n# Step 1: ${env:REGION} \u2192 \"us-east-1\"\n# Step 2: ${env:ACCOUNT} \u2192 \"123456\"\n# Step 3: ${ssm:/us-east-1/123456/api-key} \u2192 \"key123\"\napi_key: ${ssm:/${env:REGION}/${env:ACCOUNT}/api-key}\n</code></pre>"},{"location":"adr/ADR-011-interpolation-syntax/#framework-level-keyword-arguments","title":"Framework-Level Keyword Arguments","text":"<p>The resolver framework handles two special keyword arguments that apply to all resolvers uniformly. Individual resolvers do not implement these\u2014they are extracted and processed by the framework before and after calling the resolver.</p>"},{"location":"adr/ADR-011-interpolation-syntax/#default-keyword","title":"<code>default</code> Keyword","text":"<p>Provides a fallback value when the resolver cannot find the requested resource (e.g., missing env var, file not found, SSM parameter doesn't exist).</p> <pre><code># Framework extracts default=, calls resolver, uses default if resolver returns NotFound\nport: ${env:PORT,default=8080}\nconfig: ${file:./optional.yaml,default={}}\ntimeout: ${ssm:/app/timeout,default=30}\n</code></pre> <p>Behavior: 1. Framework parses the interpolation and extracts <code>default=</code> if present 2. Framework calls the resolver with remaining arguments 3. If resolver returns <code>NotFound</code> error and default is set, framework returns default value 4. If resolver returns other errors (e.g., permission denied, network error), error propagates (default not used) 5. If resolver succeeds, default is ignored</p>"},{"location":"adr/ADR-011-interpolation-syntax/#sensitive-keyword","title":"<code>sensitive</code> Keyword","text":"<p>Marks the resolved value as sensitive for redaction during serialization (see ADR-009).</p> <pre><code># Mark value as sensitive (affects serialization only)\napi_key: ${env:API_KEY,sensitive=true}\npassword: ${file:./secret.key,sensitive=true}\n\n# Override resolver's default sensitivity\nnon_secret_param: ${ssm:/app/public-config,sensitive=false}\n</code></pre> <p>Behavior: 1. Framework parses the interpolation and extracts <code>sensitive=</code> if present 2. Framework calls the resolver, which may return a sensitivity hint (e.g., SSM SecureString \u2192 sensitive) 3. If user specified <code>sensitive=</code>, that value overrides the resolver's hint 4. If user did not specify, resolver's hint is used (or <code>false</code> if resolver provides no hint) 5. Sensitivity only affects serialization (<code>to_yaml(redact=True)</code>), not value access</p>"},{"location":"adr/ADR-011-interpolation-syntax/#sensitivity-inheritance","title":"Sensitivity Inheritance","text":"<p>For self-references, sensitivity is inherited from the referenced value by default:</p> <pre><code>secrets:\n  api_key: ${env:API_KEY,sensitive=true}\n\n# Inherits sensitive=true from the referenced value\nderived: ${secrets.api_key}\n\n# Can override if needed (rare)\npublic_copy: ${secrets.api_key,sensitive=false}\n</code></pre>"},{"location":"adr/ADR-011-interpolation-syntax/#framework-resolution-flow","title":"Framework Resolution Flow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Interpolation: ${resolver:arg,default=X,sensitive=Y,opt=Z} \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2502\n                            \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  1. Parse and extract framework keywords                    \u2502\n\u2502     - default = X                                           \u2502\n\u2502     - sensitive = Y                                         \u2502\n\u2502     - remaining kwargs = {opt: Z}                           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2502\n                            \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  2. Call resolver.resolve(arg, opt=Z)                       \u2502\n\u2502     - Resolver only sees its own arguments                  \u2502\n\u2502     - Returns ResolvedValue(value, sensitive_hint)          \u2502\n\u2502       OR NotFound error                                     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2502\n              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n              \u25bc                           \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  NotFound + default  \u2502    \u2502  Success or other error      \u2502\n\u2502  \u2192 Use default value \u2502    \u2502  \u2192 Use resolver's value/error\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2502\n                            \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  3. Apply sensitivity override                              \u2502\n\u2502     - If user specified sensitive=Y, use Y                  \u2502\n\u2502     - Else use resolver's hint (or false)                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                            \u2502\n                            \u25bc\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  4. Return final ResolvedValue(value, is_sensitive)         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"adr/ADR-011-interpolation-syntax/#grammar","title":"Grammar","text":"<pre><code>interpolation  = \"${\" expression \"}\"\nexpression     = resolver_ref | self_ref\nresolver_ref   = resolver_name \":\" args\nself_ref       = path (\",\" kwargs)?\npath           = relative_path | absolute_path\nrelative_path  = \".\"+ path_segment (\".\" path_segment)*\nabsolute_path  = path_segment (\".\" path_segment)*\npath_segment   = identifier | \"[\" index \"]\"\nargs           = positional_arg* (\",\" kwarg)*\npositional_arg = value\nkwarg          = identifier \"=\" value\nvalue          = quoted_string | unquoted_value | interpolation\nquoted_string  = \"'\" [^']* \"'\" | '\"' [^\"]* '\"'\nunquoted_value = [^,=}]+                    # Until comma, equals, or closing brace\nescape         = \"\\${\"                      # Produces literal \"${\"\nkwargs         = kwarg (\",\" kwarg)*         # For self-references with options\n</code></pre> <p>Reserved Keywords (handled by framework): - <code>default</code> - Fallback value if resolver returns NotFound - <code>sensitive</code> - Override sensitivity for redaction</p>"},{"location":"adr/ADR-011-interpolation-syntax/#edge-cases","title":"Edge Cases","text":"Input Output Notes <code>${env:PORT}</code> <code>\"8080\"</code> Basic resolver <code>${env:PORT,default=3000}</code> <code>\"8080\"</code> or <code>\"3000\"</code> With default keyword <code>${env:API_KEY,sensitive=true}</code> Value, marked sensitive Sensitivity override <code>\\${env:PORT}</code> <code>\"${env:PORT}\"</code> Escaped (backslash) <code>\"http://${host}\"</code> <code>\"http://localhost\"</code> String interpolation <code>${ssm:/${env:E}/k}</code> Resolved value Nested interpolation <code>${a.b.c}</code> Value at path Self-reference <code>${.sibling}</code> Value at sibling Relative reference <code>${a.b,default=30}</code> Value or <code>30</code> Self-reference with default <code>${env:X,default=${env:Y,default=z}}</code> Cascading defaults Nested defaults"},{"location":"adr/ADR-011-interpolation-syntax/#resolution-order","title":"Resolution Order","text":"<p>For nested interpolations, resolution happens inside-out:</p> <pre><code>value: ${ssm:/${env:PREFIX}/key}\n\n# Resolution steps:\n# 1. Parse outer interpolation: ssm:/${env:PREFIX}/key\n# 2. Find nested interpolation: ${env:PREFIX}\n# 3. Resolve inner first: env:PREFIX \u2192 \"prod\"\n# 4. Substitute: ssm:/prod/key\n# 5. Resolve outer: ssm:/prod/key \u2192 \"secret_value\"\n# 6. Final value: \"secret_value\"\n</code></pre>"},{"location":"adr/ADR-011-interpolation-syntax/#limits","title":"Limits","text":"<p>To prevent abuse and ensure predictable behavior:</p> <ul> <li>Max nesting depth: 10 levels</li> <li>Max interpolations per value: 100</li> <li>Max interpolation length: 10,000 characters</li> </ul> <p>Exceeding limits raises <code>InterpolationError</code>.</p>"},{"location":"adr/ADR-011-interpolation-syntax/#rationale","title":"Rationale","text":"<ul> <li>OmegaConf-inspired syntax provides familiarity for users of similar tools</li> <li>Backslash escaping matches OmegaConf and is familiar from other languages</li> <li>Keyword syntax for <code>default</code> is explicit and avoids ambiguity with comma-containing values</li> <li>Framework-level keywords ensure consistent behavior across all resolvers without code duplication</li> <li>Nested interpolations enable dynamic key construction, a powerful feature</li> <li>Safety limits prevent runaway parsing without breaking normal use cases</li> <li>Sensitivity as framework concern keeps resolver implementations simple (they just return values with hints)</li> </ul>"},{"location":"adr/ADR-011-interpolation-syntax/#trade-offs-accepted","title":"Trade-offs Accepted","text":"<ul> <li>Keyword syntax differs from OmegaConf's positional defaults in exchange for clarity and framework-level handling</li> <li>Backslash escaping in YAML can be tricky (YAML also uses backslash), in exchange for OmegaConf compatibility</li> <li>Resolvers cannot override framework keywords in exchange for consistent, predictable behavior</li> </ul>"},{"location":"adr/ADR-011-interpolation-syntax/#migration","title":"Migration","text":"<p>From OmegaConf: Most configs require minor changes for defaults: - holoconf uses <code>${env:VAR,default=value}</code> while OmegaConf uses <code>${oc.env:VAR,value}</code> (positional) - holoconf uses <code>${env:VAR}</code> while OmegaConf uses <code>${oc.env:VAR}</code> - we provide <code>env</code> directly - holoconf uses <code>${ssm:...}</code> for AWS SSM - new resolver, not in OmegaConf</p> <p>Migration script: A simple regex can convert OmegaConf positional defaults to keyword syntax: <pre><code>${env:(\\w+),([^}]+)} \u2192 ${env:$1,default=$2}\n</code></pre></p>"},{"location":"adr/ADR-011-interpolation-syntax/#consequences","title":"Consequences","text":"<ul> <li>Positive: Consistent <code>default</code> and <code>sensitive</code> behavior across all resolvers without code duplication</li> <li>Positive: Clear, explicit syntax that avoids ambiguity</li> <li>Positive: Resolvers are simpler (don't need to implement default/sensitive handling)</li> <li>Negative: Not 100% compatible with OmegaConf positional default syntax</li> <li>Neutral: Safety limits may need tuning based on real-world usage</li> </ul>"},{"location":"adr/ADR-012-type-coercion/","title":"ADR-012: Type Coercion","text":""},{"location":"adr/ADR-012-type-coercion/#status","title":"Status","text":"<ul> <li>Proposed by: Ryan on 2026-01-07</li> <li>Accepted on: 2026-01-07</li> </ul>"},{"location":"adr/ADR-012-type-coercion/#context","title":"Context","text":"<p>Resolvers often return string values (e.g., <code>${env:PORT}</code> returns <code>\"8080\"</code>), but the schema or application may expect a different type (e.g., <code>integer</code>). We need to decide how holoconf handles type mismatches between resolved values and expected types.</p> <p>This affects: - Schema validation (ADR-007) - Resolver return values (ADR-002) - Serialization output (ADR-009)</p>"},{"location":"adr/ADR-012-type-coercion/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/ADR-012-type-coercion/#alternative-1-no-coercion-strict-types","title":"Alternative 1: No Coercion (Strict Types)","text":"<p>Resolved values must match the expected type exactly. Type mismatches raise errors.</p> <pre><code># Schema expects integer\nport:\n  type: integer\n\n# Config\nport: ${env:PORT}  # Returns \"8080\" (string) \u2192 ValidationError\n</code></pre> <ul> <li>Pros: Explicit, no surprises, forces correct resolver implementation</li> <li>Cons: Env vars are always strings, would require wrapper resolvers or schema workarounds</li> </ul>"},{"location":"adr/ADR-012-type-coercion/#alternative-2-automatic-coercion-implicit","title":"Alternative 2: Automatic Coercion (Implicit)","text":"<p>Automatically coerce values to match schema types when possible.</p> <pre><code># Schema expects integer\nport:\n  type: integer\n\n# Config\nport: ${env:PORT}  # Returns \"8080\" \u2192 coerced to 8080 (integer)\n</code></pre> <ul> <li>Pros: Convenient, works naturally with env vars</li> <li>Cons: Can hide bugs, unexpected behavior if coercion fails silently</li> </ul>"},{"location":"adr/ADR-012-type-coercion/#alternative-3-schema-driven-coercion-explicit","title":"Alternative 3: Schema-Driven Coercion (Explicit)","text":"<p>Coercion only happens when a schema is present and defines the expected type. Without a schema, values retain their resolved type.</p> <pre><code># With schema expecting integer: \"8080\" \u2192 8080\n# Without schema: \"8080\" stays \"8080\"\n</code></pre> <ul> <li>Pros: Predictable, schema controls behavior, no coercion surprises without schema</li> <li>Cons: Behavior differs with/without schema</li> </ul>"},{"location":"adr/ADR-012-type-coercion/#open-questions-proposal-phase","title":"Open Questions (Proposal Phase)","text":"<p>All resolved - see Decision section.</p>"},{"location":"adr/ADR-012-type-coercion/#next-steps-proposal-phase","title":"Next Steps (Proposal Phase)","text":"<ul> <li>[ ] Implement coercion in holoconf-core</li> <li>[ ] Test edge cases (empty strings, whitespace, locale-specific numbers)</li> <li>[ ] Document resolver-driven coercion option</li> </ul>"},{"location":"adr/ADR-012-type-coercion/#decision","title":"Decision","text":"<p>Schema-Driven Coercion with Resolver Override</p> <ul> <li>Coercion is primarily schema-driven: when a schema specifies an expected type, holoconf attempts to coerce the resolved value</li> <li>Resolvers may also perform their own coercion before returning values (resolver-driven)</li> <li>Schema coercion applies after resolver returns, so resolvers returning already-typed values skip coercion</li> <li>Boolean coercion is strict: only <code>\"true\"</code> and <code>\"false\"</code> (case-insensitive), not <code>\"1\"/\"0\"</code> or <code>\"yes\"/\"no\"</code></li> <li>No string-to-array coercion; use a built-in resolver for splitting if needed</li> </ul>"},{"location":"adr/ADR-012-type-coercion/#design","title":"Design","text":""},{"location":"adr/ADR-012-type-coercion/#schema-driven-coercion","title":"Schema-Driven Coercion","text":"<p>Coercion happens automatically when: 1. A schema is provided 2. The schema specifies an expected type 3. The resolved value doesn't match the expected type 4. A valid coercion rule exists</p>"},{"location":"adr/ADR-012-type-coercion/#resolver-driven-coercion","title":"Resolver-Driven Coercion","text":"<p>Resolvers may return already-typed values:</p> <pre><code>class SmartEnvResolver(Resolver):\n    def resolve(self, key: str) -&gt; ResolvedValue:\n        value = os.environ.get(key)\n        # Resolver does its own coercion\n        if value.isdigit():\n            return ResolvedValue(value=int(value), sensitive=False)\n        return ResolvedValue(value=value, sensitive=False)\n</code></pre> <p>When a resolver returns a typed value: - If it matches the schema type, no coercion needed - If it doesn't match, schema coercion is attempted - This allows resolvers to optimize for common cases</p>"},{"location":"adr/ADR-012-type-coercion/#coercion-rules","title":"Coercion Rules","text":"From To Rule Example string integer Parse as integer, fail if not valid <code>\"8080\"</code> \u2192 <code>8080</code>, <code>\"abc\"</code> \u2192 error string number Parse as float <code>\"3.14\"</code> \u2192 <code>3.14</code> string boolean <code>\"true\"/\"false\"</code> only (case-insensitive) <code>\"true\"</code> \u2192 <code>true</code>, <code>\"1\"</code> \u2192 error string array No coercion (use split resolver) error string object No coercion error integer number Widen to float <code>8080</code> \u2192 <code>8080.0</code> any string No coercion needed (strings accept any) value unchanged"},{"location":"adr/ADR-012-type-coercion/#coercion-failure-behavior","title":"Coercion Failure Behavior","text":"<p>When coercion fails, raise <code>TypeValidationError</code> with context:</p> <pre><code>TypeValidationError: Cannot coerce value to expected type\n  Path: database.port\n  Expected: integer\n  Got: string (\"not-a-number\")\n  Resolved from: ${env:DB_PORT}\n  Help: Ensure DB_PORT environment variable contains a valid integer\n</code></pre>"},{"location":"adr/ADR-012-type-coercion/#no-schema-behavior","title":"No-Schema Behavior","text":"<p>Without a schema, no coercion occurs. Values retain their resolved type: - <code>${env:PORT}</code> \u2192 <code>\"8080\"</code> (string) - Accessing <code>config.port</code> returns <code>\"8080\"</code> (string)</p>"},{"location":"adr/ADR-012-type-coercion/#opt-out","title":"Opt-Out","text":"<p>If schema specifies <code>type: string</code>, no coercion occurs even if the value looks like a number.</p>"},{"location":"adr/ADR-012-type-coercion/#rationale","title":"Rationale","text":"<ul> <li>Schema-driven coercion is predictable - users know when coercion happens (only with schema)</li> <li>Resolver override enables optimization - resolvers can return typed values to skip coercion</li> <li>Strict boolean parsing prevents bugs - <code>\"1\"</code> or <code>\"yes\"</code> silently becoming <code>true</code> can hide errors</li> <li>No string-to-array keeps things simple - complex parsing should be explicit via resolvers</li> </ul>"},{"location":"adr/ADR-012-type-coercion/#trade-offs-accepted","title":"Trade-offs Accepted","text":"<ul> <li>Stricter boolean coercion may require users to update configs using <code>\"1\"/\"0\"</code>, in exchange for predictable behavior</li> <li>No implicit array splitting requires explicit resolver usage, in exchange for avoiding ambiguous parsing</li> <li>Schema required for coercion means unvalidated configs keep string types, in exchange for explicit behavior</li> </ul>"},{"location":"adr/ADR-012-type-coercion/#migration","title":"Migration","text":"<p>N/A - This is the initial architecture decision.</p>"},{"location":"adr/ADR-012-type-coercion/#consequences","title":"Consequences","text":"<ul> <li>Positive: Predictable coercion, resolvers can optimize, clear separation of concerns</li> <li>Negative: Users expecting <code>\"1\"</code> \u2192 <code>true</code> will need to adjust</li> <li>Neutral: Resolvers have flexibility to do their own coercion if desired</li> </ul>"},{"location":"adr/ADR-013-testing-architecture/","title":"ADR-013: Testing Architecture","text":""},{"location":"adr/ADR-013-testing-architecture/#status","title":"Status","text":"<ul> <li>Proposed by: Ryan on 2026-01-07</li> <li>Accepted on: 2026-01-07</li> </ul>"},{"location":"adr/ADR-013-testing-architecture/#context","title":"Context","text":"<p>Holoconf is a multi-language configuration library with a Rust core and bindings for Python, JavaScript, and Go. We need a testing strategy that:</p> <ol> <li>Ensures feature parity across all language implementations</li> <li>Expresses tests in domain language (configuration, resolvers, schemas, etc.)</li> <li>Allows writing tests once and running them against all implementations</li> <li>Separates test logic from implementation details</li> </ol> <p>This is critical because: - Bugs in one binding but not another are hard to catch without shared tests - Configuration semantics must be identical across languages - Maintaining separate test suites per language leads to divergence</p>"},{"location":"adr/ADR-013-testing-architecture/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/ADR-013-testing-architecture/#alternative-1-language-specific-test-suites","title":"Alternative 1: Language-Specific Test Suites","text":"<p>Each language binding has its own independent test suite written idiomatically.</p> <ul> <li>Pros: Idiomatic tests, easy to write, no shared infrastructure</li> <li>Cons: No feature parity guarantee, duplicate effort, tests diverge over time</li> </ul>"},{"location":"adr/ADR-013-testing-architecture/#alternative-2-rust-only-testing","title":"Alternative 2: Rust-Only Testing","text":"<p>Test only the Rust core extensively; assume bindings are thin wrappers.</p> <ul> <li>Pros: Simple, fast, single test suite</li> <li>Cons: Binding bugs undetected, FFI edge cases missed, no validation that bindings work correctly</li> </ul>"},{"location":"adr/ADR-013-testing-architecture/#alternative-3-cucumbergherkin","title":"Alternative 3: Cucumber/Gherkin","text":"<p>Use Gherkin syntax for test definitions with Cucumber runners per language.</p> <ul> <li>Pros: Human-readable \"Given/When/Then\" format, established tooling</li> <li>Cons: Step definition mapping overhead, natural language parsing required, Gherkin's strength (stakeholder readability) isn't valuable when our audience is developers, adds dependency across all languages</li> </ul>"},{"location":"adr/ADR-013-testing-architecture/#alternative-4-four-tier-testing-architecture-with-yaml","title":"Alternative 4: Four-Tier Testing Architecture with YAML","text":"<p>A layered architecture separating test definitions from execution, using YAML for definitions.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Test Definitions                      \u2502\n\u2502              (YAML - what to test, expected results)     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                    DSL Layer                             \u2502\n\u2502    (Domain operations: given_config, when_resolved...)   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Rust    \u2502  Python  \u2502    JS    \u2502    Go    \u2502   Future   \u2502\n\u2502  Driver  \u2502  Driver  \u2502  Driver  \u2502  Driver  \u2502   Driver   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Rust    \u2502  Python  \u2502    JS    \u2502    Go    \u2502   Future   \u2502\n\u2502  Library \u2502 Bindings \u2502 Bindings \u2502 Bindings \u2502  Bindings  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <ul> <li>Pros: Feature parity enforced, write once run everywhere, domain-focused tests, YAML matches our config domain</li> <li>Cons: Upfront infrastructure investment, shared test format design needed</li> </ul>"},{"location":"adr/ADR-013-testing-architecture/#open-questions-proposal-phase","title":"Open Questions (Proposal Phase)","text":"<p>All resolved - see Decision section.</p>"},{"location":"adr/ADR-013-testing-architecture/#next-steps-proposal-phase","title":"Next Steps (Proposal Phase)","text":"<ul> <li>[ ] Define the DSL operations vocabulary</li> <li>[ ] Implement Rust driver as reference</li> <li>[ ] Implement one binding driver (Python) to validate architecture</li> <li>[ ] Create initial acceptance test suite</li> </ul>"},{"location":"adr/ADR-013-testing-architecture/#decision","title":"Decision","text":"<p>Four-Tier Testing Architecture with YAML test definitions, covering acceptance tests, unit tests, and performance benchmarks.</p>"},{"location":"adr/ADR-013-testing-architecture/#why-yaml-over-gherkin","title":"Why YAML over Gherkin","text":"<ol> <li>Config files are already YAML - Test definitions like <code>given: config: |</code> feel natural and consistent with the domain</li> <li>No step definition mapping - YAML is already structured; drivers consume it directly without parsing natural language</li> <li>Universal parsing - Every language has robust YAML support; Cucumber support varies</li> <li>Developer audience - Gherkin's strength is stakeholder readability; our users are developers comfortable with structured data</li> </ol>"},{"location":"adr/ADR-013-testing-architecture/#design","title":"Design","text":""},{"location":"adr/ADR-013-testing-architecture/#tier-1-test-definitions-universal","title":"Tier 1: Test Definitions (Universal)","text":"<p>Tests are defined in YAML that describes: - Setup (config files, environment, resolvers) - Actions (load, access, resolve, validate) - Assertions (expected values, errors, behaviors)</p> <pre><code># tests/acceptance/resolvers/env_resolver.yaml\nsuite: env_resolver\ndescription: Environment variable resolver behavior\ntests:\n  - name: resolves_environment_variable\n    given:\n      env:\n        PORT: \"8080\"\n      config: |\n        port: ${env:PORT}\n    when:\n      access: port\n    then:\n      value: \"8080\"\n\n  - name: uses_default_when_missing\n    given:\n      config: |\n        port: ${env:UNDEFINED_VAR,default=3000}\n    when:\n      access: port\n    then:\n      value: \"3000\"\n\n  - name: errors_when_missing_no_default\n    given:\n      config: |\n        port: ${env:UNDEFINED_VAR}\n    when:\n      access: port\n    then:\n      error:\n        type: ResolverError\n        message_contains: \"Environment variable not found\"\n</code></pre>"},{"location":"adr/ADR-013-testing-architecture/#tier-2-dsl-layer-per-language","title":"Tier 2: DSL Layer (Per-Language)","text":"<p>The DSL provides domain operations in each language. These are high-level, readable operations that map to the test definition vocabulary.</p> <p>Python DSL Example: <pre><code># holoconf_test/dsl.py\nclass ConfigTestDSL:\n    def given_env(self, env: dict[str, str]) -&gt; Self: ...\n    def given_config(self, yaml_content: str) -&gt; Self: ...\n    def given_config_file(self, path: str) -&gt; Self: ...\n    def given_schema(self, schema: dict) -&gt; Self: ...\n    def given_resolver(self, name: str, resolver: Callable) -&gt; Self: ...\n\n    def when_load(self) -&gt; Self: ...\n    def when_access(self, path: str) -&gt; Self: ...\n    def when_resolve_all(self) -&gt; Self: ...\n    def when_validate(self) -&gt; Self: ...\n    def when_export(self, format: str) -&gt; Self: ...\n\n    def then_value_equals(self, expected: Any) -&gt; Self: ...\n    def then_value_is_type(self, expected_type: type) -&gt; Self: ...\n    def then_error(self, error_type: str, message_contains: str = None) -&gt; Self: ...\n    def then_config_equals(self, expected: dict) -&gt; Self: ...\n</code></pre></p> <p>Rust DSL Example: <pre><code>// holoconf_test/src/dsl.rs\nimpl ConfigTestDSL {\n    pub fn given_env(mut self, env: HashMap&lt;String, String&gt;) -&gt; Self { ... }\n    pub fn given_config(mut self, yaml: &amp;str) -&gt; Self { ... }\n    pub fn given_schema(mut self, schema: Value) -&gt; Self { ... }\n\n    pub fn when_load(mut self) -&gt; Self { ... }\n    pub fn when_access(mut self, path: &amp;str) -&gt; Self { ... }\n\n    pub fn then_value_equals&lt;T: PartialEq&gt;(self, expected: T) -&gt; Self { ... }\n    pub fn then_error(self, error_type: &amp;str) -&gt; Self { ... }\n}\n</code></pre></p>"},{"location":"adr/ADR-013-testing-architecture/#tier-3-drivers-per-language","title":"Tier 3: Drivers (Per-Language)","text":"<p>Drivers translate DSL operations into actual library calls. They handle language-specific details like error handling, type conversion, and FFI boundaries.</p> <p>Drivers are hand-written for each language binding. This is preferred over auto-generation because: - Only 4 languages to support - Driver logic involves language-specific idioms - Auto-generation would require a meta-schema adding complexity</p> <p>Python Driver: <pre><code># holoconf_test/driver.py\nclass HoloconfDriver:\n    def __init__(self):\n        self._config = None\n        self._last_result = None\n        self._last_error = None\n\n    def load_config(self, yaml_content: str, **options):\n        \"\"\"Actually calls holoconf.Config.load()\"\"\"\n        try:\n            self._config = Config.loads(yaml_content, **options)\n        except Exception as e:\n            self._last_error = e\n\n    def access_path(self, path: str):\n        \"\"\"Actually accesses config.path.to.value\"\"\"\n        try:\n            self._last_result = self._config.get(path)\n        except Exception as e:\n            self._last_error = e\n\n    def get_last_result(self): return self._last_result\n    def get_last_error(self): return self._last_error\n</code></pre></p>"},{"location":"adr/ADR-013-testing-architecture/#tier-4-system-under-test","title":"Tier 4: System Under Test","text":"<p>The actual holoconf libraries - Rust core and language bindings.</p>"},{"location":"adr/ADR-013-testing-architecture/#test-categories","title":"Test Categories","text":""},{"location":"adr/ADR-013-testing-architecture/#acceptance-tests-cross-language","title":"Acceptance Tests (Cross-Language)","text":"<p>High-level tests that verify documented behavior from a user's perspective. Run against all implementations to ensure feature parity.</p> <p>Characteristics: - Written in YAML, executed via the four-tier architecture - Test observable behavior, not implementation details - One test definition runs against Rust, Python, JS, and Go - If it's in the documentation, there's an acceptance test for it</p> <p>What they cover: - Resolver behavior (env, self, file, http) - Merging semantics - Schema validation - Type coercion - Error messages and help text - Interpolation syntax - API surface (load, access, export)</p> <p>Location: <code>tests/acceptance/</code></p> <pre><code>tests/acceptance/\n\u251c\u2500\u2500 resolvers/\n\u2502   \u251c\u2500\u2500 env_resolver.yaml\n\u2502   \u251c\u2500\u2500 self_resolver.yaml\n\u2502   \u251c\u2500\u2500 file_resolver.yaml\n\u2502   \u2514\u2500\u2500 http_resolver.yaml\n\u251c\u2500\u2500 merging/\n\u2502   \u251c\u2500\u2500 deep_merge.yaml\n\u2502   \u2514\u2500\u2500 override_semantics.yaml\n\u251c\u2500\u2500 schema/\n\u2502   \u251c\u2500\u2500 type_validation.yaml\n\u2502   \u2514\u2500\u2500 coercion.yaml\n\u251c\u2500\u2500 interpolation/\n\u2502   \u251c\u2500\u2500 syntax.yaml\n\u2502   \u251c\u2500\u2500 escaping.yaml\n\u2502   \u2514\u2500\u2500 nesting.yaml\n\u2514\u2500\u2500 errors/\n    \u251c\u2500\u2500 resolver_errors.yaml\n    \u2514\u2500\u2500 validation_errors.yaml\n</code></pre>"},{"location":"adr/ADR-013-testing-architecture/#unit-tests-language-specific","title":"Unit Tests (Language-Specific)","text":"<p>Low-level tests for implementation details, internal functions, and edge cases not visible through the public API.</p> <p>Characteristics: - Written idiomatically in each language's test framework - Test internal implementation details - May test private/internal APIs - Not required to be cross-language</p> <p>What they cover: - Parser internals and edge cases - Memory management (Rust) - FFI boundary correctness (bindings) - Language-specific type conversions - Internal helper functions</p> <p>Location: - Rust: <code>crates/holoconf-core/src/**/*_test.rs</code> or <code>crates/holoconf-core/tests/</code> - Python: <code>bindings/python/tests/unit/</code> - JS: <code>bindings/js/tests/unit/</code> - Go: <code>bindings/go/**/*_test.go</code></p>"},{"location":"adr/ADR-013-testing-architecture/#performance-tests","title":"Performance Tests","text":"<p>Benchmark tests that verify performance characteristics. These use the same four-tier architecture with performance-specific assertions.</p> <p>Characteristics: - Written in YAML like acceptance tests - Use <code>then: performance:</code> assertions instead of value assertions - Run separately from functional tests (longer execution time) - Establish baselines and detect regressions</p> <p>What they cover: - Config loading time (small, medium, large files) - Resolution latency (single value, bulk resolution) - Memory usage during resolution - Concurrent access performance</p> <p>Location: <code>tests/performance/</code></p> <pre><code># tests/performance/loading.yaml\nsuite: config_loading_performance\ntests:\n  - name: small_config_loads_quickly\n    given:\n      config_file: fixtures/small_config.yaml  # ~50 keys\n    when:\n      load: {}\n    then:\n      performance:\n        max_duration_ms: 10\n        max_memory_mb: 5\n\n  - name: large_config_loads_reasonably\n    given:\n      config_file: fixtures/large_config.yaml  # ~10,000 keys\n    when:\n      load: {}\n    then:\n      performance:\n        max_duration_ms: 500\n        max_memory_mb: 50\n\n  - name: bulk_resolution_scales_linearly\n    given:\n      config_file: fixtures/many_resolvers.yaml  # 1000 env vars\n      env_from_file: fixtures/env_vars.json\n    when:\n      resolve_all: {}\n    then:\n      performance:\n        max_duration_ms: 200\n</code></pre>"},{"location":"adr/ADR-013-testing-architecture/#test-runner","title":"Test Runner","text":"<p>A universal test runner loads YAML test definitions and executes them against each driver:</p> <pre><code># tools/test_runner.py\ndef run_tests(driver: str, test_files: list[str], category: str = \"acceptance\"):\n    \"\"\"\n    Run tests against a specific driver.\n\n    Usage:\n        python tools/test_runner.py --driver python tests/acceptance/**/*.yaml\n        python tools/test_runner.py --driver rust tests/performance/**/*.yaml\n    \"\"\"\n    driver_impl = load_driver(driver)  # Python, Rust, JS, Go\n\n    for test_file in test_files:\n        suite = load_test_suite(test_file)\n        for test in suite.tests:\n            dsl = ConfigTestDSL(driver_impl)\n            execute_test(dsl, test)\n</code></pre>"},{"location":"adr/ADR-013-testing-architecture/#coverage-requirements","title":"Coverage Requirements","text":"Category Coverage Target Rationale Acceptance Tests 100% of documented features Feature parity guarantee Unit Tests (Core) 90% line coverage Critical path coverage Unit Tests (Bindings) 80% line coverage FFI edge cases Performance Tests Key operations baselined Regression detection"},{"location":"adr/ADR-013-testing-architecture/#ci-integration","title":"CI Integration","text":"<pre><code># .github/workflows/test.yml\njobs:\n  acceptance-tests:\n    strategy:\n      matrix:\n        driver: [rust, python, js, go]\n    steps:\n      - run: python tools/test_runner.py --driver ${{ matrix.driver }} tests/acceptance/**/*.yaml\n\n  unit-tests-rust:\n    steps:\n      - run: cargo test --workspace\n\n  unit-tests-bindings:\n    strategy:\n      matrix:\n        binding: [python, js, go]\n    steps:\n      - run: cd bindings/${{ matrix.binding }} &amp;&amp; make test\n\n  performance-tests:\n    # Run on main branch only, or on-demand\n    if: github.ref == 'refs/heads/main'\n    strategy:\n      matrix:\n        driver: [rust, python]  # Primary implementations\n    steps:\n      - run: python tools/test_runner.py --driver ${{ matrix.driver }} tests/performance/**/*.yaml\n</code></pre>"},{"location":"adr/ADR-013-testing-architecture/#rationale","title":"Rationale","text":"<ul> <li>Four-tier separation keeps test logic independent of implementation</li> <li>YAML over Gherkin because our domain is already YAML-based and our audience is developers</li> <li>Acceptance + Unit separation allows high-level feature parity tests while still testing implementation details</li> <li>Performance in same architecture reuses infrastructure while keeping concerns separate</li> <li>Hand-written drivers are simpler than auto-generation for 4 languages</li> </ul>"},{"location":"adr/ADR-013-testing-architecture/#trade-offs-accepted","title":"Trade-offs Accepted","text":"<ul> <li>Upfront infrastructure investment to build test framework, in exchange for long-term maintainability and feature parity</li> <li>YAML less readable than Gherkin for non-developers, in exchange for simpler implementation and domain consistency</li> <li>Acceptance tests may not cover all edge cases, addressed by language-specific unit tests</li> <li>Performance tests in YAML have limited expressiveness, in exchange for consistent tooling</li> </ul>"},{"location":"adr/ADR-013-testing-architecture/#migration","title":"Migration","text":"<p>N/A - This is the initial architecture decision.</p>"},{"location":"adr/ADR-013-testing-architecture/#consequences","title":"Consequences","text":"<ul> <li>Positive: Feature parity enforced across all bindings</li> <li>Positive: Tests written once, run everywhere</li> <li>Positive: Adding new language bindings just requires writing a driver</li> <li>Positive: Clear separation between \"what behavior\" (acceptance) and \"how implemented\" (unit)</li> <li>Negative: Initial setup requires building test infrastructure</li> <li>Neutral: Test failures clearly indicate which binding has issues</li> </ul>"},{"location":"adr/ADR-014-code-quality-tooling/","title":"ADR-014: Code Quality and Security Tooling","text":""},{"location":"adr/ADR-014-code-quality-tooling/#status","title":"Status","text":"<ul> <li>Proposed by: Claude on 2026-01-08</li> <li>Accepted on: 2026-01-08</li> </ul>"},{"location":"adr/ADR-014-code-quality-tooling/#context","title":"Context","text":"<p>As holoconf grows with multiple language bindings (Rust core, Python, future Node.js/Go), we need consistent code quality and security standards across all languages. Without standardized tooling:</p> <ol> <li>Code style varies between contributors</li> <li>Security vulnerabilities may go undetected</li> <li>Unused dependencies accumulate</li> <li>License compliance is not verified</li> <li>Code complexity grows unchecked</li> </ol>"},{"location":"adr/ADR-014-code-quality-tooling/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/ADR-014-code-quality-tooling/#alternative-1-manual-code-review-only","title":"Alternative 1: Manual Code Review Only","text":"<ul> <li>Pros: No tooling overhead, flexible</li> <li>Cons: Inconsistent, error-prone, doesn't scale, security issues missed</li> </ul>"},{"location":"adr/ADR-014-code-quality-tooling/#alternative-2-language-specific-tools-no-standardization","title":"Alternative 2: Language-Specific Tools (No Standardization)","text":"<ul> <li>Pros: Each language uses its best-of-breed tools</li> <li>Cons: Inconsistent CI configuration, harder to maintain, no unified quality gate</li> </ul>"},{"location":"adr/ADR-014-code-quality-tooling/#alternative-3-unified-quality-pipeline-with-language-specific-tools","title":"Alternative 3: Unified Quality Pipeline with Language-Specific Tools","text":"<ul> <li>Pros: Best tools for each language, unified CI structure, comprehensive coverage</li> <li>Cons: More CI configuration, multiple tools to learn</li> </ul>"},{"location":"adr/ADR-014-code-quality-tooling/#decision","title":"Decision","text":"<p>Adopt Alternative 3: Unified quality pipeline with best-of-breed tools for each language.</p>"},{"location":"adr/ADR-014-code-quality-tooling/#design","title":"Design","text":""},{"location":"adr/ADR-014-code-quality-tooling/#language-version-requirements","title":"Language Version Requirements","text":"Language Minimum Version Defined In Rust 1.88+ <code>Cargo.toml</code> (<code>rust-version</code>), <code>rust-toolchain.toml</code> Python 3.9+ <code>pyproject.toml</code> (<code>requires-python</code>) <p>To update Rust: <code>rustup update stable</code></p>"},{"location":"adr/ADR-014-code-quality-tooling/#rust-tooling","title":"Rust Tooling","text":"Tool Purpose Configuration When rustfmt Code formatting <code>rustfmt.toml</code> CI clippy Linting, complexity <code>clippy.toml</code> CI cargo-deny License &amp; advisory audit <code>deny.toml</code> CI cargo-audit CVE vulnerability scan - CI cargo-machete Unused dependency detection - CI cargo-geiger Audit unsafe code usage - Manual cargo-semver-checks Detect breaking API changes - Pre-release cargo-cyclonedx Generate SBOM (CycloneDX format) - Release"},{"location":"adr/ADR-014-code-quality-tooling/#clippy-configuration-clippytoml","title":"Clippy Configuration (<code>clippy.toml</code>)","text":"<pre><code>cognitive-complexity-threshold = 20\ntoo-many-lines-threshold = 80\ntoo-many-arguments-threshold = 6\n</code></pre>"},{"location":"adr/ADR-014-code-quality-tooling/#cargo-deny-configuration-denytoml","title":"Cargo Deny Configuration (<code>deny.toml</code>)","text":"<ul> <li>Deny known vulnerabilities</li> <li>Warn on unmaintained crates</li> <li>Allow only approved licenses (MIT, Apache-2.0, BSD, ISC, etc.)</li> <li>Warn on multiple versions of same crate</li> </ul>"},{"location":"adr/ADR-014-code-quality-tooling/#python-tooling","title":"Python Tooling","text":"Tool Purpose Configuration When ruff Linting + formatting <code>pyproject.toml</code> CI pip-audit Dependency security scan - CI cyclonedx-bom Generate SBOM (CycloneDX format) - Release"},{"location":"adr/ADR-014-code-quality-tooling/#ruff-configuration","title":"Ruff Configuration","text":"<pre><code>[tool.ruff.lint]\nselect = [\n    \"E\",      # pycodestyle errors\n    \"W\",      # pycodestyle warnings\n    \"F\",      # Pyflakes\n    \"I\",      # isort\n    \"B\",      # flake8-bugbear\n    \"C4\",     # flake8-comprehensions\n    \"UP\",     # pyupgrade\n    \"S\",      # flake8-bandit (security)\n    \"SIM\",    # flake8-simplify\n    \"RUF\",    # Ruff-specific rules\n]\n</code></pre>"},{"location":"adr/ADR-014-code-quality-tooling/#ci-pipeline-structure","title":"CI Pipeline Structure","text":"<pre><code>quality.yml\n\u251c\u2500\u2500 rust-lint (rustfmt, clippy)\n\u251c\u2500\u2500 rust-security (cargo-deny, cargo-audit)\n\u251c\u2500\u2500 rust-unused (cargo-machete)\n\u251c\u2500\u2500 python-lint (ruff check, ruff format)\n\u251c\u2500\u2500 python-security (pip-audit)\n\u2514\u2500\u2500 complexity (tokei - informational)\n</code></pre>"},{"location":"adr/ADR-014-code-quality-tooling/#local-development-commands","title":"Local Development Commands","text":"<p>A <code>Makefile</code> provides unified commands across all languages:</p> <pre><code>make help          # Show all available commands\nmake lint          # Run all linters (Rust + Python)\nmake format        # Format all code\nmake security      # Run all security checks\nmake test          # Run all tests\nmake check         # Run everything (lint + security + test)\nmake audit-unsafe  # Report unsafe code usage\nmake semver-check  # Check for breaking API changes (pre-release)\nmake sbom          # Generate SBOMs for all packages\n</code></pre> <p>Individual language commands are also available:</p> <pre><code># Rust\nmake lint-rust     # clippy + fmt check\nmake format-rust   # cargo fmt\nmake security-rust # cargo-deny + cargo-audit\nmake test-rust     # cargo test\n\n# Python\nmake lint-python     # ruff check + format check\nmake format-python   # ruff format + fix\nmake security-python # pip-audit\nmake test-python     # pytest\n</code></pre> <p>Or run tools directly:</p> <pre><code># Rust\ncargo fmt --all                     # Format\ncargo clippy --all-targets          # Lint\ncargo deny check                    # License/security\ncargo audit                         # CVE scan\n\n# Python (from packages/python/holoconf/)\nruff check src/ tests/              # Lint\nruff format src/ tests/             # Format\n</code></pre>"},{"location":"adr/ADR-014-code-quality-tooling/#rationale","title":"Rationale","text":"<ol> <li> <p>Rust-focused complexity checks - Most logic is in Rust, so clippy's cognitive complexity and function length limits are the primary complexity gates</p> </li> <li> <p>Security at dependency level - Both cargo-audit/cargo-deny (Rust) and pip-audit (Python) catch CVEs in dependencies before they ship</p> </li> <li> <p>Ruff over Black/flake8 - Ruff is significantly faster and combines formatting + linting in one tool</p> </li> <li> <p>Separate CI jobs - Allows parallel execution and clear failure identification</p> </li> <li> <p>CycloneDX for SBOMs - Widely adopted format (OWASP, GitHub), better tooling support than SPDX, more concise</p> </li> </ol>"},{"location":"adr/ADR-014-code-quality-tooling/#sbom-generation","title":"SBOM Generation","text":"<p>Software Bill of Materials (SBOM) generation is available for supply chain transparency:</p> <pre><code>make sbom\n</code></pre> <p>This generates CycloneDX-format SBOMs in the <code>sbom/</code> directory:</p> File Contents <code>holoconf-rust.cdx.json</code> All Rust crate dependencies <code>holoconf-python.cdx.json</code> All Python package dependencies <p>SBOMs should be generated and published with each release to provide downstream users visibility into the dependency tree.</p>"},{"location":"adr/ADR-014-code-quality-tooling/#trade-offs-accepted","title":"Trade-offs Accepted","text":"<ul> <li>More CI time in exchange for comprehensive quality gates</li> <li>Learning multiple tools in exchange for best-of-breed per language</li> <li>Stricter defaults in exchange for cleaner codebase (can allow specific lints when justified)</li> </ul>"},{"location":"adr/ADR-014-code-quality-tooling/#migration","title":"Migration","text":"<p>N/A - This ADR establishes tooling for an existing codebase. Initial cleanup was performed: - Fixed clippy warnings (PI constant in tests, wildcard patterns) - Fixed ruff issues (import sorting, deprecated typing imports)</p>"},{"location":"adr/ADR-014-code-quality-tooling/#consequences","title":"Consequences","text":"<ul> <li>Positive:</li> <li>Consistent code style across all contributors</li> <li>Security vulnerabilities caught before merge</li> <li>License compliance verified automatically</li> <li>Code complexity stays manageable</li> <li>Unused dependencies removed</li> <li> <p>SBOM generation enables supply chain transparency</p> </li> <li> <p>Negative:</p> </li> <li>CI runs take longer (~2-3 min additional)</li> <li>Contributors must install tools locally for pre-commit checks</li> <li> <p>Some false positives may require <code>#[allow(...)]</code> annotations</p> </li> <li> <p>Neutral:</p> </li> <li>Existing code required minor cleanup to pass new lints</li> </ul>"},{"location":"adr/ADR-015-documentation-site/","title":"ADR-015: Cross-Language Documentation Site","text":""},{"location":"adr/ADR-015-documentation-site/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/ADR-015-documentation-site/#context","title":"Context","text":"<p>holoconf is a multi-language configuration library with a Rust core and bindings for Python (with JS, Go, Java, C planned). We need a documentation site that:</p> <ol> <li>Provides consistent documentation across all supported languages</li> <li>Allows users to select their language once and see relevant examples site-wide</li> <li>Supports versioned documentation</li> <li>Publishes to GitHub Pages</li> <li>Includes existing ADRs and feature specs for contributors</li> </ol>"},{"location":"adr/ADR-015-documentation-site/#decision","title":"Decision","text":"<p>Use MkDocs with Material theme for the documentation site.</p>"},{"location":"adr/ADR-015-documentation-site/#rationale","title":"Rationale","text":"<ul> <li>Persistent language tabs: Material's <code>content.tabs.link</code> feature syncs tab selection across all pages via localStorage - users click \"Python\" once and all code examples show Python</li> <li>Clean syntax: Pure Markdown (<code>===</code> tabs) without JSX/MDX</li> <li>Versioning: mike plugin is mature and battle-tested</li> <li>Python ecosystem alignment: Natural fit given Python bindings and tooling</li> <li>GitHub Pages: Simple deployment via <code>mkdocs gh-deploy</code> or GitHub Actions</li> </ul>"},{"location":"adr/ADR-015-documentation-site/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/ADR-015-documentation-site/#docusaurus","title":"Docusaurus","text":"<p>Pros: - Built-in versioning (best-in-class) - Large ecosystem and community - React-based for JS-heavy teams</p> <p>Cons: - Requires MDX/JSX for tabs - React knowledge helpful for customization - Heavier build times</p>"},{"location":"adr/ADR-015-documentation-site/#starlight-astro","title":"Starlight (Astro)","text":"<p>Pros: - Fastest builds - Modern DX</p> <p>Cons: - Immature versioning support - Limited monorepo support</p>"},{"location":"adr/ADR-015-documentation-site/#vitepress","title":"VitePress","text":"<p>Pros: - Clean markdown syntax - Fast builds (Vite-powered)</p> <p>Cons: - Versioning not built-in - Vue knowledge helpful</p>"},{"location":"adr/ADR-015-documentation-site/#consequences","title":"Consequences","text":""},{"location":"adr/ADR-015-documentation-site/#positive","title":"Positive","text":"<ul> <li>Documentation is consistent across languages with persistent language selection</li> <li>Clean markdown-based authoring experience</li> <li>Existing ADRs and specs are integrated into the site</li> <li>GitHub Actions automates deployment</li> </ul>"},{"location":"adr/ADR-015-documentation-site/#negative","title":"Negative","text":"<ul> <li>Requires mike plugin for versioning (not built-in)</li> <li>Python/mkdocs dependency for local development</li> <li>No auto-generation of API docs from Rust (must maintain manually)</li> </ul>"},{"location":"adr/ADR-015-documentation-site/#implementation","title":"Implementation","text":""},{"location":"adr/ADR-015-documentation-site/#directory-structure","title":"Directory Structure","text":"<pre><code>holoconf/\n\u251c\u2500\u2500 mkdocs.yml              # Site configuration (project root)\n\u251c\u2500\u2500 docs/\n\u2502   \u251c\u2500\u2500 index.md            # Landing page\n\u2502   \u251c\u2500\u2500 guide/              # User guides with language tabs\n\u2502   \u251c\u2500\u2500 api/                # API reference\n\u2502   \u251c\u2500\u2500 contributing/       # Contributor docs\n\u2502   \u251c\u2500\u2500 adr/                # Architecture decisions (existing)\n\u2502   \u251c\u2500\u2500 specs/              # Feature specs (existing)\n\u2502   \u2514\u2500\u2500 changelog.md\n\u2514\u2500\u2500 site/                   # Built output (gitignored)\n</code></pre>"},{"location":"adr/ADR-015-documentation-site/#key-configuration","title":"Key Configuration","text":"<pre><code>theme:\n  name: material\n  features:\n    - content.tabs.link      # Persistent language selection\n    - content.code.copy\n    - navigation.instant\n</code></pre>"},{"location":"adr/ADR-015-documentation-site/#language-tab-convention","title":"Language Tab Convention","text":"<p>All code examples use consistent labels: - \"Python\" - \"Rust\" - \"CLI\" - \"JavaScript\" (future) - \"Go\" (future)</p>"},{"location":"adr/ADR-015-documentation-site/#deployment","title":"Deployment","text":"<p>GitHub Actions workflow deploys on push to main: 1. Installs mkdocs-material 2. Builds with <code>mkdocs build --strict</code> 3. Deploys to GitHub Pages</p>"},{"location":"adr/ADR-015-documentation-site/#references","title":"References","text":"<ul> <li>MkDocs Material - Content Tabs</li> <li>mike - MkDocs versioning</li> <li>Docusaurus Tabs</li> </ul>"},{"location":"adr/ADR-016-pyo3-api-documentation/","title":"ADR-016: PyO3 Extension API Documentation","text":""},{"location":"adr/ADR-016-pyo3-api-documentation/#status","title":"Status","text":"<ul> <li>Proposed by: Claude on 2026-01-08</li> <li>Accepted on: 2026-01-08</li> </ul>"},{"location":"adr/ADR-016-pyo3-api-documentation/#context","title":"Context","text":"<p>The holoconf Python package uses PyO3 to expose Rust functionality to Python. This creates a challenge for API documentation:</p> <ol> <li>The compiled extension module (<code>.so</code> file) cannot be introspected by standard Python documentation tools</li> <li>Docstrings defined in Rust code via PyO3's <code>#[pyo3(text_signature = \"...\")]</code> and <code>///</code> doc comments are available at runtime</li> <li>mkdocstrings/griffe cannot resolve type aliases from compiled extensions</li> <li>Users expect navigable API documentation like other Python packages</li> </ol> <p>We need a solution that provides: - Auto-generated API documentation (not manually maintained) - Proper type annotations visible in docs - Docstrings from the actual implementation - Standard Python documentation structure (classes, methods, parameters)</p>"},{"location":"adr/ADR-016-pyo3-api-documentation/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/ADR-016-pyo3-api-documentation/#alternative-1-manual-api-documentation-tables","title":"Alternative 1: Manual API Documentation (Tables)","text":"<p>Write API documentation entirely by hand using markdown tables.</p> <ul> <li>Pros: Full control over presentation, no tooling complexity</li> <li>Cons: Documentation drifts from code, high maintenance burden, no validation</li> </ul>"},{"location":"adr/ADR-016-pyo3-api-documentation/#alternative-2-sphinx-with-autodoc","title":"Alternative 2: Sphinx with autodoc","text":"<p>Use Sphinx instead of MkDocs with autodoc for Python documentation.</p> <ul> <li>Pros: More mature, widely used</li> <li>Cons: Different tech stack from MkDocs, same griffe/introspection issues with <code>.so</code> files</li> </ul>"},{"location":"adr/ADR-016-pyo3-api-documentation/#alternative-3-runtime-docstring-extraction","title":"Alternative 3: Runtime Docstring Extraction","text":"<p>Build a custom script to extract docstrings at runtime and generate markdown.</p> <ul> <li>Pros: Uses actual runtime docstrings</li> <li>Cons: Complex to maintain, still need type information</li> </ul>"},{"location":"adr/ADR-016-pyo3-api-documentation/#alternative-4-python-stub-files-pyi-with-mkdocstrings","title":"Alternative 4: Python Stub Files (.pyi) with mkdocstrings","text":"<p>Create <code>.pyi</code> stub files that griffe can parse, containing type annotations and docstrings.</p> <ul> <li>Pros: Standard Python pattern for type hints, works with mkdocstrings, single source of truth for types</li> <li>Cons: Must keep stubs in sync with Rust implementation</li> </ul>"},{"location":"adr/ADR-016-pyo3-api-documentation/#decision","title":"Decision","text":"<p>Adopt Alternative 4: Use Python stub files (<code>.pyi</code>) with mkdocstrings.</p>"},{"location":"adr/ADR-016-pyo3-api-documentation/#design","title":"Design","text":""},{"location":"adr/ADR-016-pyo3-api-documentation/#directory-structure","title":"Directory Structure","text":"<pre><code>packages/python/holoconf/src/holoconf/\n\u251c\u2500\u2500 __init__.py              # Re-exports from _holoconf\n\u251c\u2500\u2500 _holoconf.cpython-*.so   # Compiled extension (generated)\n\u2514\u2500\u2500 _holoconf.pyi            # Type stubs with docstrings\n</code></pre>"},{"location":"adr/ADR-016-pyo3-api-documentation/#stub-file-format","title":"Stub File Format","text":"<p>The <code>.pyi</code> file contains:</p> <ol> <li>Class definitions with docstrings</li> <li>Method signatures with full type annotations</li> <li>Docstrings in Google style format</li> <li>Exception classes with inheritance</li> </ol> <p>Example:</p> <pre><code>class Config:\n    \"\"\"Configuration object for loading and accessing configuration values.\n\n    Example:\n        &gt;&gt;&gt; config = Config.load(\"config.yaml\")\n        &gt;&gt;&gt; host = config.get(\"database.host\")\n    \"\"\"\n\n    @staticmethod\n    def load(path: str, allow_http: bool = False) -&gt; \"Config\":\n        \"\"\"Load configuration from a YAML file.\n\n        Args:\n            path: Path to the YAML file\n            allow_http: Enable HTTP resolver (disabled by default)\n\n        Returns:\n            A new Config object\n\n        Raises:\n            ParseError: If the file cannot be parsed\n        \"\"\"\n        ...\n</code></pre>"},{"location":"adr/ADR-016-pyo3-api-documentation/#mkdocsyml-configuration","title":"mkdocs.yml Configuration","text":"<pre><code>plugins:\n  - search\n  - mkdocstrings:\n      default_handler: python\n      handlers:\n        python:\n          paths:\n            - packages/python/holoconf/src\n          options:\n            show_source: false\n            show_bases: true\n            heading_level: 2\n            members_order: source\n            docstring_style: google\n            docstring_section_style: spacy\n            show_signature_annotations: true\n            separate_signature: true\n</code></pre>"},{"location":"adr/ADR-016-pyo3-api-documentation/#documentation-structure","title":"Documentation Structure","text":"<p>The API documentation uses a categorized navigation structure similar to AWS CDK docs:</p> <pre><code>docs/api/python/\n\u251c\u2500\u2500 index.md                    # Package overview with quick start\n\u251c\u2500\u2500 classes/\n\u2502   \u251c\u2500\u2500 config.md              # Config class (auto-generated)\n\u2502   \u2514\u2500\u2500 schema.md              # Schema class (auto-generated)\n\u2514\u2500\u2500 exceptions/\n    \u251c\u2500\u2500 holoconf-error.md      # Base exception\n    \u251c\u2500\u2500 parse-error.md\n    \u251c\u2500\u2500 validation-error.md\n    \u251c\u2500\u2500 resolver-error.md\n    \u251c\u2500\u2500 path-not-found-error.md\n    \u251c\u2500\u2500 circular-reference-error.md\n    \u2514\u2500\u2500 type-coercion-error.md\n</code></pre> <p>Each class page uses a simple mkdocstrings directive:</p> <pre><code># Config\n\n::: holoconf.Config\n    options:\n      show_root_heading: false\n      members_order: source\n      group_by_category: true\n      show_category_heading: true\n</code></pre> <p>Exception pages include contextual documentation around the mkdocstrings directive, since PyO3 exception docstrings are typically brief:</p> <pre><code># ParseError\n\nRaised when YAML or JSON content cannot be parsed due to syntax errors.\n\n## When It's Raised\n\n- Invalid YAML syntax (missing colons, bad indentation, etc.)\n- Invalid JSON syntax (missing quotes, trailing commas, etc.)\n- Encoding errors in the configuration file\n\n## Example\n\n\\`\\`\\`python\nfrom holoconf import Config, ParseError\n\ntry:\n    config = Config.loads(\"invalid: yaml: content\")\nexcept ParseError as e:\n    print(f\"Parse error: {e}\")\n\\`\\`\\`\n\n## Class Reference\n\n::: holoconf.ParseError\n    options:\n      show_root_heading: false\n</code></pre> <p>This pattern provides richer documentation while still auto-generating the class reference.</p> <p>The navigation in <code>mkdocs.yml</code> defines the categorized structure, using package names as top-level identifiers:</p> <pre><code>- API Reference:\n    - holoconf (Python):\n        - Overview: api/python/index.md\n        - Classes:\n            - Config: api/python/classes/config.md\n            - Schema: api/python/classes/schema.md\n        - Exceptions:\n            - HoloconfError: api/python/exceptions/holoconf-error.md\n            # ... other exceptions\n    - holoconf-core (Rust):\n        - Overview: api/rust/index.md\n        - Structs:\n            - Config: api/rust/structs/config.md\n            # ... other structs\n        - Enums:\n            - Value: api/rust/enums/value.md\n            # ... other enums\n    - holoconf-cli:\n        - Overview: api/cli/index.md\n</code></pre> <p>This pattern is applied consistently across all language bindings.</p>"},{"location":"adr/ADR-016-pyo3-api-documentation/#keeping-stubs-in-sync","title":"Keeping Stubs in Sync","text":"<p>The stub files must be kept in sync with the Rust implementation:</p> <ol> <li>Docstrings - Copy from PyO3 doc comments in <code>crates/holoconf-python/src/lib.rs</code></li> <li>Signatures - Match <code>#[pyo3(signature = ...)]</code> annotations</li> <li>Types - Use Python equivalents of Rust types</li> </ol> <p>When updating the Rust implementation: 1. Update <code>lib.rs</code> with new methods/changes 2. Update <code>_holoconf.pyi</code> with corresponding changes 3. Run <code>make docs</code> to verify</p>"},{"location":"adr/ADR-016-pyo3-api-documentation/#rationale","title":"Rationale","text":"<ol> <li> <p>Standard Python Pattern - <code>.pyi</code> files are the standard way to add type information to native extensions</p> </li> <li> <p>Works with Existing Tools - mkdocstrings/griffe can parse <code>.pyi</code> files without special handling</p> </li> <li> <p>Type Checker Support - The same stub files work with mypy, pyright, and IDE autocompletion</p> </li> <li> <p>Single Source of Truth - While stubs duplicate Rust docs, they serve multiple purposes (docs + type checking)</p> </li> <li> <p>Minimal Tooling - No custom scripts or build steps; stubs are just Python files</p> </li> </ol>"},{"location":"adr/ADR-016-pyo3-api-documentation/#trade-offs-accepted","title":"Trade-offs Accepted","text":"<ul> <li>Manual Sync Required - Must update stubs when Rust code changes</li> <li>Potential Drift - Stubs could become out of sync (mitigated by code review)</li> <li>Duplicate Documentation - Docstrings exist in both Rust and Python stubs</li> </ul>"},{"location":"adr/ADR-016-pyo3-api-documentation/#consequences","title":"Consequences","text":"<ul> <li>Positive:</li> <li>Professional API documentation with auto-generated method reference</li> <li>Type hints available for IDE autocompletion and type checkers</li> <li>Standard documentation structure (classes, methods, parameters, returns)</li> <li> <p>Works with existing MkDocs infrastructure</p> </li> <li> <p>Negative:</p> </li> <li>Additional file to maintain (<code>_holoconf.pyi</code>)</li> <li> <p>Must remember to update stubs when changing Rust API</p> </li> <li> <p>Neutral:</p> </li> <li>Documentation build process unchanged (still <code>make docs</code>)</li> <li>Same tooling (MkDocs + Material theme)</li> </ul>"},{"location":"adr/ADR-016-pyo3-api-documentation/#references","title":"References","text":"<ul> <li>PEP 484 - Type Hints</li> <li>PEP 561 - Distributing and Packaging Type Information</li> <li>mkdocstrings documentation</li> <li>PyO3 documentation</li> </ul>"},{"location":"adr/ADR-017-release-process/","title":"ADR-017: Release Process","text":""},{"location":"adr/ADR-017-release-process/#status","title":"Status","text":"<ul> <li>Proposed by: Ryan on 2026-01-08</li> <li>Accepted on: 2026-01-08</li> </ul>"},{"location":"adr/ADR-017-release-process/#context","title":"Context","text":"<p>Holoconf is a multi-language project with packages for: - Rust: <code>holoconf-core</code> and <code>holoconf-cli</code> crates (crates.io) - Python: <code>holoconf</code> package (PyPI) - Node.js: Future npm package</p> <p>We need a consistent, automated release process that: 1. Keeps all package versions synchronized 2. Updates the changelog appropriately 3. Publishes to all package registries 4. Creates GitHub releases with binaries</p>"},{"location":"adr/ADR-017-release-process/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/ADR-017-release-process/#alternative-1-manual-releases","title":"Alternative 1: Manual Releases","text":"<ul> <li>Description: Developer manually updates versions, changelog, tags, and publishes each package</li> <li>Pros: Simple, no tooling needed</li> <li>Cons: Error-prone, inconsistent, easy to forget steps, packages can get out of sync</li> </ul>"},{"location":"adr/ADR-017-release-process/#alternative-2-cargo-release","title":"Alternative 2: cargo-release","text":"<ul> <li>Description: Use <code>cargo-release</code> to automate Rust releases with hooks for other languages</li> <li>Pros: Well-maintained, handles Rust crates well</li> <li>Cons: Rust-centric, hooks for Python/npm are awkward, doesn't integrate with GitHub releases</li> </ul>"},{"location":"adr/ADR-017-release-process/#alternative-3-release-please","title":"Alternative 3: release-please","text":"<ul> <li>Description: Google's release automation tool that generates releases from conventional commits</li> <li>Pros: Fully automated, generates changelogs</li> <li>Cons: Requires conventional commit format, more complex setup, opinionated workflow</li> </ul>"},{"location":"adr/ADR-017-release-process/#alternative-4-makefile-tag-triggered-ci","title":"Alternative 4: Makefile + Tag-Triggered CI","text":"<ul> <li>Description: <code>make release</code> for local preparation, GitHub Actions for publishing</li> <li>Pros: Simple, predictable, works across all languages, no commit format requirements</li> <li>Cons: Requires manual changelog entries</li> </ul>"},{"location":"adr/ADR-017-release-process/#decision","title":"Decision","text":"<p>Use a two-part release process: 1. Local preparation via <code>make release VERSION=x.y.z</code> 2. CI publishing via tag-triggered GitHub Actions</p>"},{"location":"adr/ADR-017-release-process/#design","title":"Design","text":""},{"location":"adr/ADR-017-release-process/#pre-release-check","title":"Pre-Release Check","text":"<p>Before releasing, run all checks without making changes:</p> <pre><code>make release-check\n</code></pre> <p>This runs: 1. Working directory check - Warns if uncommitted changes exist 2. Branch check - Warns if not on <code>main</code> 3. Full test suite - Rust, Python, and acceptance tests 4. Semver compatibility - Checks for breaking changes 5. Changelog coverage - Reviews changes that may need documentation</p>"},{"location":"adr/ADR-017-release-process/#release-command","title":"Release Command","text":"<pre><code>make release VERSION=0.2.0\n</code></pre> <p>This command: 1. Pre-flight checks:    - Verifies no uncommitted changes    - Verifies on <code>main</code> branch    - Runs full test suite locally 2. Updates versions in:    - <code>Cargo.toml</code> (workspace version)    - <code>packages/python/holoconf/pyproject.toml</code> 3. Updates CHANGELOG.md:    - Moves <code>[Unreleased]</code> section to <code>[VERSION] - DATE</code>    - Adds new empty <code>[Unreleased]</code> section 4. Creates commit and tag:    - Commit: <code>chore: release vX.Y.Z</code>    - Tag: <code>vX.Y.Z</code> 5. Prints next step: <code>git push origin main --tags</code></p>"},{"location":"adr/ADR-017-release-process/#ci-workflow-releaseyml","title":"CI Workflow (release.yml)","text":"<p>Triggered by pushing a <code>v*</code> tag:</p> <pre><code>validate \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n    \u2502                                                              \u2502\n    \u251c\u2500\u2500\u25ba build-python (parallel)                                   \u2502\n    \u2502      \u251c\u2500 x86_64-linux                                         \u2502\n    \u2502      \u251c\u2500 aarch64-linux                                        \u2502\n    \u2502      \u251c\u2500 x86_64-darwin                                        \u2502\n    \u2502      \u251c\u2500 aarch64-darwin                                       \u2502\n    \u2502      \u2514\u2500 x86_64-windows                                       \u2502\n    \u2502                                                              \u2502\n    \u251c\u2500\u2500\u25ba build-cli (parallel)                                      \u2502\n    \u2502      \u251c\u2500 linux (x86_64, aarch64)                              \u2502\n    \u2502      \u251c\u2500 macos (x86_64, aarch64)                              \u2502\n    \u2502      \u2514\u2500 windows (x86_64)                                     \u2502\n    \u2502                                                              \u2502\n    \u2514\u2500\u2500\u25ba publish-crates \u2500\u2500\u25ba publish-pypi \u2500\u2500\u25ba github-release \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"adr/ADR-017-release-process/#version-synchronization","title":"Version Synchronization","text":"<p>All packages share the same version number, derived from the git tag: - Tag: <code>v0.2.0</code> - Cargo.toml: <code>version = \"0.2.0\"</code> - pyproject.toml: <code>version = \"0.2.0\"</code></p>"},{"location":"adr/ADR-017-release-process/#changelog-format","title":"Changelog Format","text":"<p>Using Keep a Changelog format:</p> <pre><code>## [Unreleased]\n\n## [0.2.0] - 2026-01-15\n\n### Added\n- New feature X\n\n### Fixed\n- Bug Y\n</code></pre> <p>Changelog entries are added manually during development.</p>"},{"location":"adr/ADR-017-release-process/#changelog-review-tool","title":"Changelog Review Tool","text":"<p>Before releasing, run <code>make changelog-check</code> to review changes that may need changelog entries:</p> <pre><code>make changelog-check\n</code></pre> <p>This analyzes changes since the last release tag and reports: - Feature spec status changes (e.g., Draft \u2192 Implemented) - New/modified acceptance tests - New Rust unit tests (functions with <code>#[test]</code>) - New Python unit tests (functions matching <code>test_*</code>) - New feature specs and ADRs</p> <p>Example output: <pre><code>\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\nChangelog Review for Next Release\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\nComparing against: v0.1.0\n\nCurrent [Unreleased] section:\n----------------------------------------\n  - Added env resolver with default value support\n  - Fixed schema validation for nested objects\n\nChanges since v0.1.0 that may need changelog entries:\n\n  Feature Specs:\n    ! FEAT-002: Draft -&gt; Implemented\n\n  Acceptance Tests (3 new/modified):\n    + tests/acceptance/resolvers/env_resolver.yaml\n    + tests/acceptance/resolvers/env_defaults.yaml\n    ~ tests/acceptance/schema/nested_validation.yaml\n\n  Rust Unit Tests (2 new #[test]):\n    + crates/holoconf-core/src/resolvers/env.rs (2 new)\n\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\nReview: Do the changelog entries above cover these changes?\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n</code></pre></p> <p>This is a review tool, not a gate\u2014use your judgment to determine if changes warrant changelog entries.</p>"},{"location":"adr/ADR-017-release-process/#bootstrapping-manual-publishing","title":"Bootstrapping: Manual Publishing","text":"<p>For the initial release, trusted publishing (PyPI OIDC) requires the package to exist first. Use manual publishing to bootstrap:</p> <pre><code># Publish Rust crates (requires: cargo login)\nmake publish-crates\n\n# Publish Python wheel (requires: twine + ~/.pypirc or TWINE_* env vars)\nmake publish-pypi\n\n# Publish all packages\nmake publish-local\n</code></pre> <p>One-time setup:</p> <ol> <li>crates.io: Run <code>cargo login</code> with your API token from https://crates.io/settings/tokens</li> <li>PyPI: Create <code>~/.pypirc</code> or set <code>TWINE_USERNAME</code> and <code>TWINE_PASSWORD</code> env vars</li> </ol> <p>After the initial publish, configure CI trusted publishing: - PyPI: Add OIDC publisher in project settings (no token needed) - crates.io: Add <code>CARGO_REGISTRY_TOKEN</code> to GitHub repo secrets</p>"},{"location":"adr/ADR-017-release-process/#required-secrets","title":"Required Secrets","text":"Secret Purpose Configuration <code>CARGO_REGISTRY_TOKEN</code> Publish to crates.io GitHub repo secrets PyPI OIDC Publish to PyPI PyPI trusted publishing (no secret needed) <code>NPM_TOKEN</code> (future) Publish to npm GitHub repo secrets"},{"location":"adr/ADR-017-release-process/#rationale","title":"Rationale","text":"<p>This approach was chosen because:</p> <ol> <li>Simplicity: Two clear phases (local prep, CI publish) with no magic</li> <li>Multi-language support: Works equally well for Rust, Python, and future npm packages</li> <li>No commit format requirements: Developers write changelog entries naturally</li> <li>Safety: Local tests must pass before tagging; CI tests run again before publishing</li> <li>Manual push: Final checkpoint before irreversible publishing to registries</li> </ol>"},{"location":"adr/ADR-017-release-process/#trade-offs-accepted","title":"Trade-offs Accepted","text":"<ul> <li>Manual changelog entries in exchange for no conventional commit requirement</li> <li>Two-step process (make release + git push) in exchange for final safety checkpoint</li> <li>sed-based version updates in exchange for no additional tooling dependencies</li> </ul>"},{"location":"adr/ADR-017-release-process/#migration","title":"Migration","text":"<p>N/A - This is a new process for the initial release.</p>"},{"location":"adr/ADR-017-release-process/#consequences","title":"Consequences","text":"<ul> <li>Positive: Consistent releases across all package types</li> <li>Positive: Single command prepares everything locally</li> <li>Positive: CI handles all publishing automatically</li> <li>Positive: Changelog review tool helps catch undocumented changes</li> <li>Negative: Must remember to add changelog entries before releasing (mitigated by <code>make changelog-check</code>)</li> <li>Neutral: Version must be specified explicitly (no auto-increment)</li> </ul>"},{"location":"adr/ADR-018-git-workflow/","title":"ADR-018: Pull Request and Merge Process","text":""},{"location":"adr/ADR-018-git-workflow/#status","title":"Status","text":"<ul> <li>Proposed by: Ryan on 2026-01-11</li> <li>Accepted on: 2026-01-11</li> </ul>"},{"location":"adr/ADR-018-git-workflow/#context","title":"Context","text":"<p>As the project grows and gains contributors, we need a documented process for submitting and approving changes. Key concerns:</p> <ol> <li>Maintaining a clean, linear commit history on main</li> <li>Ensuring all changes pass CI before merging</li> <li>Consistent code quality through review and automated checks</li> <li>Clear expectations for contributors</li> </ol>"},{"location":"adr/ADR-018-git-workflow/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/ADR-018-git-workflow/#alternative-1-merge-commits","title":"Alternative 1: Merge Commits","text":"<pre><code>main:    A---B---C-------M\n              \\       /\nfeature:       D---E---F\n</code></pre> <ul> <li>Pros: Full history preserved, easy to revert entire features, non-destructive</li> <li>Cons: Non-linear history, harder to bisect, cluttered <code>git log</code></li> </ul>"},{"location":"adr/ADR-018-git-workflow/#alternative-2-squash-and-merge-github","title":"Alternative 2: Squash and Merge (GitHub)","text":"<pre><code>main:    A---B---C---S (single commit with all changes)\n</code></pre> <ul> <li>Pros: Very clean main branch, atomic features, easy reverts, simple contributor workflow</li> <li>Cons: Loses granular commit history, multiple authors compressed to one commit</li> </ul>"},{"location":"adr/ADR-018-git-workflow/#alternative-3-rebase-fast-forward-only","title":"Alternative 3: Rebase + Fast-Forward Only","text":"<pre><code>main:    A---B---C---D---E---F (linear)\n</code></pre> <ul> <li>Pros: Linear history, full commit granularity preserved, easy bisect, clear progression</li> <li>Cons: Requires contributors to rebase before merge, force-push on feature branches, complex local workflow</li> </ul>"},{"location":"adr/ADR-018-git-workflow/#decision","title":"Decision","text":"<p>Use GitHub's \"Squash and merge\" for all merges to main.</p> <p>This gives us: - Linear history on main (no merge commits) - Atomic features (one commit per PR, easy to revert) - Simple contributor workflow (no local squashing or rebasing required) - Automatic squashing handled by GitHub at merge time</p>"},{"location":"adr/ADR-018-git-workflow/#requirements","title":"Requirements","text":""},{"location":"adr/ADR-018-git-workflow/#before-submitting-a-pr","title":"Before Submitting a PR","text":"<ol> <li>Pass local checks: Run <code>make check</code> before pushing</li> <li>Formatting: <code>ruff format</code> (Python), <code>cargo fmt</code> (Rust)</li> <li>Linting: <code>ruff check</code> (Python), <code>cargo clippy</code> (Rust)</li> <li> <p>Tests: All tests must pass</p> </li> <li> <p>PR title format: Use conventional commit format for PR titles:    <pre><code>&lt;type&gt;: &lt;description&gt;\n</code></pre>    Types: <code>feat</code>, <code>fix</code>, <code>docs</code>, <code>refactor</code>, <code>test</code>, <code>chore</code></p> </li> </ol> <p>The PR title becomes the squash commit message on main, giving us conventional commits on main without requiring them on individual development commits.</p>"},{"location":"adr/ADR-018-git-workflow/#pr-approval-requirements","title":"PR Approval Requirements","text":"<ol> <li>CI Pipeline: All workflow gate jobs must pass:</li> <li>Quality checks - Linting, security audits, unused dependency checks (all languages)</li> <li>Language-specific checks - Unit tests, acceptance tests, builds for each supported language</li> <li> <p>Documentation - Docs build successfully</p> </li> <li> <p>Code Review: At least one approving review (when multiple contributors)</p> </li> </ol>"},{"location":"adr/ADR-018-git-workflow/#merge-process","title":"Merge Process","text":"<ol> <li>Contributor pushes feature branch and creates PR</li> <li>CI runs automatically</li> <li>Reviewer approves PR</li> <li>Maintainer clicks \"Squash and merge\" and edits the commit message</li> <li>GitHub squashes all commits into one and adds to main</li> </ol>"},{"location":"adr/ADR-018-git-workflow/#github-repository-configuration","title":"GitHub Repository Configuration","text":"<p>1. Merge method (Settings &gt; General &gt; Pull Requests): - Enable only \"Allow squash merging\" - Disable \"Allow merge commits\" and \"Allow rebase merging\"</p> <p>2. Branch protection (Settings &gt; Rules &gt; Rulesets):</p> <p>Ruleset name: <code>Default Branch Ruleset</code></p> <p>Targeting <code>main</code> (Default Branch): - Require status checks to pass: All workflow gate jobs (see CI Workflow Structure below) - Require pull request reviews: 1 approving review - Dismiss stale reviews on push: Enabled - Require resolution of review threads: Enabled - Require linear history: Enabled - Block deletions: Enabled - Block force pushes: Enabled - Bypass list: Repository administrators (for emergency merges)</p> <p>This keeps squash-merge enforced repo-wide while requiring CI to pass for merges to <code>main</code>, with admin override for emergencies.</p> <p>3. CI Workflow Structure:</p> <p>Each workflow has a gate job (named <code>&lt;Category&gt; Complete</code>) that aggregates all jobs in that workflow. The ruleset requires all gate jobs to pass.</p> Workflow Gate Job Purpose <code>quality.yml</code> <code>Quality Complete</code> Linting, security audits, unused deps (all languages) <code>docs.yml</code> <code>Docs Complete</code> Documentation builds <code>&lt;lang&gt;.yml</code> <code>&lt;Lang&gt; Complete</code> Language-specific tests and builds <p>Adding a new language binding:</p> <ol> <li>Create <code>.github/workflows/&lt;lang&gt;.yml</code> with tests, builds, and a gate job named <code>&lt;Lang&gt; Complete</code></li> <li>Update the ruleset to require the new gate job:    <pre><code># Add to required_status_checks in the ruleset\ngh api repos/&lt;owner&gt;/&lt;repo&gt;/rulesets/&lt;id&gt; --method PUT ...\n</code></pre></li> <li>Add language-specific quality checks to <code>quality.yml</code> if needed</li> </ol>"},{"location":"adr/ADR-018-git-workflow/#completed","title":"Completed","text":"<ul> <li>[x] Branch protection rules to configure on GitHub (use Rulesets)</li> <li>[x] Set up required status checks</li> </ul>"},{"location":"adr/ADR-018-git-workflow/#rationale","title":"Rationale","text":"<ol> <li>Linear history makes <code>git log</code>, <code>git bisect</code>, and understanding project evolution straightforward</li> <li>Squash at merge simplifies the contributor workflow - no need to learn rebase</li> <li>CI gates catch issues before they reach main</li> <li>Consistent formatting reduces noise in diffs and reviews</li> <li>One commit per feature makes reverting atomic and clean</li> </ol>"},{"location":"adr/ADR-018-git-workflow/#trade-offs-accepted","title":"Trade-offs Accepted","text":"<ul> <li>Lost granular history in exchange for simpler workflow</li> <li>Squash at merge means individual commits aren't preserved on main</li> <li>Stricter process in exchange for higher code quality</li> <li>No signed commit requirement: With squash-and-merge, individual commit signatures don't survive anyway. Accountability is provided by PR metadata (author, reviewers) and GitHub's audit log.</li> </ul>"},{"location":"adr/ADR-018-git-workflow/#migration","title":"Migration","text":"<p>N/A - This documents the process going forward.</p>"},{"location":"adr/ADR-018-git-workflow/#consequences","title":"Consequences","text":"<ul> <li>Positive: Clean, linear, bisectable history on main</li> <li>Positive: Consistent code quality through automated checks</li> <li>Positive: Simple contributor workflow (no rebasing required)</li> <li>Positive: Easy to revert entire features (single commit)</li> <li>Negative: Granular commit history lost on main (preserved in PR)</li> <li>Neutral: Maintainers responsible for final merge and commit message</li> </ul>"},{"location":"adr/ADR-019-resolver-extension-packages/","title":"ADR-019: Resolver Extension Packages","text":""},{"location":"adr/ADR-019-resolver-extension-packages/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/ADR-019-resolver-extension-packages/#context","title":"Context","text":"<p>As holoconf grows, users need ways to add custom resolvers for their specific infrastructure (AWS SSM, HashiCorp Vault, Azure Key Vault, etc.). We need a pattern for creating extension packages that:</p> <ol> <li>Can be published and installed independently</li> <li>Work seamlessly with the core holoconf library</li> <li>Support both Rust and Python implementations</li> <li>Allow automatic discovery and registration</li> </ol>"},{"location":"adr/ADR-019-resolver-extension-packages/#decision","title":"Decision","text":""},{"location":"adr/ADR-019-resolver-extension-packages/#global-resolver-registry","title":"Global Resolver Registry","text":"<p>We use a global resolver registry pattern where resolvers can be registered once and used by all Config instances:</p> <p>Rust: <pre><code>use holoconf_core::resolver::{register_global, Resolver};\nuse std::sync::Arc;\n\nlet resolver = Arc::new(MyResolver::new());\nregister_global(resolver, force: bool)?;\n</code></pre></p> <p>Python: <pre><code>import holoconf\n\ndef my_resolver(arg, **kwargs):\n    return value\n\nholoconf.register_resolver(\"my\", my_resolver)\n</code></pre></p>"},{"location":"adr/ADR-019-resolver-extension-packages/#extension-package-pattern","title":"Extension Package Pattern","text":""},{"location":"adr/ADR-019-resolver-extension-packages/#rust-extension-crates","title":"Rust Extension Crates","text":"<p>Rust extension crates (e.g., <code>holoconf-aws</code>) should:</p> <ol> <li>Depend on <code>holoconf-core</code> for resolver traits</li> <li>Implement <code>Resolver</code> trait for each resolver</li> <li>Provide a <code>register()</code> function to register all resolvers</li> <li>Use <code>register_global(resolver, force=true)</code> for registration</li> </ol> <p>Example structure: <pre><code>holoconf-aws/\n\u251c\u2500\u2500 Cargo.toml\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 lib.rs          # register_all(), re-exports\n\u2502   \u2514\u2500\u2500 ssm.rs          # SsmResolver implementation\n</code></pre></p>"},{"location":"adr/ADR-019-resolver-extension-packages/#python-extension-packages","title":"Python Extension Packages","text":"<p>Python extension packages (e.g., <code>holoconf-aws</code>) can be implemented in two ways:</p> <p>Option A: PyO3 bindings to Rust (recommended)</p> <p>Use PyO3 to expose Rust resolvers to Python. This ensures consistent behavior across both languages and avoids code duplication.</p> <pre><code>holoconf-aws/\n\u251c\u2500\u2500 pyproject.toml          # maturin build, entry points\n\u251c\u2500\u2500 src/holoconf_aws/\n\u2502   \u251c\u2500\u2500 __init__.py         # Re-exports from Rust bindings\n\u2502   \u2514\u2500\u2500 _holoconf_aws.pyi   # Type stubs\n</code></pre> <p>The Rust implementation lives in a separate PyO3 crate (e.g., <code>holoconf-aws-python</code>) that depends on the Rust resolver crate.</p> <p>Option B: Pure Python</p> <p>For simpler resolvers or when Rust isn't needed:</p> <pre><code>holoconf-aws/\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 src/holoconf_aws/\n\u2502   \u251c\u2500\u2500 __init__.py     # Registration functions\n\u2502   \u2514\u2500\u2500 resolver.py     # Resolver implementation\n</code></pre>"},{"location":"adr/ADR-019-resolver-extension-packages/#plugin-discovery","title":"Plugin Discovery","text":"<p>Python packages declare entry points in <code>pyproject.toml</code>:</p> <pre><code>[project.entry-points.\"holoconf.resolvers\"]\nssm = \"holoconf_aws:register_ssm\"\n</code></pre> <p>Plugins are automatically discovered and registered when holoconf is imported. No explicit import or registration is needed:</p> <pre><code>import holoconf  # Auto-discovers all installed plugins\n\n# SSM resolver is already available (if holoconf-aws is installed)\nconfig = holoconf.Config.loads(\"secret: ${ssm:/app/password}\")\n</code></pre> <p>The <code>discover_plugins()</code> function is called automatically at import time. It can also be called manually to re-discover plugins if new ones are installed at runtime:</p> <pre><code>loaded = holoconf.discover_plugins()\nprint(f\"Loaded plugins: {loaded}\")  # ['ssm']\n</code></pre> <p>If a plugin fails to load, a warning is logged (but does not raise an exception).</p>"},{"location":"adr/ADR-019-resolver-extension-packages/#error-handling-for-custom-resolvers","title":"Error Handling for Custom Resolvers","text":"<p>Custom resolvers should follow these patterns for proper framework integration:</p> <ol> <li>Raise <code>KeyError</code> for \"not found\" conditions - This triggers framework-level default handling</li> <li>Raise <code>ValueError</code> for validation errors - This becomes a resolver error</li> <li>Return <code>ResolvedValue(value, sensitive=True)</code> for secrets - This enables redaction</li> </ol>"},{"location":"adr/ADR-019-resolver-extension-packages/#framework-level-kwargs","title":"Framework-Level Kwargs","text":"<p>The framework handles these kwargs uniformly for all resolvers:</p> <ul> <li><code>default</code>: Value to use if resolver raises KeyError</li> <li><code>sensitive</code>: Override automatic sensitivity detection</li> </ul> <p>Resolvers should NOT handle these kwargs themselves.</p>"},{"location":"adr/ADR-019-resolver-extension-packages/#consequences","title":"Consequences","text":""},{"location":"adr/ADR-019-resolver-extension-packages/#positive","title":"Positive","text":"<ul> <li>Clean separation between core library and extensions</li> <li>Extensions can be published independently</li> <li>Plugin discovery enables zero-config usage</li> <li>Consistent patterns for both Rust and Python</li> <li>Framework handles cross-cutting concerns (defaults, sensitivity)</li> </ul>"},{"location":"adr/ADR-019-resolver-extension-packages/#negative","title":"Negative","text":"<ul> <li>Global state (registry) complicates testing</li> <li>Need to document KeyError convention for default handling</li> <li>Two implementations (Rust and Python) for each resolver</li> </ul>"},{"location":"adr/ADR-019-resolver-extension-packages/#mitigations","title":"Mitigations","text":"<ul> <li>Tests can use <code>register_global(resolver, force=true)</code> to override</li> <li>Clear documentation of error handling conventions</li> <li>PyO3 bindings allow Python to use the same Rust implementation</li> </ul>"},{"location":"adr/template/","title":"ADR-NNN: Title","text":""},{"location":"adr/template/#status","title":"Status","text":"<ul> <li>Proposed by: [name] on [date]</li> <li>Accepted on: [date] (when applicable)</li> <li>Supersedes: ADR-XXX (if applicable)</li> </ul>"},{"location":"adr/template/#context","title":"Context","text":"<p>[What is the issue that we're seeing that is motivating this decision?]</p>"},{"location":"adr/template/#alternatives-considered","title":"Alternatives Considered","text":""},{"location":"adr/template/#alternative-1-name","title":"Alternative 1: [Name]","text":"<ul> <li>Description</li> <li>Pros</li> <li>Cons</li> </ul>"},{"location":"adr/template/#alternative-2-name","title":"Alternative 2: [Name]","text":"<p>...</p>"},{"location":"adr/template/#open-questions-proposal-phase","title":"Open Questions (Proposal Phase)","text":"<ul> <li>[ ] Question 1</li> <li>[ ] Question 2</li> </ul>"},{"location":"adr/template/#next-steps-proposal-phase","title":"Next Steps (Proposal Phase)","text":"<ul> <li>[ ] Step 1</li> <li>[ ] Step 2</li> </ul>"},{"location":"adr/template/#decision","title":"Decision","text":"<p>[The decision that was made]</p>"},{"location":"adr/template/#design","title":"Design","text":"<p>[Technical design details, diagrams, code examples]</p>"},{"location":"adr/template/#rationale","title":"Rationale","text":"<p>[Why this decision was chosen over alternatives]</p>"},{"location":"adr/template/#trade-offs-accepted","title":"Trade-offs Accepted","text":"<ul> <li>Trade-off 1: [what we gave up] in exchange for [what we gained]</li> <li>Trade-off 2: ...</li> </ul>"},{"location":"adr/template/#migration","title":"Migration","text":"<p>[If this changes existing behavior, how do we migrate? Write \"N/A\" for new features.]</p>"},{"location":"adr/template/#consequences","title":"Consequences","text":"<ul> <li>Positive: ...</li> <li>Negative: ...</li> <li>Neutral: ...</li> </ul>"},{"location":"api/cli/","title":"HoloConf CLI","text":"<p>The <code>holoconf</code> CLI provides tools for inspecting, validating, and exporting configuration files from the command line.</p>"},{"location":"api/cli/#installation","title":"Installation","text":"<p>Choose your preferred installation method:</p> pip (Python)cargo (Rust)pipx (Isolated)Binary (Direct) <p>Install from PyPI with the Python package:</p> <pre><code>pip install holoconf\n</code></pre> <p>The CLI is included with the Python package. Best for users who also use the Python library.</p> <p>Install from crates.io:</p> <pre><code>cargo install holoconf-cli\n</code></pre> <p>Standalone binary without Python dependency. Best for system-wide installation or CI/CD pipelines.</p> <p>Install in an isolated environment:</p> <pre><code>pipx install holoconf\n</code></pre> <p>Keeps HoloConf isolated from your project's dependencies. Best for global CLI tools.</p> <p>Download pre-built binaries from GitHub Releases:</p> <pre><code># Linux (x86_64)\ncurl -L https://github.com/rfestag/holoconf/releases/latest/download/holoconf-linux-x86_64.tar.gz | tar xz\nsudo mv holoconf /usr/local/bin/\n\n# macOS (Apple Silicon)\ncurl -L https://github.com/rfestag/holoconf/releases/latest/download/holoconf-darwin-arm64.tar.gz | tar xz\nsudo mv holoconf /usr/local/bin/\n</code></pre> <p>Pre-built binaries for fast installation without compilation.</p> <p>Verify installation:</p> <pre><code>holoconf --version\n</code></pre>"},{"location":"api/cli/#quick-start","title":"Quick Start","text":"<pre><code># Check syntax\nholoconf check config.yaml\n\n# Get a specific value\nholoconf get config.yaml database.host\n\n# Dump resolved configuration\nholoconf dump config.yaml --resolve\n\n# Validate against a schema\nholoconf validate config.yaml --schema schema.json\n</code></pre>"},{"location":"api/cli/#commands","title":"Commands","text":""},{"location":"api/cli/#holoconf-check","title":"holoconf check","text":"<p>Quick syntax check for configuration files.</p> <pre><code>holoconf check &lt;FILES&gt;...\n</code></pre> <p>Examples:</p> <pre><code>$ holoconf check config.yaml\n\u2713 config.yaml: valid YAML\n\n$ holoconf check config.yaml secrets.yaml\n\u2713 config.yaml: valid YAML\n\u2713 secrets.yaml: valid YAML\n\n$ holoconf check broken.yaml\n\u2717 broken.yaml: expected ':', but found '-' at line 3 column 1\n</code></pre>"},{"location":"api/cli/#holoconf-get","title":"holoconf get","text":"<p>Get a specific value from configuration.</p> <pre><code>holoconf get &lt;FILES&gt;... &lt;PATH&gt; [OPTIONS]\n</code></pre> <p>Options:</p> Option Description <code>-r, --resolve</code> Resolve interpolations (default: raw value) <code>-f, --format</code> Output format: <code>text</code>, <code>json</code>, <code>yaml</code> (default: text) <code>-d, --default</code> Default value if path not found <code>--schema</code> Path to schema file for default values <p>Examples:</p> <pre><code># Get a value\n$ holoconf get config.yaml app.name\nmy-application\n\n# Get with resolution\n$ DB_HOST=prod.example.com holoconf get config.yaml database.host -r\nprod.example.com\n\n# Get nested object as JSON\n$ holoconf get config.yaml database -f json\n{\"host\": \"localhost\", \"port\": 5432}\n\n# Use default if not found\n$ holoconf get config.yaml optional.key -d \"fallback\"\nfallback\n\n# Merge multiple files, then get\n$ holoconf get base.yaml production.yaml database.host\nprod-db.example.com\n\n# Get with schema defaults (returns schema default if path missing)\n$ holoconf get config.yaml database.pool_size --schema schema.yaml\n10\n</code></pre>"},{"location":"api/cli/#holoconf-dump","title":"holoconf dump","text":"<p>Export entire configuration.</p> <pre><code>holoconf dump &lt;FILES&gt;... [OPTIONS]\n</code></pre> <p>Options:</p> Option Description <code>-r, --resolve</code> Resolve all interpolations <code>-f, --format</code> Output format: <code>yaml</code>, <code>json</code> (default: yaml) <code>-o, --output</code> Write to file instead of stdout <code>--no-redact</code> Don't redact sensitive values <code>--schema</code> Path to schema file for default values <p>Examples:</p> <pre><code># Dump as YAML (default)\n$ holoconf dump config.yaml\napp:\n  name: my-application\ndatabase:\n  host: ${env:DB_HOST,default=localhost}\n\n# Dump resolved as JSON\n$ holoconf dump config.yaml --resolve --format json\n{\n  \"app\": {\"name\": \"my-application\"},\n  \"database\": {\"host\": \"localhost\"}\n}\n\n# Dump merged configs\n$ holoconf dump base.yaml production.yaml --resolve\n\n# Write to file\n$ holoconf dump config.yaml --resolve -o resolved.yaml\n\u2713 Wrote to resolved.yaml\n\n# Dump with schema defaults applied\n$ holoconf dump config.yaml --schema schema.yaml --resolve\n</code></pre>"},{"location":"api/cli/#holoconf-validate","title":"holoconf validate","text":"<p>Validate configuration against JSON Schema.</p> <pre><code>holoconf validate &lt;FILES&gt;... --schema &lt;SCHEMA&gt; [OPTIONS]\n</code></pre> <p>Options:</p> Option Description <code>-s, --schema</code> Path to schema file (required) <code>-r, --resolve</code> Resolve before validating <code>-f, --format</code> Output format: <code>text</code>, <code>json</code> (default: text) <code>-q, --quiet</code> Only output errors <p>Examples:</p> <pre><code># Validate configuration\n$ holoconf validate config.yaml --schema schema.json\n\u2713 config.yaml is valid\n\n# Validate resolved values\n$ holoconf validate config.yaml --schema schema.json --resolve\n\u2713 config.yaml is valid\n\n# Validation failure\n$ holoconf validate bad-config.yaml --schema schema.json\n\u2717 Validation failed\ndatabase.port: -1 is less than the minimum of 1\n\n# JSON output for CI\n$ holoconf validate config.yaml --schema schema.json --format json\n{\"valid\": true}\n\n# Quiet mode (exit code only)\n$ holoconf validate config.yaml --schema schema.json --quiet\n$ echo $?\n0\n</code></pre> <p>Exit Codes:</p> Code Meaning 0 Configuration is valid 1 Validation failed 2 Error reading files"},{"location":"api/cli/#exit-codes","title":"Exit Codes","text":"Code Meaning 0 Success 1 Validation or resolution error 2 File not found or I/O error"},{"location":"api/cli/#environment-variables","title":"Environment Variables","text":"Variable Description <code>NO_COLOR</code> Disable colored output when set"},{"location":"api/cli/#shell-completion","title":"Shell Completion","text":"<p>Generate shell completion scripts:</p> BashZshFish <pre><code># Add to ~/.bashrc\neval \"$(holoconf --completion bash)\"\n</code></pre> <pre><code># Add to ~/.zshrc\neval \"$(holoconf --completion zsh)\"\n</code></pre> <pre><code>holoconf --completion fish | source\n</code></pre> <p>Note</p> <p>Shell completion is planned but not yet implemented.</p>"},{"location":"api/cli/#see-also","title":"See Also","text":"<ul> <li>Getting Started - Installation and first steps</li> <li>FEAT-006 CLI - Full CLI specification</li> </ul>"},{"location":"api/python/","title":"Python Package","text":"<p>The holoconf Python package provides native bindings to the Rust core library via PyO3, giving you high-performance configuration management with Pythonic ergonomics.</p>"},{"location":"api/python/#installation","title":"Installation","text":"<pre><code>pip install holoconf\n</code></pre> <p>Requires Python 3.9 or later. The package includes pre-built wheels for common platforms.</p>"},{"location":"api/python/#quick-start","title":"Quick Start","text":"<pre><code>from holoconf import Config, Schema\n\n# Load configuration\nconfig = Config.load(\"config.yaml\")\n\n# Access values (resolves interpolations automatically)\nhost = config.get(\"database.host\")\nport = config.get(\"database.port\")\n\n# Or use dict-like access\nhost = config[\"database.host\"]\n\n# Export resolved configuration\nprint(config.to_yaml(resolve=True))\n\n# Validate against a schema\nschema = Schema.load(\"schema.json\")\nconfig.validate(schema)\n</code></pre>"},{"location":"api/python/#features","title":"Features","text":"<ul> <li>Native performance - Rust core compiled to native extension</li> <li>Lazy resolution - Values resolved on access, not at parse time</li> <li>Type coercion - <code>get_string()</code>, <code>get_int()</code>, <code>get_float()</code>, <code>get_bool()</code></li> <li>Dict-like access - <code>config[\"key\"]</code> and <code>config.key</code> syntax</li> <li>Schema validation - JSON Schema support with detailed errors</li> <li>Serialization - Export to YAML/JSON with optional redaction</li> </ul>"},{"location":"api/python/#package-contents","title":"Package Contents","text":""},{"location":"api/python/#classes","title":"Classes","text":"Class Description Config Main configuration object for loading and accessing values Schema JSON Schema validator for configuration"},{"location":"api/python/#exceptions","title":"Exceptions","text":"Exception Description HoloconfError Base exception for all holoconf errors ParseError YAML/JSON syntax errors ValidationError Schema validation failures ResolverError Resolution failures (missing env vars, etc.) PathNotFoundError Config path doesn't exist CircularReferenceError Circular reference detected TypeCoercionError Type conversion failures"},{"location":"api/python/#examples","title":"Examples","text":""},{"location":"api/python/#environment-variables-with-defaults","title":"Environment Variables with Defaults","text":"<pre><code># config.yaml:\n# database:\n#   host: ${env:DB_HOST,default=localhost}\n#   port: ${env:DB_PORT,default=5432}\n\nconfig = Config.load(\"config.yaml\")\n\n# Uses environment variable if set, otherwise default\nhost = config.get(\"database.host\")  # \"localhost\" or $DB_HOST\n</code></pre>"},{"location":"api/python/#merging-configurations","title":"Merging Configurations","text":"<pre><code># Load base config, then override with environment-specific\nconfig = Config.load_merged([\n    \"config/base.yaml\",\n    \"config/production.yaml\"\n])\n</code></pre>"},{"location":"api/python/#validation-with-error-collection","title":"Validation with Error Collection","text":"<pre><code>schema = Schema.load(\"schema.json\")\nerrors = config.validate_collect(schema)\n\nif errors:\n    print(\"Validation errors:\")\n    for error in errors:\n        print(f\"  - {error}\")\nelse:\n    print(\"Configuration is valid\")\n</code></pre>"},{"location":"api/python/#safe-export-redacted","title":"Safe Export (Redacted)","text":"<pre><code># Redact sensitive values for logging\nsafe_yaml = config.to_yaml(resolve=True, redact=True)\nprint(safe_yaml)\n# database:\n#   host: prod-db.example.com\n#   password: \"[REDACTED]\"\n</code></pre>"},{"location":"api/python/#code-coverage","title":"Code Coverage","text":"<p>The Python package coverage measures the wrapper layer (<code>__init__.py</code>, <code>cli.py</code>). The core logic is tested via Rust coverage.</p> <p>Coverage not available</p> <p>Run <code>make coverage</code> to generate coverage reports.</p> <p>Generate coverage reports</p> <p>Run <code>make coverage</code> to generate coverage data.</p>"},{"location":"api/python/#see-also","title":"See Also","text":"<ul> <li>Getting Started - Installation and first steps</li> <li>Interpolation - Variable substitution syntax</li> <li>Validation - Schema validation details</li> </ul>"},{"location":"api/python/classes/config/","title":"Config","text":"<p>Configuration object for loading and accessing configuration values.</p> <p>The Config class is the main entry point for holoconf. It provides methods for loading configuration from files or strings, accessing values with automatic interpolation resolution, and exporting configuration in various formats.</p> Example <p>config = Config.load(\"config.yaml\") host = config.get(\"database.host\") port = config.get_int(\"database.port\")</p>"},{"location":"api/python/classes/config/#holoconf.Config-functions","title":"Functions","text":""},{"location":"api/python/classes/config/#holoconf.Config.load","title":"load  <code>staticmethod</code>","text":"<pre><code>load(\n    path: str,\n    schema: str | None = None,\n    allow_http: bool = False,\n    http_allowlist: list[str] | None = None,\n    http_proxy: str | None = None,\n    http_proxy_from_env: bool = False,\n    http_ca_bundle: str | None = None,\n    http_extra_ca_bundle: str | None = None,\n    http_client_cert: str | None = None,\n    http_client_key: str | None = None,\n    http_client_key_password: str | None = None,\n    http_insecure: bool = False,\n) -&gt; Config\n</code></pre> <p>Load configuration from a YAML file (required - errors if missing).</p> <p>This is the primary way to load configuration. Use <code>Config.optional()</code> for files that may not exist.</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to the YAML file</p> <p> TYPE: <code>str</code> </p> <code>schema</code> <p>Optional path to a JSON Schema file. If provided, schema defaults    will be used when accessing missing paths.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>allow_http</code> <p>Enable HTTP resolver (disabled by default for security)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>http_allowlist</code> <p>List of URL patterns to allow (glob-style)</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>http_proxy</code> <p>Proxy URL (e.g., \"http://proxy:8080\" or \"socks5://proxy:1080\")</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>http_proxy_from_env</code> <p>Auto-detect proxy from HTTP_PROXY/HTTPS_PROXY env vars</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>http_ca_bundle</code> <p>Path to CA bundle PEM file (replaces default roots)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>http_extra_ca_bundle</code> <p>Path to extra CA bundle PEM file (adds to default roots)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>http_client_cert</code> <p>Path to client certificate (PEM or P12/PFX) for mTLS</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>http_client_key</code> <p>Path to client private key PEM (not needed for P12/PFX)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>http_client_key_password</code> <p>Password for encrypted key or P12/PFX file</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>http_insecure</code> <p>DANGEROUS - Skip TLS certificate verification</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Config</code> <p>A new Config object</p> RAISES DESCRIPTION <code>HoloconfError</code> <p>If the file cannot be read or doesn't exist</p> <code>ParseError</code> <p>If the file cannot be parsed</p> Example <p>config = Config.load(\"config.yaml\", schema=\"schema.yaml\") config.pool_size  # Returns schema default if not in config</p>"},{"location":"api/python/classes/config/#holoconf.Config.required","title":"required  <code>staticmethod</code>","text":"<pre><code>required(\n    path: str,\n    schema: str | None = None,\n    allow_http: bool = False,\n    http_allowlist: list[str] | None = None,\n    http_proxy: str | None = None,\n    http_proxy_from_env: bool = False,\n    http_ca_bundle: str | None = None,\n    http_extra_ca_bundle: str | None = None,\n    http_client_cert: str | None = None,\n    http_client_key: str | None = None,\n    http_client_key_password: str | None = None,\n    http_insecure: bool = False,\n) -&gt; Config\n</code></pre> <p>Alias for <code>load()</code> - load a required config file.</p> <p>Provided for symmetry with <code>Config.optional()</code>.</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to the YAML file</p> <p> TYPE: <code>str</code> </p> <code>schema</code> <p>Optional path to a JSON Schema file</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>allow_http</code> <p>Enable HTTP resolver (disabled by default for security)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>http_allowlist</code> <p>List of URL patterns to allow (glob-style)</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>http_proxy</code> <p>Proxy URL (e.g., \"http://proxy:8080\" or \"socks5://proxy:1080\")</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>http_proxy_from_env</code> <p>Auto-detect proxy from HTTP_PROXY/HTTPS_PROXY env vars</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>http_ca_bundle</code> <p>Path to CA bundle PEM file (replaces default roots)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>http_extra_ca_bundle</code> <p>Path to extra CA bundle PEM file (adds to default roots)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>http_client_cert</code> <p>Path to client certificate (PEM or P12/PFX) for mTLS</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>http_client_key</code> <p>Path to client private key PEM (not needed for P12/PFX)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>http_client_key_password</code> <p>Password for encrypted key or P12/PFX file</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>http_insecure</code> <p>DANGEROUS - Skip TLS certificate verification</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Config</code> <p>A new Config object</p> RAISES DESCRIPTION <code>HoloconfError</code> <p>If the file cannot be read or doesn't exist</p> <code>ParseError</code> <p>If the file cannot be parsed</p>"},{"location":"api/python/classes/config/#holoconf.Config.optional","title":"optional  <code>staticmethod</code>","text":"<pre><code>optional(path: str) -&gt; Config\n</code></pre> <p>Load an optional configuration file.</p> <p>Returns an empty Config if the file doesn't exist. Use this for configuration files that may or may not be present, such as local overrides.</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to the config file</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Config</code> <p>A Config object (empty if file doesn't exist)</p> Example <p>base = Config.load(\"base.yaml\") local = Config.optional(\"local.yaml\") base.merge(local)</p>"},{"location":"api/python/classes/config/#holoconf.Config.loads","title":"loads  <code>staticmethod</code>","text":"<pre><code>loads(\n    yaml: str,\n    base_path: str | None = None,\n    allow_http: bool = False,\n    http_allowlist: list[str] | None = None,\n    http_proxy: str | None = None,\n    http_proxy_from_env: bool = False,\n    http_ca_bundle: str | None = None,\n    http_extra_ca_bundle: str | None = None,\n    http_client_cert: str | None = None,\n    http_client_key: str | None = None,\n    http_client_key_password: str | None = None,\n    http_insecure: bool = False,\n) -&gt; Config\n</code></pre> <p>Load configuration from a YAML string.</p> PARAMETER DESCRIPTION <code>yaml</code> <p>YAML content as a string</p> <p> TYPE: <code>str</code> </p> <code>base_path</code> <p>Optional base path for resolving relative file references</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>allow_http</code> <p>Enable HTTP resolver (disabled by default for security)</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>http_allowlist</code> <p>List of URL patterns to allow (glob-style)</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>http_proxy</code> <p>Proxy URL (e.g., \"http://proxy:8080\" or \"socks5://proxy:1080\")</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>http_proxy_from_env</code> <p>Auto-detect proxy from HTTP_PROXY/HTTPS_PROXY env vars</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>http_ca_bundle</code> <p>Path to CA bundle PEM file (replaces default roots)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>http_extra_ca_bundle</code> <p>Path to extra CA bundle PEM file (adds to default roots)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>http_client_cert</code> <p>Path to client certificate (PEM or P12/PFX) for mTLS</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>http_client_key</code> <p>Path to client private key PEM (not needed for P12/PFX)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>http_client_key_password</code> <p>Password for encrypted key or P12/PFX file</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>http_insecure</code> <p>DANGEROUS - Skip TLS certificate verification</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Config</code> <p>A new Config object</p> RAISES DESCRIPTION <code>ParseError</code> <p>If the YAML is invalid</p>"},{"location":"api/python/classes/config/#holoconf.Config.from_json","title":"from_json  <code>staticmethod</code>","text":"<pre><code>from_json(json: str) -&gt; Config\n</code></pre> <p>Load configuration from a JSON string.</p> PARAMETER DESCRIPTION <code>json</code> <p>JSON content as a string</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Config</code> <p>A new Config object</p> RAISES DESCRIPTION <code>ParseError</code> <p>If the JSON is invalid</p>"},{"location":"api/python/classes/config/#holoconf.Config.get","title":"get","text":"<pre><code>get(path: str) -&gt; Any\n</code></pre> <p>Get a resolved value by path (e.g., \"database.host\").</p> <p>Interpolations like ${env:VAR} are resolved before returning.</p> PARAMETER DESCRIPTION <code>path</code> <p>Dot-separated path to the value</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>The resolved value (str, int, float, bool, list, dict, or None)</p> RAISES DESCRIPTION <code>PathNotFoundError</code> <p>If the path doesn't exist</p> <code>ResolverError</code> <p>If resolution fails (e.g., missing env var)</p>"},{"location":"api/python/classes/config/#holoconf.Config.get_raw","title":"get_raw","text":"<pre><code>get_raw(path: str) -&gt; Any\n</code></pre> <p>Get the raw (unresolved) value by path.</p> <p>Returns the value without resolving interpolations. Useful for debugging or inspecting the raw configuration.</p> PARAMETER DESCRIPTION <code>path</code> <p>Dot-separated path to the value</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>The raw value (may contain ${...} interpolation syntax)</p> RAISES DESCRIPTION <code>PathNotFoundError</code> <p>If the path doesn't exist</p>"},{"location":"api/python/classes/config/#holoconf.Config.get_string","title":"get_string","text":"<pre><code>get_string(path: str) -&gt; str\n</code></pre> <p>Get a string value, with type coercion if needed.</p> PARAMETER DESCRIPTION <code>path</code> <p>Dot-separated path to the value</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The value as a string</p> RAISES DESCRIPTION <code>TypeCoercionError</code> <p>If the value cannot be converted to string</p>"},{"location":"api/python/classes/config/#holoconf.Config.get_int","title":"get_int","text":"<pre><code>get_int(path: str) -&gt; int\n</code></pre> <p>Get an integer value, with type coercion if needed.</p> <p>String values like \"42\" will be parsed as integers.</p> PARAMETER DESCRIPTION <code>path</code> <p>Dot-separated path to the value</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The value as an integer</p> RAISES DESCRIPTION <code>TypeCoercionError</code> <p>If the value cannot be converted to integer</p>"},{"location":"api/python/classes/config/#holoconf.Config.get_float","title":"get_float","text":"<pre><code>get_float(path: str) -&gt; float\n</code></pre> <p>Get a float value, with type coercion if needed.</p> <p>String values like \"3.14\" will be parsed as floats.</p> PARAMETER DESCRIPTION <code>path</code> <p>Dot-separated path to the value</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>float</code> <p>The value as a float</p> RAISES DESCRIPTION <code>TypeCoercionError</code> <p>If the value cannot be converted to float</p>"},{"location":"api/python/classes/config/#holoconf.Config.get_bool","title":"get_bool","text":"<pre><code>get_bool(path: str) -&gt; bool\n</code></pre> <p>Get a boolean value, with strict coercion.</p> <p>Only \"true\" and \"false\" (case-insensitive) are accepted for string coercion.</p> PARAMETER DESCRIPTION <code>path</code> <p>Dot-separated path to the value</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>The value as a boolean</p> RAISES DESCRIPTION <code>TypeCoercionError</code> <p>If the value cannot be converted to boolean</p>"},{"location":"api/python/classes/config/#holoconf.Config.to_dict","title":"to_dict","text":"<pre><code>to_dict(\n    resolve: bool = True, redact: bool = False\n) -&gt; dict[str, Any]\n</code></pre> <p>Export the configuration as a Python dict.</p> <p>Binary data (from file resolver with encoding=binary) is returned as Python bytes objects.</p> PARAMETER DESCRIPTION <code>resolve</code> <p>If True (default), resolve all interpolations. If False, return raw values.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>redact</code> <p>If True (default False), redact sensitive values with \"[REDACTED]\"</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>The configuration as a Python dictionary. Values may include bytes objects.</p>"},{"location":"api/python/classes/config/#holoconf.Config.to_yaml","title":"to_yaml","text":"<pre><code>to_yaml(resolve: bool = True, redact: bool = False) -&gt; str\n</code></pre> <p>Export the configuration as YAML.</p> <p>Binary data (from file resolver with encoding=binary) is serialized as base64 strings.</p> PARAMETER DESCRIPTION <code>resolve</code> <p>If True (default), resolve all interpolations. If False, return raw values.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>redact</code> <p>If True (default False), redact sensitive values with \"[REDACTED]\"</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The configuration as a YAML string</p>"},{"location":"api/python/classes/config/#holoconf.Config.to_json","title":"to_json","text":"<pre><code>to_json(resolve: bool = True, redact: bool = False) -&gt; str\n</code></pre> <p>Export the configuration as JSON.</p> <p>Binary data (from file resolver with encoding=binary) is serialized as base64 strings.</p> PARAMETER DESCRIPTION <code>resolve</code> <p>If True (default), resolve all interpolations. If False, return raw values.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>redact</code> <p>If True (default False), redact sensitive values with \"[REDACTED]\"</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The configuration as a JSON string</p>"},{"location":"api/python/classes/config/#holoconf.Config.merge","title":"merge","text":"<pre><code>merge(other: Config) -&gt; None\n</code></pre> <p>Merge another config into this one.</p> <p>The other config's values override this config's values.</p> PARAMETER DESCRIPTION <code>other</code> <p>Another Config to merge into this one</p> <p> TYPE: <code>Config</code> </p>"},{"location":"api/python/classes/config/#holoconf.Config.resolve_all","title":"resolve_all","text":"<pre><code>resolve_all() -&gt; None\n</code></pre> <p>Resolve all values eagerly.</p> <p>By default, values are resolved lazily when accessed. This method forces resolution of all values upfront, which can be useful for detecting errors early or for performance when all values are needed.</p> RAISES DESCRIPTION <code>ResolverError</code> <p>If any value fails to resolve</p>"},{"location":"api/python/classes/config/#holoconf.Config.clear_cache","title":"clear_cache","text":"<pre><code>clear_cache() -&gt; None\n</code></pre> <p>Clear the resolution cache.</p> <p>Resolved values are cached for performance. Call this method to clear the cache, for example after environment variables have changed.</p>"},{"location":"api/python/classes/config/#holoconf.Config.get_source","title":"get_source","text":"<pre><code>get_source(path: str) -&gt; str | None\n</code></pre> <p>Get the source file for a config path.</p> <p>Returns the filename of the config file that provided this value. For merged configs, this returns the file that \"won\" for this path.</p> PARAMETER DESCRIPTION <code>path</code> <p>The config path (e.g., \"database.host\")</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str | None</code> <p>The filename or None if source tracking is not available</p>"},{"location":"api/python/classes/config/#holoconf.Config.dump_sources","title":"dump_sources","text":"<pre><code>dump_sources() -&gt; dict[str, str]\n</code></pre> <p>Get all source mappings.</p> <p>Returns a dict mapping config paths to their source filenames. Useful for debugging which file each value came from.</p> RETURNS DESCRIPTION <code>dict[str, str]</code> <p>A dict of {path: filename} entries</p>"},{"location":"api/python/classes/config/#holoconf.Config.set_schema","title":"set_schema","text":"<pre><code>set_schema(schema: Schema) -&gt; None\n</code></pre> <p>Attach a schema to this config for default value lookup.</p> <p>When a schema is attached, accessing a missing path will return the schema's default value (if defined) instead of raising PathNotFoundError.</p> PARAMETER DESCRIPTION <code>schema</code> <p>A Schema object to attach</p> <p> TYPE: <code>Schema</code> </p> Example <p>config = Config.load(\"config.yaml\") schema = Schema.load(\"schema.yaml\") config.set_schema(schema) config.pool_size  # Returns schema default if not in config</p>"},{"location":"api/python/classes/config/#holoconf.Config.get_schema","title":"get_schema","text":"<pre><code>get_schema() -&gt; Schema | None\n</code></pre> <p>Get the attached schema, if any.</p> RETURNS DESCRIPTION <code>Schema | None</code> <p>The attached Schema object, or None if no schema is attached</p>"},{"location":"api/python/classes/config/#holoconf.Config.validate","title":"validate","text":"<pre><code>validate(schema: Schema | None = None) -&gt; None\n</code></pre> <p>Validate the resolved configuration against a schema.</p> <p>This resolves all values first, then validates the resolved values against the schema, checking types, constraints, and patterns.</p> PARAMETER DESCRIPTION <code>schema</code> <p>Optional Schema object to validate against. If not provided,    uses the attached schema (set via <code>set_schema()</code> or <code>load(schema=...)</code>).</p> <p> TYPE: <code>Schema | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValidationError</code> <p>If validation fails</p> <code>ResolverError</code> <p>If resolution fails</p> <code>HoloconfError</code> <p>If no schema is provided and none is attached</p>"},{"location":"api/python/classes/config/#holoconf.Config.validate_raw","title":"validate_raw","text":"<pre><code>validate_raw(schema: Schema | None = None) -&gt; None\n</code></pre> <p>Validate the raw (unresolved) configuration against a schema.</p> <p>This performs structural validation before resolution, checking that required keys exist and the configuration structure matches the schema. Interpolation placeholders (${...}) are allowed as valid values.</p> PARAMETER DESCRIPTION <code>schema</code> <p>Optional Schema object to validate against. If not provided,    uses the attached schema (set via <code>set_schema()</code> or <code>load(schema=...)</code>).</p> <p> TYPE: <code>Schema | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValidationError</code> <p>If validation fails</p> <code>HoloconfError</code> <p>If no schema is provided and none is attached</p>"},{"location":"api/python/classes/config/#holoconf.Config.validate_collect","title":"validate_collect","text":"<pre><code>validate_collect(schema: Schema | None = None) -&gt; list[str]\n</code></pre> <p>Validate and collect all errors (instead of failing on first).</p> PARAMETER DESCRIPTION <code>schema</code> <p>Optional Schema object to validate against. If not provided,    uses the attached schema (set via <code>set_schema()</code> or <code>load(schema=...)</code>).</p> <p> TYPE: <code>Schema | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>A list of error message strings (empty if valid)</p> RAISES DESCRIPTION <code>HoloconfError</code> <p>If no schema is provided and none is attached</p>"},{"location":"api/python/classes/config/#holoconf.Config.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: str) -&gt; Any\n</code></pre> <p>Dict-like access: config[\"key\"].</p>"},{"location":"api/python/classes/config/#holoconf.Config.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(name: str) -&gt; Any\n</code></pre> <p>Attribute access: config.key.</p>"},{"location":"api/python/classes/schema/","title":"Schema","text":"<p>Schema for validating configuration against JSON Schema.</p> <p>The Schema class loads JSON Schema definitions from files or strings, and is used with Config.validate() to validate configuration values.</p> Example <p>schema = Schema.load(\"schema.json\") config.validate(schema)</p>"},{"location":"api/python/classes/schema/#holoconf.Schema-functions","title":"Functions","text":""},{"location":"api/python/classes/schema/#holoconf.Schema.load","title":"load  <code>staticmethod</code>","text":"<pre><code>load(path: str) -&gt; Schema\n</code></pre> <p>Load a schema from a file (JSON or YAML based on extension).</p> PARAMETER DESCRIPTION <code>path</code> <p>Path to the schema file (.yaml, .yml, or .json)</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Schema</code> <p>A new Schema object</p> RAISES DESCRIPTION <code>ParseError</code> <p>If the file cannot be parsed</p> <code>HoloconfError</code> <p>If the file cannot be read</p>"},{"location":"api/python/classes/schema/#holoconf.Schema.from_yaml","title":"from_yaml  <code>staticmethod</code>","text":"<pre><code>from_yaml(yaml: str) -&gt; Schema\n</code></pre> <p>Load a schema from a YAML string.</p> PARAMETER DESCRIPTION <code>yaml</code> <p>JSON Schema as a YAML string</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Schema</code> <p>A new Schema object</p> RAISES DESCRIPTION <code>ParseError</code> <p>If the YAML is invalid or not a valid JSON Schema</p>"},{"location":"api/python/classes/schema/#holoconf.Schema.from_json","title":"from_json  <code>staticmethod</code>","text":"<pre><code>from_json(json: str) -&gt; Schema\n</code></pre> <p>Load a schema from a JSON string.</p> PARAMETER DESCRIPTION <code>json</code> <p>JSON Schema as a JSON string</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Schema</code> <p>A new Schema object</p> RAISES DESCRIPTION <code>ParseError</code> <p>If the JSON is invalid or not a valid JSON Schema</p>"},{"location":"api/python/exceptions/circular-reference-error/","title":"CircularReferenceError","text":"<p>Raised when self-references create a circular dependency.</p>"},{"location":"api/python/exceptions/circular-reference-error/#when-its-raised","title":"When It's Raised","text":"<ul> <li>Direct circular reference: <code>a: ${a}</code></li> <li>Indirect circular reference: <code>a: ${b}</code> and <code>b: ${a}</code></li> <li>Longer cycles: <code>a: ${b}</code>, <code>b: ${c}</code>, <code>c: ${a}</code></li> </ul>"},{"location":"api/python/exceptions/circular-reference-error/#example","title":"Example","text":"<pre><code>from holoconf import Config, CircularReferenceError\n\nconfig = Config.loads(\"\"\"\na: ${b}\nb: ${c}\nc: ${a}\n\"\"\")\n\ntry:\n    value = config.get(\"a\")\nexcept CircularReferenceError as e:\n    print(f\"Circular reference: {e}\")\n    # Circular reference: Circular reference detected at path 'a'\n</code></pre>"},{"location":"api/python/exceptions/circular-reference-error/#prevention","title":"Prevention","text":"<p>Ensure your self-references form a directed acyclic graph (DAG):</p> <pre><code># Good - no cycles\ndefaults:\n  timeout: 30\n\ndatabase:\n  timeout: ${defaults.timeout}\n\ncache:\n  timeout: ${defaults.timeout}\n</code></pre> <pre><code># Bad - cycle between a and b\na: ${b}\nb: ${a}\n</code></pre>"},{"location":"api/python/exceptions/circular-reference-error/#class-reference","title":"Class Reference","text":"<p>               Bases: <code>HoloconfError</code></p> <p>Circular reference detected in configuration.</p> <p>Raised when a circular reference is detected during value resolution. This occurs when interpolations form a cycle, such as a value referencing itself or indirect circular dependencies.</p>"},{"location":"api/python/exceptions/holoconf-error/","title":"HoloconfError","text":"<p>Base exception for all holoconf errors.</p>"},{"location":"api/python/exceptions/holoconf-error/#exception-hierarchy","title":"Exception Hierarchy","text":"<p>All holoconf exceptions inherit from <code>HoloconfError</code>:</p> <pre><code>HoloconfError (base)\n\u251c\u2500\u2500 ParseError          - YAML/JSON syntax errors\n\u251c\u2500\u2500 ValidationError     - Schema validation failures\n\u251c\u2500\u2500 ResolverError       - Resolution failures\n\u251c\u2500\u2500 PathNotFoundError   - Config path doesn't exist\n\u251c\u2500\u2500 CircularReferenceError - Circular reference detected\n\u2514\u2500\u2500 TypeCoercionError   - Type conversion failures\n</code></pre>"},{"location":"api/python/exceptions/holoconf-error/#example","title":"Example","text":"<p>Catch all holoconf errors:</p> <pre><code>from holoconf import Config, HoloconfError\n\ntry:\n    config = Config.load(\"config.yaml\")\n    value = config.get(\"database.host\")\nexcept HoloconfError as e:\n    print(f\"Configuration error: {e}\")\n</code></pre>"},{"location":"api/python/exceptions/holoconf-error/#handling-specific-errors","title":"Handling Specific Errors","text":"<p>For more granular error handling, catch specific exception types:</p> <pre><code>from holoconf import (\n    Config,\n    ParseError,\n    PathNotFoundError,\n    ResolverError,\n    HoloconfError,\n)\n\ntry:\n    config = Config.load(\"config.yaml\")\n    value = config.get(\"database.host\")\nexcept ParseError as e:\n    print(f\"Invalid config file: {e}\")\nexcept PathNotFoundError as e:\n    print(f\"Missing config key: {e}\")\nexcept ResolverError as e:\n    print(f\"Failed to resolve: {e}\")\nexcept HoloconfError as e:\n    print(f\"Other config error: {e}\")\n</code></pre>"},{"location":"api/python/exceptions/holoconf-error/#class-reference","title":"Class Reference","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all holoconf errors.</p> <p>Catch this exception to handle any holoconf-related error.</p> Example <p>try: ...     config = Config.load(\"config.yaml\") ... except HoloconfError as e: ...     print(f\"Configuration error: {e}\")</p>"},{"location":"api/python/exceptions/parse-error/","title":"ParseError","text":"<p>Raised when YAML or JSON content cannot be parsed due to syntax errors.</p>"},{"location":"api/python/exceptions/parse-error/#when-its-raised","title":"When It's Raised","text":"<ul> <li>Invalid YAML syntax (missing colons, bad indentation, etc.)</li> <li>Invalid JSON syntax (missing quotes, trailing commas, etc.)</li> <li>Encoding errors in the configuration file</li> <li>Malformed interpolation syntax</li> </ul>"},{"location":"api/python/exceptions/parse-error/#example","title":"Example","text":"<pre><code>from holoconf import Config, ParseError\n\ntry:\n    # Invalid YAML - missing colon\n    config = Config.loads(\"\"\"\n    database\n      host: localhost\n    \"\"\")\nexcept ParseError as e:\n    print(f\"Parse error: {e}\")\n    # Parse error: expected ':', but found '-' at line 2 column 3\n</code></pre>"},{"location":"api/python/exceptions/parse-error/#handling","title":"Handling","text":"<pre><code>from holoconf import Config, ParseError\n\ndef load_config(path: str) -&gt; Config:\n    try:\n        return Config.load(path)\n    except ParseError as e:\n        print(f\"Failed to parse {path}: {e}\")\n        raise SystemExit(1)\n</code></pre>"},{"location":"api/python/exceptions/parse-error/#class-reference","title":"Class Reference","text":"<p>               Bases: <code>HoloconfError</code></p> <p>Error parsing configuration (YAML/JSON syntax).</p> <p>Raised when YAML or JSON content cannot be parsed due to syntax errors, malformed content, or encoding issues.</p>"},{"location":"api/python/exceptions/path-not-found-error/","title":"PathNotFoundError","text":"<p>Raised when a requested configuration path doesn't exist.</p>"},{"location":"api/python/exceptions/path-not-found-error/#when-its-raised","title":"When It's Raised","text":"<ul> <li>Accessing a key that doesn't exist in the configuration</li> <li>Typo in the path</li> <li>Path exists in a different config file that wasn't loaded</li> </ul>"},{"location":"api/python/exceptions/path-not-found-error/#example","title":"Example","text":"<pre><code>from holoconf import Config, PathNotFoundError\n\nconfig = Config.loads(\"\"\"\ndatabase:\n  host: localhost\n\"\"\")\n\ntry:\n    # 'port' doesn't exist\n    port = config.get(\"database.port\")\nexcept PathNotFoundError as e:\n    print(f\"Path not found: {e}\")\n    # Path not found: 'database.port' does not exist\n</code></pre>"},{"location":"api/python/exceptions/path-not-found-error/#handling-with-defaults","title":"Handling with Defaults","text":"<p>Use <code>get_raw()</code> with a try/except or check existence first:</p> <pre><code>from holoconf import Config, PathNotFoundError\n\nconfig = Config.load(\"config.yaml\")\n\n# Option 1: Try/except with default\ntry:\n    port = config.get(\"database.port\")\nexcept PathNotFoundError:\n    port = 5432  # default\n\n# Option 2: Use get_raw and check\nraw = config.to_dict(resolve=False)\nport = raw.get(\"database\", {}).get(\"port\", 5432)\n</code></pre>"},{"location":"api/python/exceptions/path-not-found-error/#class-reference","title":"Class Reference","text":"<p>               Bases: <code>HoloconfError</code></p> <p>Requested path does not exist in configuration.</p> <p>Raised when attempting to access a configuration path that doesn't exist. Check for typos in the path name, missing configuration sections, or incorrect path separators (use '.' not '/').</p>"},{"location":"api/python/exceptions/resolver-error/","title":"ResolverError","text":"<p>Raised when a resolver fails to resolve a value.</p>"},{"location":"api/python/exceptions/resolver-error/#when-its-raised","title":"When It's Raised","text":"<ul> <li>Environment variable not found (and no default provided)</li> <li>File include fails (file not found, permission denied)</li> <li>HTTP request fails (network error, non-200 response)</li> <li>Invalid resolver syntax</li> </ul>"},{"location":"api/python/exceptions/resolver-error/#example","title":"Example","text":"<pre><code>from holoconf import Config, ResolverError\n\nconfig = Config.loads(\"\"\"\ndatabase:\n  password: ${env:DB_PASSWORD}\n\"\"\")\n\ntry:\n    # Fails if DB_PASSWORD environment variable is not set\n    password = config.get(\"database.password\")\nexcept ResolverError as e:\n    print(f\"Resolution failed: {e}\")\n    # Resolution failed: Environment variable 'DB_PASSWORD' not found\n</code></pre>"},{"location":"api/python/exceptions/resolver-error/#providing-defaults","title":"Providing Defaults","text":"<p>Avoid <code>ResolverError</code> by providing default values:</p> <pre><code>database:\n  # With default - won't raise if DB_PASSWORD is not set\n  password: ${env:DB_PASSWORD,default_password}\n</code></pre>"},{"location":"api/python/exceptions/resolver-error/#handling","title":"Handling","text":"<pre><code>from holoconf import Config, ResolverError\nimport os\n\nconfig = Config.load(\"config.yaml\")\n\ntry:\n    password = config.get(\"database.password\")\nexcept ResolverError:\n    # Fall back to interactive input or other source\n    password = os.environ.get(\"DB_PASSWORD\") or input(\"Enter DB password: \")\n</code></pre>"},{"location":"api/python/exceptions/resolver-error/#class-reference","title":"Class Reference","text":"<p>               Bases: <code>HoloconfError</code></p> <p>Error during value resolution.</p> <p>Raised when a resolver fails during value resolution. Common causes include missing environment variables (without defaults), file not found for file resolver, HTTP request failures, or invalid resolver syntax.</p>"},{"location":"api/python/exceptions/type-coercion-error/","title":"TypeCoercionError","text":"<p>Raised when a value cannot be converted to the requested type.</p>"},{"location":"api/python/exceptions/type-coercion-error/#when-its-raised","title":"When It's Raised","text":"<ul> <li>Calling <code>get_int()</code> on a non-numeric string</li> <li>Calling <code>get_bool()</code> on a value that isn't boolean-like</li> <li>Calling <code>get_float()</code> on text that can't be parsed as a number</li> <li>Schema validation with type coercion enabled</li> </ul>"},{"location":"api/python/exceptions/type-coercion-error/#example","title":"Example","text":"<pre><code>from holoconf import Config, TypeCoercionError\n\nconfig = Config.loads(\"\"\"\ndatabase:\n  port: not-a-number\n\"\"\")\n\ntry:\n    port = config.get_int(\"database.port\")\nexcept TypeCoercionError as e:\n    print(f\"Type error: {e}\")\n    # Type error: Cannot convert 'not-a-number' to integer\n</code></pre>"},{"location":"api/python/exceptions/type-coercion-error/#type-coercion-rules","title":"Type Coercion Rules","text":"Method Accepts <code>get_string()</code> Any value (converts to string) <code>get_int()</code> Integers, numeric strings like <code>\"42\"</code> <code>get_float()</code> Floats, integers, numeric strings <code>get_bool()</code> Booleans, <code>\"true\"</code>/<code>\"false\"</code> (case-insensitive)"},{"location":"api/python/exceptions/type-coercion-error/#handling","title":"Handling","text":"<pre><code>from holoconf import Config, TypeCoercionError\n\nconfig = Config.load(\"config.yaml\")\n\ntry:\n    port = config.get_int(\"database.port\")\nexcept TypeCoercionError:\n    # Fall back to string and parse manually, or use default\n    port_str = config.get_string(\"database.port\")\n    port = int(port_str) if port_str.isdigit() else 5432\n</code></pre>"},{"location":"api/python/exceptions/type-coercion-error/#class-reference","title":"Class Reference","text":"<p>               Bases: <code>HoloconfError</code></p> <p>Failed to coerce value to requested type.</p> <p>Raised when a value cannot be converted to the requested type. For example, calling get_int() on a non-numeric string, or get_bool() on a string other than \"true\"/\"false\".</p>"},{"location":"api/python/exceptions/validation-error/","title":"ValidationError","text":"<p>Raised when configuration fails JSON Schema validation.</p>"},{"location":"api/python/exceptions/validation-error/#when-its-raised","title":"When It's Raised","text":"<ul> <li>Required property is missing</li> <li>Value doesn't match expected type</li> <li>Value fails pattern or format validation</li> <li>Value outside min/max bounds</li> <li>Additional properties when not allowed</li> </ul>"},{"location":"api/python/exceptions/validation-error/#example","title":"Example","text":"<pre><code>from holoconf import Config, Schema, ValidationError\n\nconfig = Config.loads(\"\"\"\ndatabase:\n  port: -1\n\"\"\")\n\nschema = Schema.from_json(\"\"\"\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"database\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"port\": {\"type\": \"integer\", \"minimum\": 1, \"maximum\": 65535}\n      }\n    }\n  }\n}\n\"\"\")\n\ntry:\n    config.validate(schema)\nexcept ValidationError as e:\n    print(f\"Validation failed: {e}\")\n    # Validation failed: -1 is less than the minimum of 1 at path 'database.port'\n</code></pre>"},{"location":"api/python/exceptions/validation-error/#collecting-all-errors","title":"Collecting All Errors","text":"<p>To get all validation errors instead of failing on the first:</p> <pre><code>errors = config.validate_collect(schema)\nif errors:\n    print(\"Validation errors:\")\n    for error in errors:\n        print(f\"  - {error}\")\n</code></pre>"},{"location":"api/python/exceptions/validation-error/#class-reference","title":"Class Reference","text":"<p>               Bases: <code>HoloconfError</code></p> <p>Schema validation error.</p> <p>Raised when configuration fails to validate against a JSON Schema. Common causes include missing required fields, type mismatches, and constraint violations.</p>"},{"location":"api/rust/","title":"holoconf-core","text":"<p>The <code>holoconf-core</code> crate is the foundation of holoconf, providing high-performance configuration management with resolver support.</p>"},{"location":"api/rust/#installation","title":"Installation","text":"<p>Add to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nholoconf-core = \"0.1\"\n</code></pre>"},{"location":"api/rust/#quick-start","title":"Quick Start","text":"<pre><code>use holoconf_core::{Config, ConfigOptions, Schema};\n\nfn main() -&gt; Result&lt;(), holoconf_core::Error&gt; {\n    // Load configuration\n    let config = Config::from_yaml_file(\"config.yaml\")?;\n\n    // Access values (resolves interpolations automatically)\n    let host = config.get_string(\"database.host\")?;\n    let port = config.get_i64(\"database.port\")?;\n\n    // Validate against a schema\n    let schema = Schema::from_file(\"schema.json\")?;\n    config.validate(&amp;schema)?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"api/rust/#features","title":"Features","text":"<ul> <li>Zero-copy parsing - Efficient YAML/JSON parsing with serde</li> <li>Lazy resolution - Values resolved on access, cached for performance</li> <li>Thread-safe - <code>Config</code> is <code>Send + Sync</code> for concurrent access</li> <li>Type coercion - Automatic conversion with schema support</li> <li>Structured errors - Rich error context with paths and suggestions</li> </ul>"},{"location":"api/rust/#api-documentation","title":"API Documentation","text":"<p>\ud83d\udcda Full API documentation on docs.rs</p> <p>The rustdoc documentation includes all public types, methods, and usage examples.</p>"},{"location":"api/rust/#feature-flags","title":"Feature Flags","text":"<pre><code>[dependencies]\nholoconf-core = { version = \"0.1\", features = [\"http\"] }\n</code></pre> Feature Description Default <code>http</code> Enable HTTP resolver No"},{"location":"api/rust/#code-coverage","title":"Code Coverage","text":"<p>The Rust crate contains all core logic: configuration parsing, interpolation, resolution, validation, and error handling.</p> <p>Coverage not available</p> <p>Run <code>make coverage</code> to generate coverage reports.</p> <p>Generate coverage reports</p> <p>Run <code>make coverage</code> to generate coverage data.</p>"},{"location":"api/rust/#see-also","title":"See Also","text":"<ul> <li>Getting Started - Installation and first steps</li> <li>ADR-001 Multi-Language Architecture - Why Rust core</li> <li>ADR-010 Thread Safety - Concurrency design</li> </ul>"},{"location":"api/rust/enums/error/","title":"Error","text":"<p>Structured error type with variants for each error kind.</p>"},{"location":"api/rust/enums/error/#overview","title":"Overview","text":"<p><code>Error</code> provides detailed error information including:</p> <ul> <li>The kind of error that occurred</li> <li>The configuration path where it happened (when applicable)</li> <li>A human-readable message with context</li> <li>Source error chain for debugging</li> </ul>"},{"location":"api/rust/enums/error/#error-kinds","title":"Error Kinds","text":"<pre><code>pub enum ErrorKind {\n    /// YAML or JSON syntax error\n    Parse,\n\n    /// Requested path doesn't exist\n    PathNotFound,\n\n    /// Resolver failed (env var not found, HTTP error, etc.)\n    Resolver(ResolverKind),\n\n    /// Schema validation failed\n    Validation,\n\n    /// Circular reference detected (a -&gt; b -&gt; a)\n    CircularReference,\n\n    /// Cannot convert value to requested type\n    TypeCoercion,\n\n    /// File I/O error\n    Io,\n}\n</code></pre>"},{"location":"api/rust/enums/error/#handling-errors","title":"Handling Errors","text":""},{"location":"api/rust/enums/error/#pattern-matching","title":"Pattern Matching","text":"<pre><code>use holoconf_core::{Config, Error, error::ErrorKind};\n\nlet result = Config::from_yaml_file(\"config.yaml\");\n\nmatch result {\n    Ok(config) =&gt; { /* use config */ }\n    Err(e) =&gt; match e.kind() {\n        ErrorKind::Parse =&gt; {\n            eprintln!(\"Invalid YAML/JSON: {}\", e);\n        }\n        ErrorKind::Io =&gt; {\n            eprintln!(\"File error: {}\", e);\n        }\n        _ =&gt; {\n            eprintln!(\"Error: {}\", e);\n        }\n    }\n}\n</code></pre>"},{"location":"api/rust/enums/error/#resolver-errors","title":"Resolver Errors","text":"<pre><code>use holoconf_core::error::{ErrorKind, ResolverKind};\n\nmatch e.kind() {\n    ErrorKind::Resolver(ResolverKind::Env) =&gt; {\n        eprintln!(\"Environment variable not found: {}\", e);\n    }\n    ErrorKind::Resolver(ResolverKind::File) =&gt; {\n        eprintln!(\"Include file not found: {}\", e);\n    }\n    ErrorKind::Resolver(ResolverKind::Http) =&gt; {\n        eprintln!(\"HTTP request failed: {}\", e);\n    }\n    _ =&gt; {}\n}\n</code></pre>"},{"location":"api/rust/enums/error/#error-context","title":"Error Context","text":""},{"location":"api/rust/enums/error/#path-information","title":"Path Information","text":"<pre><code>if let Some(path) = e.path() {\n    eprintln!(\"Error at path '{}': {}\", path, e.message());\n}\n</code></pre>"},{"location":"api/rust/enums/error/#source-chain","title":"Source Chain","text":"<pre><code>// Print full error chain\nlet mut current: Option&lt;&amp;dyn std::error::Error&gt; = Some(&amp;e);\nwhile let Some(err) = current {\n    eprintln!(\"  Caused by: {}\", err);\n    current = err.source();\n}\n</code></pre>"},{"location":"api/rust/enums/error/#converting-to-result","title":"Converting to Result","text":"<pre><code>use holoconf_core::{Config, Error};\n\nfn load_config() -&gt; Result&lt;Config, Error&gt; {\n    let config = Config::from_yaml_file(\"config.yaml\")?;\n    config.validate(&amp;schema)?;\n    Ok(config)\n}\n</code></pre>"},{"location":"api/rust/enums/error/#display-and-debug","title":"Display and Debug","text":"<pre><code>let e: Error = /* ... */;\n\n// User-friendly message\nprintln!(\"{}\", e);\n// e.g., \"Path 'database.host' not found\"\n\n// Debug representation with full context\nprintln!(\"{:?}\", e);\n// e.g., Error { kind: PathNotFound, path: Some(\"database.host\"), ... }\n</code></pre>"},{"location":"api/rust/enums/error/#common-patterns","title":"Common Patterns","text":""},{"location":"api/rust/enums/error/#graceful-fallback","title":"Graceful Fallback","text":"<pre><code>use holoconf_core::error::ErrorKind;\n\nlet port = match config.get_i64(\"database.port\") {\n    Ok(p) =&gt; p,\n    Err(e) if matches!(e.kind(), ErrorKind::PathNotFound) =&gt; 5432, // default\n    Err(e) =&gt; return Err(e),\n};\n</code></pre>"},{"location":"api/rust/enums/error/#collecting-all-errors","title":"Collecting All Errors","text":"<pre><code>let paths = [\"database.host\", \"database.port\", \"app.name\"];\nlet mut errors = Vec::new();\n\nfor path in &amp;paths {\n    if let Err(e) = config.get_string(path) {\n        errors.push(format!(\"{}: {}\", path, e));\n    }\n}\n\nif !errors.is_empty() {\n    eprintln!(\"Configuration errors:\\n{}\", errors.join(\"\\n\"));\n}\n</code></pre>"},{"location":"api/rust/enums/error/#api-reference","title":"API Reference","text":"<p>\ud83d\udcda Full rustdoc on docs.rs</p>"},{"location":"api/rust/enums/value/","title":"Value","text":"<p>Raw configuration values before type conversion.</p>"},{"location":"api/rust/enums/value/#overview","title":"Overview","text":"<p><code>Value</code> represents a configuration value in its raw form, before being converted to a specific Rust type. Use it when you need to:</p> <ul> <li>Inspect the type of a value before conversion</li> <li>Handle dynamic configuration structures</li> <li>Work with values that could be multiple types</li> </ul>"},{"location":"api/rust/enums/value/#variants","title":"Variants","text":"<pre><code>pub enum Value {\n    Null,\n    Bool(bool),\n    Integer(i64),\n    Float(f64),\n    String(String),\n    Sequence(Vec&lt;Value&gt;),\n    Mapping(IndexMap&lt;String, Value&gt;),\n}\n</code></pre>"},{"location":"api/rust/enums/value/#accessing-raw-values","title":"Accessing Raw Values","text":"<pre><code>use holoconf_core::{Config, Value};\n\nlet config = Config::from_yaml(r#\"\ndatabase:\n  host: localhost\n  port: 5432\n  replicas:\n    - host: replica1\n    - host: replica2\n  settings:\n    timeout: 30\n    ssl: true\n\"#)?;\n\nlet value = config.get_raw(\"database\")?;\n</code></pre>"},{"location":"api/rust/enums/value/#pattern-matching","title":"Pattern Matching","text":"<pre><code>use holoconf_core::Value;\n\nmatch config.get_raw(\"some.path\")? {\n    Value::Null =&gt; println!(\"null value\"),\n    Value::Bool(b) =&gt; println!(\"boolean: {}\", b),\n    Value::Integer(i) =&gt; println!(\"integer: {}\", i),\n    Value::Float(f) =&gt; println!(\"float: {}\", f),\n    Value::String(s) =&gt; println!(\"string: {}\", s),\n    Value::Sequence(arr) =&gt; {\n        println!(\"array with {} items\", arr.len());\n        for item in arr {\n            println!(\"  - {:?}\", item);\n        }\n    }\n    Value::Mapping(map) =&gt; {\n        println!(\"map with {} keys\", map.len());\n        for (key, val) in map {\n            println!(\"  {}: {:?}\", key, val);\n        }\n    }\n}\n</code></pre>"},{"location":"api/rust/enums/value/#type-checking-methods","title":"Type Checking Methods","text":"<pre><code>let value = config.get_raw(\"database.port\")?;\n\nif value.is_integer() {\n    let port = value.as_i64().unwrap();\n    println!(\"Port: {}\", port);\n}\n\n// Available methods:\n// - is_null(), as_null()\n// - is_bool(), as_bool()\n// - is_integer(), as_i64()\n// - is_float(), as_f64()\n// - is_string(), as_str()\n// - is_sequence(), as_sequence()\n// - is_mapping(), as_mapping()\n</code></pre>"},{"location":"api/rust/enums/value/#converting-to-typed-values","title":"Converting to Typed Values","text":"<pre><code>use holoconf_core::Value;\n\nlet value = config.get_raw(\"database.port\")?;\n\n// Try to convert to a specific type\nmatch value {\n    Value::Integer(i) =&gt; {\n        let port: u16 = i.try_into()?;\n        println!(\"Port: {}\", port);\n    }\n    Value::String(s) =&gt; {\n        // Handle string that might be a number\n        let port: u16 = s.parse()?;\n        println!(\"Port: {}\", port);\n    }\n    _ =&gt; return Err(\"Expected integer or string\".into()),\n}\n</code></pre>"},{"location":"api/rust/enums/value/#working-with-sequences","title":"Working with Sequences","text":"<pre><code>let replicas = config.get_raw(\"database.replicas\")?;\n\nif let Value::Sequence(items) = replicas {\n    for item in items {\n        if let Value::Mapping(map) = item {\n            if let Some(Value::String(host)) = map.get(\"host\") {\n                println!(\"Replica: {}\", host);\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"api/rust/enums/value/#working-with-mappings","title":"Working with Mappings","text":"<pre><code>use indexmap::IndexMap;\n\nlet settings = config.get_raw(\"database.settings\")?;\n\nif let Value::Mapping(map) = settings {\n    for (key, value) in &amp;map {\n        println!(\"{}: {:?}\", key, value);\n    }\n}\n</code></pre>"},{"location":"api/rust/enums/value/#api-reference","title":"API Reference","text":"<p>\ud83d\udcda Full rustdoc on docs.rs</p>"},{"location":"api/rust/structs/config-options/","title":"ConfigOptions","text":"<p>Configuration options for customizing Config behavior.</p>"},{"location":"api/rust/structs/config-options/#overview","title":"Overview","text":"<p><code>ConfigOptions</code> allows you to customize how configuration is loaded and resolved:</p> <ul> <li>Enable/disable specific resolvers</li> <li>Set resolver-specific options</li> <li>Configure resolution behavior</li> </ul>"},{"location":"api/rust/structs/config-options/#default-options","title":"Default Options","text":"<pre><code>use holoconf_core::ConfigOptions;\n\nlet options = ConfigOptions::default();\n// HTTP resolver is disabled by default\n// Environment resolver is enabled\n// File resolver is enabled\n</code></pre>"},{"location":"api/rust/structs/config-options/#available-options","title":"Available Options","text":""},{"location":"api/rust/structs/config-options/#http-resolver","title":"HTTP Resolver","text":"<p>Enable the HTTP resolver for fetching remote configuration:</p> <pre><code>use holoconf_core::{Config, ConfigOptions};\n\nlet mut options = ConfigOptions::default();\noptions.allow_http = true;\n\nlet config = Config::from_yaml_with_options(r#\"\napi_key: ${http:https://config.example.com/api-key}\n\"#, options)?;\n</code></pre> <p>Warning</p> <p>The HTTP resolver requires the <code>http</code> feature flag: <pre><code>[dependencies]\nholoconf-core = { version = \"0.1\", features = [\"http\"] }\n</code></pre></p>"},{"location":"api/rust/structs/config-options/#environment-prefix","title":"Environment Prefix","text":"<p>Restrict environment variable access to a specific prefix:</p> <pre><code>let mut options = ConfigOptions::default();\noptions.env_prefix = Some(\"MYAPP_\".to_string());\n\n// Only ${env:MYAPP_*} will resolve\nlet config = Config::from_yaml_with_options(yaml, options)?;\n</code></pre>"},{"location":"api/rust/structs/config-options/#base-path-for-file-resolver","title":"Base Path for File Resolver","text":"<p>Set the base path for file includes:</p> <pre><code>let mut options = ConfigOptions::default();\noptions.base_path = Some(\"/etc/myapp/config\".into());\n\n// ${file:secrets.yaml} resolves to /etc/myapp/config/secrets.yaml\nlet config = Config::from_yaml_with_options(yaml, options)?;\n</code></pre>"},{"location":"api/rust/structs/config-options/#usage-with-config","title":"Usage with Config","text":"<pre><code>use holoconf_core::{Config, ConfigOptions};\n\n// Create custom options\nlet mut options = ConfigOptions::default();\noptions.allow_http = true;\noptions.env_prefix = Some(\"MYAPP_\".to_string());\n\n// Load with options\nlet config = Config::from_yaml_with_options(yaml_content, options)?;\n\n// Or from file\nlet config = Config::from_yaml_file_with_options(\"config.yaml\", options)?;\n</code></pre>"},{"location":"api/rust/structs/config-options/#api-reference","title":"API Reference","text":"<p>\ud83d\udcda Full rustdoc on docs.rs</p>"},{"location":"api/rust/structs/config/","title":"Config","text":"<p>The main configuration container with lazy resolution.</p>"},{"location":"api/rust/structs/config/#overview","title":"Overview","text":"<p><code>Config</code> is the primary type for loading and accessing configuration values. It supports:</p> <ul> <li>Loading from YAML and JSON files or strings</li> <li>Merging multiple configuration sources</li> <li>Lazy resolution of interpolations (cached for performance)</li> <li>Thread-safe access (<code>Send + Sync</code>)</li> </ul>"},{"location":"api/rust/structs/config/#creating-a-config","title":"Creating a Config","text":""},{"location":"api/rust/structs/config/#from-files","title":"From Files","text":"<pre><code>use holoconf_core::Config;\n\n// From a single file\nlet config = Config::from_yaml_file(\"config.yaml\")?;\nlet config = Config::from_json_file(\"config.json\")?;\n\n// Merge multiple files (later files override earlier)\nlet config = Config::load_merged(&amp;[\"base.yaml\", \"production.yaml\"])?;\n</code></pre>"},{"location":"api/rust/structs/config/#from-strings","title":"From Strings","text":"<pre><code>use holoconf_core::Config;\n\nlet yaml = r#\"\ndatabase:\n  host: localhost\n  port: 5432\n\"#;\n\nlet config = Config::from_yaml(yaml)?;\n\nlet json = r#\"{\"database\": {\"host\": \"localhost\"}}\"#;\nlet config = Config::from_json(json)?;\n</code></pre>"},{"location":"api/rust/structs/config/#with-options","title":"With Options","text":"<pre><code>use holoconf_core::{Config, ConfigOptions};\n\nlet mut options = ConfigOptions::default();\noptions.allow_http = true;  // Enable HTTP resolver\n\nlet config = Config::from_yaml_with_options(yaml_str, options)?;\n</code></pre>"},{"location":"api/rust/structs/config/#accessing-values","title":"Accessing Values","text":""},{"location":"api/rust/structs/config/#typed-getters","title":"Typed Getters","text":"<pre><code>// String values\nlet host: String = config.get_string(\"database.host\")?;\n\n// Numeric values\nlet port: i64 = config.get_i64(\"database.port\")?;\nlet timeout: f64 = config.get_f64(\"server.timeout\")?;\n\n// Boolean values\nlet enabled: bool = config.get_bool(\"feature.enabled\")?;\n</code></pre>"},{"location":"api/rust/structs/config/#raw-values","title":"Raw Values","text":"<p>Access values before type conversion:</p> <pre><code>use holoconf_core::Value;\n\nlet value = config.get_raw(\"some.path\")?;\n\nmatch value {\n    Value::String(s) =&gt; println!(\"string: {}\", s),\n    Value::Integer(i) =&gt; println!(\"int: {}\", i),\n    Value::Sequence(arr) =&gt; println!(\"array: {} items\", arr.len()),\n    Value::Mapping(map) =&gt; println!(\"map: {} keys\", map.len()),\n    _ =&gt; {}\n}\n</code></pre>"},{"location":"api/rust/structs/config/#nested-paths","title":"Nested Paths","text":"<p>Use dot notation to access nested values:</p> <pre><code>// config.yaml:\n// database:\n//   connection:\n//     host: localhost\n\nlet host = config.get_string(\"database.connection.host\")?;\n</code></pre>"},{"location":"api/rust/structs/config/#merging-configurations","title":"Merging Configurations","text":"<pre><code>use holoconf_core::Config;\n\n// Merge at load time\nlet config = Config::load_merged(&amp;[\"base.yaml\", \"env.yaml\", \"local.yaml\"])?;\n\n// Or merge programmatically\nlet base = Config::from_yaml_file(\"base.yaml\")?;\nlet overlay = Config::from_yaml_file(\"production.yaml\")?;\nlet merged = base.merge(&amp;overlay)?;\n</code></pre>"},{"location":"api/rust/structs/config/#validation","title":"Validation","text":"<pre><code>use holoconf_core::{Config, Schema};\n\nlet config = Config::from_yaml_file(\"config.yaml\")?;\nlet schema = Schema::from_file(\"schema.json\")?;\n\n// Validate resolved values\nconfig.validate(&amp;schema)?;\n\n// Validate raw structure (before resolution)\nconfig.validate_raw(&amp;schema)?;\n</code></pre>"},{"location":"api/rust/structs/config/#thread-safety","title":"Thread Safety","text":"<p><code>Config</code> is <code>Send + Sync</code> with interior mutability for the resolution cache:</p> <pre><code>use holoconf_core::Config;\nuse std::sync::Arc;\nuse std::thread;\n\nlet config = Arc::new(Config::from_yaml_file(\"config.yaml\")?);\n\nlet handles: Vec&lt;_&gt; = (0..4).map(|_| {\n    let config = Arc::clone(&amp;config);\n    thread::spawn(move || {\n        let host = config.get_string(\"database.host\").unwrap();\n        println!(\"Host: {}\", host);\n    })\n}).collect();\n\nfor handle in handles {\n    handle.join().unwrap();\n}\n</code></pre>"},{"location":"api/rust/structs/config/#api-reference","title":"API Reference","text":"<p>\ud83d\udcda Full rustdoc on docs.rs</p>"},{"location":"api/rust/structs/schema/","title":"Schema","text":"<p>JSON Schema validation for configuration files.</p>"},{"location":"api/rust/structs/schema/#overview","title":"Overview","text":"<p><code>Schema</code> provides validation against JSON Schema specifications. Use it to:</p> <ul> <li>Ensure configuration structure matches expectations</li> <li>Validate data types and constraints</li> <li>Provide helpful error messages for invalid configurations</li> </ul>"},{"location":"api/rust/structs/schema/#creating-a-schema","title":"Creating a Schema","text":""},{"location":"api/rust/structs/schema/#from-files","title":"From Files","text":"<pre><code>use holoconf_core::Schema;\n\n// From JSON Schema file\nlet schema = Schema::from_file(\"schema.json\")?;\n</code></pre>"},{"location":"api/rust/structs/schema/#from-strings","title":"From Strings","text":"<pre><code>use holoconf_core::Schema;\n\nlet schema_json = r#\"{\n    \"type\": \"object\",\n    \"properties\": {\n        \"database\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"host\": { \"type\": \"string\" },\n                \"port\": { \"type\": \"integer\", \"minimum\": 1, \"maximum\": 65535 }\n            },\n            \"required\": [\"host\"]\n        }\n    }\n}\"#;\n\nlet schema = Schema::from_json(schema_json)?;\n\n// Also supports YAML schemas\nlet schema = Schema::from_yaml(yaml_str)?;\n</code></pre>"},{"location":"api/rust/structs/schema/#validating-configuration","title":"Validating Configuration","text":""},{"location":"api/rust/structs/schema/#validate-resolved-values","title":"Validate Resolved Values","text":"<pre><code>use holoconf_core::{Config, Schema};\n\nlet config = Config::from_yaml_file(\"config.yaml\")?;\nlet schema = Schema::from_file(\"schema.json\")?;\n\n// Validates after resolving all interpolations\nmatch config.validate(&amp;schema) {\n    Ok(()) =&gt; println!(\"Configuration is valid\"),\n    Err(e) =&gt; eprintln!(\"Validation failed: {}\", e),\n}\n</code></pre>"},{"location":"api/rust/structs/schema/#validate-raw-structure","title":"Validate Raw Structure","text":"<pre><code>// Validates structure without resolving interpolations\n// Useful for checking config shape before deployment\nconfig.validate_raw(&amp;schema)?;\n</code></pre>"},{"location":"api/rust/structs/schema/#example-schema","title":"Example Schema","text":"<pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"type\": \"object\",\n    \"required\": [\"app\", \"database\"],\n    \"properties\": {\n        \"app\": {\n            \"type\": \"object\",\n            \"required\": [\"name\"],\n            \"properties\": {\n                \"name\": {\n                    \"type\": \"string\",\n                    \"minLength\": 1\n                },\n                \"debug\": {\n                    \"type\": \"boolean\",\n                    \"default\": false\n                }\n            }\n        },\n        \"database\": {\n            \"type\": \"object\",\n            \"required\": [\"host\", \"port\"],\n            \"properties\": {\n                \"host\": { \"type\": \"string\" },\n                \"port\": {\n                    \"type\": \"integer\",\n                    \"minimum\": 1,\n                    \"maximum\": 65535\n                },\n                \"ssl\": {\n                    \"type\": \"boolean\",\n                    \"default\": true\n                }\n            }\n        }\n    },\n    \"additionalProperties\": false\n}\n</code></pre>"},{"location":"api/rust/structs/schema/#error-messages","title":"Error Messages","text":"<p>Validation errors include the path to the invalid value:</p> <pre><code>match config.validate(&amp;schema) {\n    Err(e) =&gt; {\n        // e.g., \"database.port: -1 is less than the minimum of 1\"\n        eprintln!(\"{}\", e);\n    }\n    Ok(()) =&gt; {}\n}\n</code></pre>"},{"location":"api/rust/structs/schema/#api-reference","title":"API Reference","text":"<p>\ud83d\udcda Full rustdoc on docs.rs</p>"},{"location":"contributing/","title":"Contributing to HoloConf","text":"<p>Thank you for your interest in contributing to HoloConf! This section provides guidelines for contributors.</p>"},{"location":"contributing/#quick-links","title":"Quick Links","text":"<ul> <li>Development Setup - Get your environment ready</li> <li>Testing - Testing guidelines and acceptance tests</li> <li>Architecture Decisions - ADRs documenting design decisions</li> <li>Feature Specs - Detailed feature specifications</li> </ul>"},{"location":"contributing/#ways-to-contribute","title":"Ways to Contribute","text":""},{"location":"contributing/#bug-reports","title":"Bug Reports","text":"<p>Found a bug? Open an issue with:</p> <ul> <li>A clear description of the problem</li> <li>Steps to reproduce</li> <li>Expected vs actual behavior</li> <li>Your environment (OS, Python/Rust version, HoloConf version)</li> </ul>"},{"location":"contributing/#feature-requests","title":"Feature Requests","text":"<p>Have an idea? Open an issue describing:</p> <ul> <li>The use case or problem you're trying to solve</li> <li>Your proposed solution</li> <li>Any alternatives you've considered</li> </ul>"},{"location":"contributing/#code-contributions","title":"Code Contributions","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch</li> <li>Make your changes (with tests!)</li> <li>Submit a pull request</li> </ol> <p>See Development Setup for detailed instructions.</p>"},{"location":"contributing/#project-structure","title":"Project Structure","text":"<pre><code>holoconf/\n\u251c\u2500\u2500 crates/\n\u2502   \u251c\u2500\u2500 holoconf-core/      # Rust core library\n\u2502   \u251c\u2500\u2500 holoconf-python/    # PyO3 Python bindings\n\u2502   \u2514\u2500\u2500 holoconf-cli/       # Rust CLI binary\n\u251c\u2500\u2500 packages/\n\u2502   \u2514\u2500\u2500 python/holoconf/    # Python package\n\u251c\u2500\u2500 tests/\n\u2502   \u2514\u2500\u2500 acceptance/         # Cross-language acceptance tests\n\u251c\u2500\u2500 docs/\n\u2502   \u251c\u2500\u2500 adr/                # Architecture Decision Records\n\u2502   \u2514\u2500\u2500 specs/              # Feature specifications\n\u2514\u2500\u2500 tools/\n    \u2514\u2500\u2500 test_runner.py      # Acceptance test runner\n</code></pre>"},{"location":"contributing/#decision-making","title":"Decision Making","text":"<p>Significant decisions are documented as Architecture Decision Records (ADRs). Before proposing major changes, review existing ADRs and consider whether your change requires a new one.</p> <p>See Architecture Decisions for the full list.</p>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<ul> <li>Be respectful and inclusive</li> <li>Provide constructive feedback</li> <li>Focus on the code, not the person</li> <li>Help others learn and grow</li> </ul>"},{"location":"contributing/acceptance-tests/","title":"Acceptance Tests","text":"<p>Acceptance tests validate end-to-end behavior across all language bindings. They ensure that HoloConf behaves consistently whether you're using Rust, Python, or any other supported language.</p> <p>Run acceptance tests</p> <p>Run <code>make test-acceptance</code> to run all acceptance tests, or <code>make test-acceptance-json</code> to generate the results matrix.</p>"},{"location":"contributing/acceptance-tests/#test-matrix","title":"Test Matrix","text":"<p>The matrix below shows which tests pass for each driver:</p> <p>Acceptance test results not available</p> <p>Run <code>make test-acceptance</code> to generate test results.</p>"},{"location":"contributing/acceptance-tests/#running-acceptance-tests","title":"Running Acceptance Tests","text":""},{"location":"contributing/acceptance-tests/#all-tests","title":"All Tests","text":"<pre><code>make test-acceptance\n</code></pre>"},{"location":"contributing/acceptance-tests/#by-driver","title":"By Driver","text":"<pre><code># Run with Rust driver\npython tools/test_runner.py --driver rust 'tests/acceptance/**/*.yaml' -v\n\n# Run with Python driver\npython tools/test_runner.py --driver python 'tests/acceptance/**/*.yaml' -v\n</code></pre>"},{"location":"contributing/acceptance-tests/#specific-test-file","title":"Specific Test File","text":"<pre><code>python tools/test_runner.py --driver python tests/acceptance/resolvers/env.yaml -v\n</code></pre>"},{"location":"contributing/acceptance-tests/#test-organization","title":"Test Organization","text":"<p>Acceptance tests are organized by feature area:</p> <pre><code>tests/acceptance/\n\u251c\u2500\u2500 api/                  # API behavior tests\n\u251c\u2500\u2500 interpolation/        # Interpolation syntax tests\n\u251c\u2500\u2500 merging/              # Config merging tests\n\u251c\u2500\u2500 resolvers/            # Resolver tests\n\u2502   \u251c\u2500\u2500 env.yaml          # Environment resolver\n\u2502   \u251c\u2500\u2500 file.yaml         # File resolver\n\u2502   \u2514\u2500\u2500 self-ref.yaml     # Self-reference resolver\n\u251c\u2500\u2500 schema/               # Schema validation tests\n\u2514\u2500\u2500 serialization/        # Export/dump tests\n</code></pre>"},{"location":"contributing/acceptance-tests/#test-format","title":"Test Format","text":"<p>Acceptance tests are defined in YAML and run against all language bindings. This ensures consistent behavior across languages.</p>"},{"location":"contributing/acceptance-tests/#basic-structure","title":"Basic Structure","text":"<pre><code>name: \"Feature name\"\ndescription: \"What this test file covers\"\n\ntests:\n  - name: \"Test case description\"\n    config:\n      key: value\n      nested:\n        path: \"${env:HOME}\"\n    assertions:\n      - path: \"key\"\n        expected: \"value\"\n</code></pre>"},{"location":"contributing/acceptance-tests/#assertions","title":"Assertions","text":"<pre><code>assertions:\n  # Exact value match\n  - path: \"database.port\"\n    expected: 5432\n\n  # Pattern match (regex)\n  - path: \"app.version\"\n    expected_pattern: \"^\\\\d+\\\\.\\\\d+\\\\.\\\\d+$\"\n\n  # Type check\n  - path: \"app.debug\"\n    expected_type: \"boolean\"\n\n  # Error expectation\n  - path: \"missing.key\"\n    expected_error: \"PathNotFoundError\"\n</code></pre>"},{"location":"contributing/acceptance-tests/#environment-setup","title":"Environment Setup","text":"<pre><code>tests:\n  - name: \"Environment variable resolution\"\n    env:\n      DATABASE_URL: \"postgres://localhost/test\"\n    config:\n      db_url: \"${env:DATABASE_URL}\"\n    assertions:\n      - path: \"db_url\"\n        expected: \"postgres://localhost/test\"\n</code></pre>"},{"location":"contributing/acceptance-tests/#file-fixtures","title":"File Fixtures","text":"<pre><code>tests:\n  - name: \"File include\"\n    files:\n      secrets.yaml: |\n        api_key: \"secret123\"\n    config:\n      secrets: \"${file:secrets.yaml}\"\n    assertions:\n      - path: \"secrets.api_key\"\n        expected: \"secret123\"\n</code></pre>"},{"location":"contributing/acceptance-tests/#adding-new-tests","title":"Adding New Tests","text":"<ol> <li>Create a YAML file in the appropriate <code>tests/acceptance/</code> subdirectory</li> <li>Define test cases with config and assertions</li> <li>Run against all drivers to verify consistent behavior:</li> </ol> <pre><code>python tools/test_runner.py --driver rust tests/acceptance/your-test.yaml -v\npython tools/test_runner.py --driver python tests/acceptance/your-test.yaml -v\n</code></pre>"},{"location":"contributing/acceptance-tests/#see-also","title":"See Also","text":"<ul> <li>Testing - Full testing guide including coverage goals</li> <li>ADR-013 Testing Architecture - Design rationale</li> </ul>"},{"location":"contributing/development/","title":"Development Setup","text":"<p>This guide helps you set up a development environment for HoloConf.</p>"},{"location":"contributing/development/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust 1.88 or later (rustup.rs)</li> <li>Python 3.8 or later</li> <li>maturin for building Python bindings</li> </ul>"},{"location":"contributing/development/#quick-setup","title":"Quick Setup","text":"<pre><code># Clone the repository\ngit clone https://github.com/rfestag/holoconf.git\ncd holoconf\n\n# Set up Python virtual environment\npython -m venv .venv\nsource .venv/bin/activate  # Windows: .venv\\Scripts\\activate\n\n# Install development tools\nmake install-tools\n\n# Build everything\nmake build\n\n# Run all tests\nmake test\n</code></pre>"},{"location":"contributing/development/#step-by-step-setup","title":"Step-by-Step Setup","text":""},{"location":"contributing/development/#1-clone-and-enter-the-repository","title":"1. Clone and Enter the Repository","text":"<pre><code>git clone https://github.com/rfestag/holoconf.git\ncd holoconf\n</code></pre>"},{"location":"contributing/development/#2-set-up-python-environment","title":"2. Set Up Python Environment","text":"<pre><code>python -m venv .venv\nsource .venv/bin/activate\n</code></pre>"},{"location":"contributing/development/#3-install-development-dependencies","title":"3. Install Development Dependencies","text":"<pre><code># Install Rust tooling\ncargo install cargo-deny cargo-audit cargo-machete\n\n# Install Python dev dependencies\ncd packages/python/holoconf\npip install -e \".[dev]\"\ncd ../../..\n</code></pre>"},{"location":"contributing/development/#4-build-the-project","title":"4. Build the Project","text":"<pre><code># Build Rust crates\ncargo build\n\n# Build Python bindings (development mode)\ncd packages/python/holoconf\nmaturin develop\ncd ../../..\n</code></pre>"},{"location":"contributing/development/#5-verify-setup","title":"5. Verify Setup","text":"<pre><code># Run Rust tests\ncargo test\n\n# Run Python tests\ncd packages/python/holoconf\npytest tests/ -v\ncd ../../..\n\n# Run acceptance tests\npython tools/test_runner.py --driver python 'tests/acceptance/**/*.yaml' -v\n</code></pre>"},{"location":"contributing/development/#available-make-targets","title":"Available Make Targets","text":"Target Description <code>make help</code> Show all available targets <code>make build</code> Build Rust crates and Python bindings <code>make test</code> Run all tests (Rust, Python, acceptance) <code>make lint</code> Run all linters <code>make format</code> Format all code <code>make check</code> Run lint + security + test <code>make clean</code> Clean build artifacts"},{"location":"contributing/development/#code-style","title":"Code Style","text":""},{"location":"contributing/development/#rust","title":"Rust","text":"<pre><code># Format code\ncargo fmt\n\n# Run linter\ncargo clippy -- -D warnings\n</code></pre> <p>Follow Rust conventions: - <code>snake_case</code> for functions and variables - <code>CamelCase</code> for types - <code>SCREAMING_SNAKE_CASE</code> for constants</p>"},{"location":"contributing/development/#python","title":"Python","text":"<pre><code># Format and lint\ncd packages/python/holoconf\nruff format src/ tests/\nruff check src/ tests/\n</code></pre> <p>Follow PEP 8 guidelines with type hints.</p>"},{"location":"contributing/development/#pull-request-workflow","title":"Pull Request Workflow","text":"<ol> <li> <p>Create a feature branch: <pre><code>git checkout -b feature/your-feature-name\n</code></pre></p> </li> <li> <p>Make changes with tests and documentation</p> </li> <li> <p>Run checks locally: <pre><code>make check\n</code></pre></p> </li> <li> <p>Commit with clear messages: <pre><code>git commit -m \"feat: add support for X\"\n</code></pre></p> </li> <li> <p>Push and open PR: <pre><code>git push origin feature/your-feature-name\n</code></pre></p> </li> </ol>"},{"location":"contributing/development/#creating-an-adr","title":"Creating an ADR","text":"<p>For architectural decisions, create an ADR:</p> <pre><code>cp docs/adr/template.md docs/adr/ADR-XXX-your-decision.md\n</code></pre> <p>Fill out the template and submit with your PR. See Architecture Decisions for examples.</p>"},{"location":"contributing/development/#creating-a-feature-spec","title":"Creating a Feature Spec","text":"<p>For new features, create a specification:</p> <pre><code>cp docs/specs/features/template.md docs/specs/features/FEAT-XXX-feature-name.md\n</code></pre> <p>See Feature Specs for examples.</p>"},{"location":"contributing/testing/","title":"Testing","text":"<p>HoloConf uses a multi-layered testing strategy to ensure correctness across all language bindings.</p>"},{"location":"contributing/testing/#test-layers","title":"Test Layers","text":"Layer Purpose Location Unit tests Test individual components <code>crates/*/src/</code>, <code>packages/*/tests/</code> Acceptance tests Cross-language behavior verification <code>tests/acceptance/</code> Integration tests End-to-end scenarios <code>tests/integration/</code>"},{"location":"contributing/testing/#running-tests","title":"Running Tests","text":""},{"location":"contributing/testing/#all-tests","title":"All Tests","text":"<pre><code>make test\n</code></pre>"},{"location":"contributing/testing/#rust-unit-tests","title":"Rust Unit Tests","text":"<pre><code>cargo test --all\n</code></pre>"},{"location":"contributing/testing/#python-unit-tests","title":"Python Unit Tests","text":"<pre><code>cd packages/python/holoconf\npytest tests/ -v\n</code></pre>"},{"location":"contributing/testing/#acceptance-tests","title":"Acceptance Tests","text":"<pre><code># Run with Rust driver\npython tools/test_runner.py --driver rust 'tests/acceptance/**/*.yaml' -v\n\n# Run with Python driver\npython tools/test_runner.py --driver python 'tests/acceptance/**/*.yaml' -v\n\n# Run a specific test file\npython tools/test_runner.py --driver python tests/acceptance/resolvers/env.yaml -v\n</code></pre> <p>See Acceptance Tests for test format details and the full test matrix.</p>"},{"location":"contributing/testing/#writing-good-tests","title":"Writing Good Tests","text":""},{"location":"contributing/testing/#do","title":"Do","text":"<ul> <li>Test one behavior per test case</li> <li>Use descriptive test names</li> <li>Cover both success and error cases</li> <li>Test edge cases and boundaries</li> <li>Keep test data minimal but realistic</li> </ul>"},{"location":"contributing/testing/#dont","title":"Don't","text":"<ul> <li>Don't test implementation details</li> <li>Don't rely on external services</li> <li>Don't use random/time-dependent data</li> <li>Don't write overly complex test configs</li> </ul>"},{"location":"contributing/testing/#debugging-tests","title":"Debugging Tests","text":""},{"location":"contributing/testing/#verbose-output","title":"Verbose Output","text":"<pre><code>python tools/test_runner.py --driver python -vv tests/acceptance/...\n</code></pre>"},{"location":"contributing/testing/#run-single-test","title":"Run Single Test","text":"<pre><code>python tools/test_runner.py --driver python --test \"specific test name\" tests/acceptance/...\n</code></pre>"},{"location":"contributing/testing/#debug-in-python","title":"Debug in Python","text":"<pre><code>from holoconf import Config\n\nconfig = Config.from_string(\"\"\"\ndatabase:\n  host: ${env:DB_HOST,default=localhost}\n\"\"\")\n\n# Inspect values\nprint(config.dump(resolve=True))\n</code></pre>"},{"location":"contributing/testing/#code-coverage","title":"Code Coverage","text":""},{"location":"contributing/testing/#coverage-goals","title":"Coverage Goals","text":"Package Target Notes holoconf-core (Rust) 80% Core logic, all public APIs holoconf (Python) 80% Bindings and Python-specific code holoconf-cli 70% CLI commands and argument handling"},{"location":"contributing/testing/#generating-coverage-reports","title":"Generating Coverage Reports","text":""},{"location":"contributing/testing/#rust-coverage","title":"Rust Coverage","text":"<pre><code># Generate HTML coverage report\nmake coverage-rust\n\n# View report\nopen target/llvm-cov/html/index.html\n</code></pre> <p>Requires <code>cargo-llvm-cov</code>: <pre><code>cargo install cargo-llvm-cov\n</code></pre></p>"},{"location":"contributing/testing/#python-coverage","title":"Python Coverage","text":"<pre><code>cd packages/python/holoconf\npytest --cov=holoconf --cov-report=html tests/\nopen htmlcov/index.html\n</code></pre>"},{"location":"contributing/testing/#full-coverage-rust-python-acceptance","title":"Full Coverage (Rust + Python + Acceptance)","text":"<pre><code>make coverage-full\n</code></pre> <p>This generates a combined report covering:</p> <ul> <li>Rust unit tests</li> <li>Python unit tests</li> <li>Acceptance tests run through both drivers</li> </ul>"},{"location":"contributing/testing/#coverage-in-ci","title":"Coverage in CI","text":"<p>Coverage reports are automatically generated on pull requests. The CI will:</p> <ol> <li>Run all test suites with coverage instrumentation</li> <li>Generate combined coverage reports</li> <li>Post coverage summary as a PR comment</li> <li>Fail if coverage drops below thresholds</li> </ol>"},{"location":"contributing/testing/#see-also","title":"See Also","text":"<ul> <li>Acceptance Tests - Cross-language acceptance test details</li> <li>ADR-013 Testing Architecture - Design rationale for the testing approach</li> </ul>"},{"location":"guide/getting-started/","title":"Getting Started","text":"<p>This guide walks you through installing HoloConf and creating your first configuration.</p>"},{"location":"guide/getting-started/#installation","title":"Installation","text":"PythonRustCLI <pre><code>pip install holoconf\n</code></pre> <p>Requires Python 3.8 or later.</p> <p>Add to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nholoconf = \"0.1\"\n</code></pre> <p>The CLI is included with the Python package:</p> <pre><code>pip install holoconf\nholoconf --help\n</code></pre> <p>Or install the standalone Rust binary:</p> <pre><code>cargo install holoconf-cli\n</code></pre>"},{"location":"guide/getting-started/#your-first-configuration","title":"Your First Configuration","text":"<p>Create a file named <code>config.yaml</code>:</p> <pre><code>app:\n  name: my-application\n  debug: false\n\ndatabase:\n  host: ${env:DB_HOST,default=localhost}\n  port: ${env:DB_PORT,default=5432}\n  name: ${env:DB_NAME,default=myapp}\n\nlogging:\n  level: ${env:LOG_LEVEL,default=info}\n  format: json\n</code></pre> <p>This configuration demonstrates several HoloConf features:</p> <ul> <li>Nested structure - Values organized hierarchically</li> <li>Environment variables - <code>${env:VAR_NAME}</code> resolves to environment variable values</li> <li>Default values - <code>${env:VAR_NAME,default=value}</code> provides fallbacks when variables aren't set</li> </ul>"},{"location":"guide/getting-started/#loading-configuration","title":"Loading Configuration","text":"PythonRustCLI <pre><code>from holoconf import Config\n\n# Load from file\nconfig = Config.from_file(\"config.yaml\")\n\n# Access values using dot notation\napp_name = config.get(\"app.name\")\ndb_host = config.get(\"database.host\")\n\nprint(f\"App: {app_name}\")\nprint(f\"Database: {db_host}\")\n</code></pre> <pre><code>use holoconf::Config;\n\nfn main() -&gt; Result&lt;(), holoconf::Error&gt; {\n    // Load from file\n    let config = Config::from_file(\"config.yaml\")?;\n\n    // Access values using dot notation\n    let app_name: String = config.get(\"app.name\")?;\n    let db_host: String = config.get(\"database.host\")?;\n\n    println!(\"App: {}\", app_name);\n    println!(\"Database: {}\", db_host);\n\n    Ok(())\n}\n</code></pre> <pre><code># Get a specific value\n$ holoconf get config.yaml app.name\nmy-application\n\n# Get database host (resolves environment variable)\n$ DB_HOST=prod-db.example.com holoconf get config.yaml database.host\nprod-db.example.com\n\n# Dump entire resolved configuration\n$ holoconf dump config.yaml --resolve\napp:\n  name: my-application\n  debug: false\ndatabase:\n  host: localhost\n  port: \"5432\"\n  name: myapp\nlogging:\n  level: info\n  format: json\n</code></pre>"},{"location":"guide/getting-started/#working-with-nested-values","title":"Working with Nested Values","text":"<p>HoloConf supports deep nesting and provides convenient access patterns:</p> PythonRust <pre><code>from holoconf import Config\n\nconfig = Config.from_file(\"config.yaml\")\n\n# Get nested values with dot notation\nlog_level = config.get(\"logging.level\")\n\n# Get a subsection as a dict\ndb_config = config.get(\"database\")\nprint(db_config)\n# {'host': 'localhost', 'port': '5432', 'name': 'myapp'}\n\n# Check if a path exists\nif config.get(\"app.debug\"):\n    print(\"Debug mode enabled\")\n</code></pre> <pre><code>use holoconf::Config;\n\nfn main() -&gt; Result&lt;(), holoconf::Error&gt; {\n    let config = Config::from_file(\"config.yaml\")?;\n\n    // Get nested values with dot notation\n    let log_level: String = config.get(\"logging.level\")?;\n\n    // Get a subsection\n    let db_config = config.get_section(\"database\")?;\n\n    // Check if a path exists\n    if config.get::&lt;bool&gt;(\"app.debug\")? {\n        println!(\"Debug mode enabled\");\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"guide/getting-started/#error-handling","title":"Error Handling","text":"<p>HoloConf provides descriptive errors to help you debug configuration issues:</p> PythonRust <pre><code>from holoconf import Config, PathNotFoundError, ResolverError\n\nconfig = Config.from_file(\"config.yaml\")\n\ntry:\n    value = config.get(\"nonexistent.path\")\nexcept PathNotFoundError as e:\n    print(f\"Path not found: {e}\")\n\ntry:\n    # If REQUIRED_VAR is not set and has no default\n    value = config.get(\"some.required.value\")\nexcept ResolverError as e:\n    print(f\"Failed to resolve: {e}\")\n</code></pre> <pre><code>use holoconf::{Config, Error};\n\nfn main() {\n    let config = Config::from_file(\"config.yaml\").unwrap();\n\n    match config.get::&lt;String&gt;(\"nonexistent.path\") {\n        Ok(value) =&gt; println!(\"Value: {}\", value),\n        Err(Error::PathNotFound { path, .. }) =&gt; {\n            println!(\"Path not found: {}\", path);\n        }\n        Err(e) =&gt; println!(\"Other error: {}\", e),\n    }\n}\n</code></pre>"},{"location":"guide/getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you have the basics, explore these topics:</p> <ul> <li>Interpolation - Variable substitution syntax and escaping</li> <li>Resolvers - Environment, file, HTTP, and self-reference resolvers</li> <li>Merging - Combine multiple configuration files</li> <li>Validation - Validate configuration with JSON Schema</li> </ul>"},{"location":"guide/interpolation/","title":"Interpolation","text":""},{"location":"guide/interpolation/#overview","title":"Overview","text":"<p>HoloConf supports interpolation syntax to dynamically resolve values at access time. The general syntax is:</p> <pre><code>${resolver:argument}\n${resolver:argument,default=value}\n${resolver:argument,sensitive=true}\n</code></pre>"},{"location":"guide/interpolation/#quick-reference","title":"Quick Reference","text":"Syntax Description Example <code>${env:VAR}</code> Environment variable <code>${env:DATABASE_URL}</code> <code>${env:VAR,default=value}</code> Environment variable with default <code>${env:PORT,default=8080}</code> <code>${env:VAR,sensitive=true}</code> Mark as sensitive (redacted in output) <code>${env:API_KEY,sensitive=true}</code> <code>${path.to.value}</code> Self-reference (absolute) <code>${database.host}</code> <code>${.sibling}</code> Self-reference (relative) <code>${.port}</code> <code>${..parent.value}</code> Self-reference (parent) <code>${..shared.timeout}</code> <code>${file:path}</code> Include file content <code>${file:./secrets.yaml}</code> <code>${http:url}</code> Fetch from HTTP endpoint <code>${http:https://config.example.com/settings}</code>"},{"location":"guide/interpolation/#keyword-arguments","title":"Keyword Arguments","text":"<p>All resolvers support two framework-level keyword arguments:</p> <ul> <li><code>default=value</code> - Fallback value if the resolver fails (e.g., env var not set, file not found)</li> <li><code>sensitive=true</code> - Mark value as sensitive for redaction in output</li> </ul> <p>These can be combined:</p> <pre><code>api_key: ${env:API_KEY,default=dev-key,sensitive=true}\n</code></pre> <p>Lazy Default Resolution</p> <p>Default values are resolved lazily - if the primary resolver succeeds, the default is never evaluated. This allows defaults to contain other resolvers without causing errors.</p>"},{"location":"guide/interpolation/#examples","title":"Examples","text":""},{"location":"guide/interpolation/#environment-variables","title":"Environment Variables","text":"PythonRust <pre><code># config.yaml:\n# database:\n#   url: ${env:DATABASE_URL,default=postgres://localhost/mydb}\n\nfrom holoconf import Config\nimport os\n\nos.environ[\"DATABASE_URL\"] = \"postgres://prod-server/mydb\"\nconfig = Config.from_file(\"config.yaml\")\n\nurl = config.get(\"database.url\")\n# Returns: \"postgres://prod-server/mydb\"\n</code></pre> <pre><code>use holoconf::Config;\nuse std::env;\n\nfn main() -&gt; Result&lt;(), holoconf::Error&gt; {\n    env::set_var(\"DATABASE_URL\", \"postgres://prod-server/mydb\");\n    let config = Config::from_file(\"config.yaml\")?;\n\n    let url: String = config.get(\"database.url\")?;\n    // Returns: \"postgres://prod-server/mydb\"\n\n    Ok(())\n}\n</code></pre>"},{"location":"guide/interpolation/#self-references","title":"Self-References","text":"<pre><code>defaults:\n  timeout: 30\n  retries: 3\n\ndatabase:\n  timeout: ${defaults.timeout}\n  connection_retries: ${defaults.retries}\n\ncache:\n  timeout: ${defaults.timeout}\n</code></pre>"},{"location":"guide/interpolation/#sensitive-values","title":"Sensitive Values","text":"<p>Mark values as sensitive to automatically redact them in dumps:</p> <pre><code>database:\n  host: ${env:DB_HOST,default=localhost}\n  password: ${env:DB_PASSWORD,sensitive=true}\n</code></pre> <p>When dumping with redaction:</p> <pre><code>config = Config.from_file(\"config.yaml\")\nprint(config.to_yaml(redact=True))\n# database:\n#   host: localhost\n#   password: '[REDACTED]'\n</code></pre>"},{"location":"guide/interpolation/#nested-defaults","title":"Nested Defaults","text":"<p>Default values can contain other resolvers:</p> <pre><code># Falls back to FALLBACK_VAR if PRIMARY_VAR is not set\nvalue: ${env:PRIMARY_VAR,default=${env:FALLBACK_VAR,default=final-fallback}}\n</code></pre>"},{"location":"guide/interpolation/#escaping","title":"Escaping","text":"<p>To include a literal <code>${</code> in your configuration, escape it with a backslash:</p> <pre><code>template: \"Hello \\${name}\"  # Literal ${name}, not interpolated\n</code></pre>"},{"location":"guide/interpolation/#see-also","title":"See Also","text":"<ul> <li>ADR-011 Interpolation Syntax - Technical details and design rationale</li> <li>Resolvers - Detailed resolver documentation</li> </ul>"},{"location":"guide/merging/","title":"Configuration Merging","text":"<p>Coming Soon</p> <p>This page is under construction. See FEAT-003 Config Merging for the full specification.</p>"},{"location":"guide/merging/#overview","title":"Overview","text":"<p>HoloConf allows you to merge multiple configuration files, enabling patterns like:</p> <ul> <li>Base configuration with environment-specific overrides</li> <li>Shared defaults with local customizations</li> <li>Modular configuration split across multiple files</li> </ul>"},{"location":"guide/merging/#basic-merging","title":"Basic Merging","text":"PythonRust <pre><code>from holoconf import Config\n\n# Load base configuration, then merge overrides\nbase = Config.load(\"config/base.yaml\")\nproduction = Config.load(\"config/production.yaml\")\nbase.merge(production)\n\n# Now 'base' contains the merged result\n</code></pre> <pre><code>use holoconf::Config;\n\nfn main() -&gt; Result&lt;(), holoconf::Error&gt; {\n    let mut config = Config::load(\"config/base.yaml\")?;\n    let production = Config::load(\"config/production.yaml\")?;\n    config.merge(production);\n\n    Ok(())\n}\n</code></pre>"},{"location":"guide/merging/#merge-behavior","title":"Merge Behavior","text":"<p>When merging configurations:</p> Type Behavior Scalars (string, int, bool) Later value replaces earlier Objects/Maps Deep merge (keys are merged recursively) Arrays Later array replaces earlier (no concatenation)"},{"location":"guide/merging/#example","title":"Example","text":"<pre><code># base.yaml\ndatabase:\n  host: localhost\n  port: 5432\n  pool_size: 10\n\nlogging:\n  level: info\n</code></pre> <pre><code># production.yaml\ndatabase:\n  host: prod-db.example.com\n  pool_size: 50\n\nlogging:\n  level: warning\n</code></pre> <p>Result after merging:</p> <pre><code>database:\n  host: prod-db.example.com  # overridden\n  port: 5432                  # from base\n  pool_size: 50               # overridden\n\nlogging:\n  level: warning              # overridden\n</code></pre>"},{"location":"guide/merging/#common-patterns","title":"Common Patterns","text":""},{"location":"guide/merging/#environment-based-configuration","title":"Environment-based Configuration","text":"<pre><code>config/\n\u251c\u2500\u2500 base.yaml\n\u251c\u2500\u2500 development.yaml\n\u251c\u2500\u2500 staging.yaml\n\u2514\u2500\u2500 production.yaml\n</code></pre> PythonRust <pre><code>import os\nfrom holoconf import Config\n\nenv = os.environ.get(\"APP_ENV\", \"development\")\n\nconfig = Config.load(\"config/base.yaml\")\nenv_config = Config.load(f\"config/{env}.yaml\")\nconfig.merge(env_config)\n</code></pre> <pre><code>use holoconf::Config;\nuse std::env;\n\nfn main() -&gt; Result&lt;(), holoconf::Error&gt; {\n    let env = env::var(\"APP_ENV\").unwrap_or_else(|_| \"development\".into());\n\n    let mut config = Config::load(\"config/base.yaml\")?;\n    let env_config = Config::load(&amp;format!(\"config/{}.yaml\", env))?;\n    config.merge(env_config);\n\n    Ok(())\n}\n</code></pre>"},{"location":"guide/merging/#optional-files","title":"Optional Files","text":"<p>Sometimes you want to load configuration files that may or may not exist. For example, a <code>local.yaml</code> file that developers can create for local overrides but isn't committed to version control.</p> <p>Use <code>Config.optional()</code> to load files that might not exist:</p> PythonRust <pre><code>from holoconf import Config\n\n# Config.optional() returns empty config if file doesn't exist\nconfig = Config.load(\"config/base.yaml\")  # Required - errors if missing\nlocal = Config.optional(\"config/local.yaml\")  # Optional - empty if missing\nconfig.merge(local)\n\n# Symmetry with Config.required() (alias for load)\nconfig = Config.required(\"config/base.yaml\")  # Same as Config.load()\n</code></pre> <pre><code>use holoconf::Config;\n\nfn main() -&gt; Result&lt;(), holoconf::Error&gt; {\n    // Config::optional() returns empty config if file doesn't exist\n    let mut config = Config::load(\"config/base.yaml\")?;  // Required\n    let local = Config::optional(\"config/local.yaml\")?;  // Optional\n    config.merge(local);\n\n    // Config::required() is an alias for load()\n    let config = Config::required(\"config/base.yaml\")?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"guide/merging/#behavior","title":"Behavior","text":"<ul> <li><code>Config.load(path)</code> / <code>Config.required(path)</code>: Must exist. Returns an error if the file is not found.</li> <li><code>Config.optional(path)</code>: Returns an empty Config if the file doesn't exist. Loads normally if present.</li> </ul>"},{"location":"guide/merging/#common-pattern-local-overrides","title":"Common Pattern: Local Overrides","text":"<p>A typical setup with optional local overrides:</p> <pre><code>config/\n\u251c\u2500\u2500 base.yaml           # Committed, shared defaults\n\u251c\u2500\u2500 production.yaml     # Committed, production settings\n\u2514\u2500\u2500 local.yaml          # .gitignored, developer-specific overrides\n</code></pre> PythonRust <pre><code>from holoconf import Config\nimport os\n\nenv = os.environ.get(\"APP_ENV\", \"development\")\n\n# Load and merge in order: base \u2192 environment \u2192 local overrides\nconfig = Config.load(\"config/base.yaml\")\nenv_config = Config.load(f\"config/{env}.yaml\")\nconfig.merge(env_config)\n\n# Local overrides are optional\nlocal = Config.optional(\"config/local.yaml\")\nconfig.merge(local)\n</code></pre> <pre><code>use holoconf::Config;\nuse std::env;\n\nfn main() -&gt; Result&lt;(), holoconf::Error&gt; {\n    let env = env::var(\"APP_ENV\").unwrap_or_else(|_| \"development\".into());\n\n    // Load and merge in order\n    let mut config = Config::load(\"config/base.yaml\")?;\n    let env_config = Config::load(&amp;format!(\"config/{}.yaml\", env))?;\n    config.merge(env_config);\n\n    // Local overrides are optional\n    let local = Config::optional(\"config/local.yaml\")?;\n    config.merge(local);\n\n    Ok(())\n}\n</code></pre>"},{"location":"guide/merging/#glob-patterns","title":"Glob Patterns","text":"<p>When loading configurations from multiple files, you can use glob patterns to automatically match and merge files:</p> PythonRust <pre><code>from holoconf import Config\n\n# Load all YAML files in config/ directory\nconfig = Config.load(\"config/*.yaml\")\n\n# Load recursively from nested directories\nconfig = Config.load(\"config/**/*.yaml\")\n</code></pre> <pre><code>use holoconf::Config;\n\nfn main() -&gt; Result&lt;(), holoconf::Error&gt; {\n    // Load all YAML files in config/ directory\n    let config = Config::load(\"config/*.yaml\")?;\n\n    // Load recursively from nested directories\n    let config = Config::load(\"config/**/*.yaml\")?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"guide/merging/#supported-patterns","title":"Supported Patterns","text":"Pattern Matches <code>*</code> Any sequence of characters (except <code>/</code>) <code>**</code> Any sequence of directories <code>?</code> Any single character <code>[abc]</code> Any character in the set <code>[a-z]</code> Any character in the range"},{"location":"guide/merging/#merge-order","title":"Merge Order","text":"<p>Files matching a glob pattern are sorted alphabetically before merging. This means:</p> <ul> <li><code>00-base.yaml</code> is loaded before <code>10-override.yaml</code></li> <li><code>a.yaml</code> is loaded before <code>b.yaml</code></li> <li><code>config/base.yaml</code> is loaded before <code>config/sub/override.yaml</code></li> </ul> <p>Use numeric prefixes to control the merge order:</p> <pre><code>config/\n\u251c\u2500\u2500 00-base.yaml       # Loaded first (base settings)\n\u251c\u2500\u2500 10-database.yaml   # Loaded second\n\u251c\u2500\u2500 20-logging.yaml    # Loaded third\n\u2514\u2500\u2500 99-local.yaml      # Loaded last (highest priority)\n</code></pre>"},{"location":"guide/merging/#required-vs-optional-globs","title":"Required vs Optional Globs","text":"<ul> <li><code>Config.load(\"pattern\")</code>: At least one file must match. Returns an error if no files match.</li> <li><code>Config.optional(\"pattern\")</code>: Returns an empty config if no files match.</li> </ul> PythonRust <pre><code>from holoconf import Config\n\n# Error if no files match\nconfig = Config.load(\"config/*.yaml\")\n\n# Empty config if no files match\noverrides = Config.optional(\"overrides/*.yaml\")\n</code></pre> <pre><code>use holoconf::Config;\n\nfn main() -&gt; Result&lt;(), holoconf::Error&gt; {\n    // Error if no files match\n    let config = Config::load(\"config/*.yaml\")?;\n\n    // Empty config if no files match\n    let overrides = Config::optional(\"overrides/*.yaml\")?;\n\n    Ok(())\n}\n</code></pre> <p>See ADR-004 Config Merging for the design rationale.</p>"},{"location":"guide/resolvers/","title":"Resolvers","text":""},{"location":"guide/resolvers/#overview","title":"Overview","text":"<p>Resolvers are the mechanism HoloConf uses to dynamically compute configuration values. Each resolver handles a specific type of value source.</p> <p>All resolvers support two framework-level keyword arguments:</p> <ul> <li><code>default=value</code> - Fallback value if resolution fails</li> <li><code>sensitive=true</code> - Mark value as sensitive for redaction</li> </ul>"},{"location":"guide/resolvers/#built-in-resolvers","title":"Built-in Resolvers","text":""},{"location":"guide/resolvers/#environment-variables-env","title":"Environment Variables (<code>env</code>)","text":"<p>Reads values from environment variables.</p> <pre><code>database:\n  host: ${env:DB_HOST}\n  port: ${env:DB_PORT,default=5432}\n  password: ${env:DB_PASSWORD,sensitive=true}\n</code></pre> PythonRust <pre><code>import os\nfrom holoconf import Config\n\nos.environ[\"DB_HOST\"] = \"production-db.example.com\"\nconfig = Config.from_file(\"config.yaml\")\n\nhost = config.get(\"database.host\")  # \"production-db.example.com\"\nport = config.get(\"database.port\")  # \"5432\" (default, since DB_PORT not set)\n</code></pre> <pre><code>use holoconf::Config;\nuse std::env;\n\nfn main() -&gt; Result&lt;(), holoconf::Error&gt; {\n    env::set_var(\"DB_HOST\", \"production-db.example.com\");\n    let config = Config::from_file(\"config.yaml\")?;\n\n    let host: String = config.get(\"database.host\")?;\n    let port: String = config.get(\"database.port\")?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"guide/resolvers/#self-references","title":"Self-References","text":"<p>Reference other values within the same configuration.</p> <pre><code>base_url: https://api.example.com\n\nendpoints:\n  users: ${base_url}/users\n  orders: ${base_url}/orders\n</code></pre>"},{"location":"guide/resolvers/#relative-references","title":"Relative References","text":"<p>Use <code>.</code> for sibling references and <code>..</code> to go up levels:</p> <pre><code>database:\n  host: localhost\n  port: 5432\n  connection:\n    # Reference sibling 'host' (same level)\n    url: postgres://${.host}:${.port}/mydb\n    # Reference parent's sibling\n    timeout: ${..defaults.timeout}\n</code></pre>"},{"location":"guide/resolvers/#file-include-file","title":"File Include (<code>file</code>)","text":"<p>Include content from other files.</p> <pre><code># main.yaml\napp:\n  name: my-app\n  secrets: ${file:./secrets.yaml}\n  # With default if file doesn't exist\n  optional_config: ${file:./local.yaml,default={}}\n</code></pre>"},{"location":"guide/resolvers/#file-resolver-options","title":"File Resolver Options","text":"Option Description Example <code>parse=yaml</code> Parse as YAML <code>${file:data.txt,parse=yaml}</code> <code>parse=json</code> Parse as JSON <code>${file:data.txt,parse=json}</code> <code>parse=text</code> Read as plain text <code>${file:data.json,parse=text}</code> <code>parse=auto</code> Auto-detect from extension (default) <code>${file:config.yaml}</code> <code>encoding=utf-8</code> UTF-8 encoding (default) <code>${file:data.txt}</code> <code>encoding=base64</code> Base64 encode contents <code>${file:cert.pem,encoding=base64}</code> <code>encoding=binary</code> Return raw bytes <code>${file:image.png,encoding=binary}</code>"},{"location":"guide/resolvers/#http-http","title":"HTTP (<code>http</code>)","text":"<p>Security</p> <p>HTTP resolver is disabled by default for security. Enable it explicitly in your configuration options.</p> <p>Fetch configuration from HTTP endpoints.</p> <pre><code>feature_flags: ${http:https://config.example.com/flags.json}\n# With fallback if request fails\nremote_config: ${http:https://api.example.com/config,default={}}\n# With authentication header\nprivate_config: ${http:https://api.example.com/config,header=Authorization:Bearer token}\n# With explicit parse mode\nraw_data: ${http:https://api.example.com/data,parse=text}\n</code></pre>"},{"location":"guide/resolvers/#enabling-http-resolver","title":"Enabling HTTP Resolver","text":"PythonRust <pre><code>from holoconf import Config\n\n# Enable HTTP resolver\nconfig = Config.from_file(\"config.yaml\", allow_http=True)\n\n# With URL allowlist for additional security\nconfig = Config.from_file(\n    \"config.yaml\",\n    allow_http=True,\n    http_allowlist=[\"https://config.example.com/*\", \"https://*.internal.com/*\"]\n)\n</code></pre> <pre><code>use holoconf::Config;\n\nlet config = Config::builder()\n    .allow_http(true)\n    .http_allowlist(vec![\"https://config.example.com/*\"])\n    .load(\"config.yaml\")?;\n</code></pre>"},{"location":"guide/resolvers/#http-resolver-options","title":"HTTP Resolver Options","text":"Option Description Example <code>parse=auto</code> Auto-detect from Content-Type or URL extension (default) <code>${http:https://example.com/config}</code> <code>parse=yaml</code> Parse response as YAML <code>${http:https://example.com/config,parse=yaml}</code> <code>parse=json</code> Parse response as JSON <code>${http:https://example.com/config,parse=json}</code> <code>parse=text</code> Return response as text <code>${http:https://example.com/data,parse=text}</code> <code>parse=binary</code> Return response as raw bytes <code>${http:https://example.com/cert,parse=binary}</code> <code>timeout=30</code> Request timeout in seconds (default: 30) <code>${http:https://example.com/config,timeout=60}</code> <code>header=Name:Value</code> Add custom HTTP header <code>${http:https://api.com/config,header=Authorization:Bearer token}</code>"},{"location":"guide/resolvers/#url-allowlist-patterns","title":"URL Allowlist Patterns","text":"<p>The URL allowlist supports glob-style patterns:</p> Pattern Matches <code>https://example.com/*</code> Any path on example.com <code>https://*.example.com/*</code> Any subdomain of example.com <code>https://api.example.com/config/*</code> Specific path prefix"},{"location":"guide/resolvers/#security-best-practices","title":"Security Best Practices","text":"<ol> <li>Keep HTTP disabled by default - Only enable when needed</li> <li>Use URL allowlist - Restrict which URLs can be fetched</li> <li>Use HTTPS - Always use HTTPS for sensitive configuration</li> <li>Set appropriate timeouts - Prevent hanging on slow responses</li> <li>Use authentication - Add authorization headers for private endpoints</li> </ol>"},{"location":"guide/resolvers/#proxy-configuration","title":"Proxy Configuration","text":"<p>Configure HTTP/SOCKS proxy for requests:</p> Python <pre><code>from holoconf import Config\n\n# Explicit proxy\nconfig = Config.load(\n    \"config.yaml\",\n    allow_http=True,\n    http_proxy=\"http://proxy.corp.com:8080\"\n)\n\n# SOCKS proxy\nconfig = Config.load(\n    \"config.yaml\",\n    allow_http=True,\n    http_proxy=\"socks5://proxy.corp.com:1080\"\n)\n\n# Auto-detect from environment (HTTP_PROXY, HTTPS_PROXY)\nconfig = Config.load(\n    \"config.yaml\",\n    allow_http=True,\n    http_proxy_from_env=True\n)\n</code></pre> <p>Per-request proxy override in YAML:</p> <pre><code>value: ${http:https://api.example.com/config,proxy=http://proxy:8080}\n</code></pre>"},{"location":"guide/resolvers/#custom-ca-certificates","title":"Custom CA Certificates","text":"<p>For internal/corporate CAs or self-signed certificates:</p> Python <pre><code>from holoconf import Config\n\n# Replace default roots with custom CA bundle\nconfig = Config.load(\n    \"config.yaml\",\n    allow_http=True,\n    http_ca_bundle=\"/etc/ssl/certs/internal-ca.pem\"\n)\n\n# Add extra CA to default roots\nconfig = Config.load(\n    \"config.yaml\",\n    allow_http=True,\n    http_extra_ca_bundle=\"/etc/ssl/certs/extra-ca.pem\"\n)\n</code></pre> <p>Per-request CA override in YAML:</p> <pre><code># Replace CA bundle\nvalue: ${http:https://internal.corp/config,ca_bundle=/path/to/ca.pem}\n\n# Add extra CA\nvalue: ${http:https://api.example.com/config,extra_ca_bundle=/path/to/extra.pem}\n</code></pre>"},{"location":"guide/resolvers/#mutual-tls-mtls-client-certificates","title":"Mutual TLS (mTLS) / Client Certificates","text":"<p>For services requiring client certificate authentication:</p> Python <pre><code>from holoconf import Config\n\n# PEM certificate and key\nconfig = Config.load(\n    \"config.yaml\",\n    allow_http=True,\n    http_client_cert=\"/path/to/client.pem\",\n    http_client_key=\"/path/to/client-key.pem\"\n)\n\n# Encrypted private key\nconfig = Config.load(\n    \"config.yaml\",\n    allow_http=True,\n    http_client_cert=\"/path/to/client.pem\",\n    http_client_key=\"/path/to/client-key-encrypted.pem\",\n    http_client_key_password=\"secret\"\n)\n\n# P12/PFX bundle (includes both cert and key)\nconfig = Config.load(\n    \"config.yaml\",\n    allow_http=True,\n    http_client_cert=\"/path/to/identity.p12\",\n    http_client_key_password=\"secret\"\n)\n</code></pre> <p>Per-request mTLS in YAML:</p> <pre><code># PEM files\nvalue: ${http:https://secure.corp/config,client_cert=/path/cert.pem,client_key=/path/key.pem}\n\n# With encrypted key\nvalue: ${http:https://secure.corp/config,client_cert=/path/cert.pem,client_key=/path/key.pem,key_password=secret}\n\n# P12/PFX bundle\nvalue: ${http:https://secure.corp/config,client_cert=/path/identity.p12,key_password=secret}\n</code></pre>"},{"location":"guide/resolvers/#disabling-tls-verification","title":"Disabling TLS Verification","text":"<p>http_insecure is dangerous</p> <p>Setting <code>http_insecure=true</code> disables ALL TLS certificate verification. This exposes your application to man-in-the-middle attacks.</p> <p>Never use in production. Only for local development with self-signed certs.</p> Python <pre><code>from holoconf import Config\n\n# DANGEROUS: For development only\nconfig = Config.load(\n    \"config.yaml\",\n    allow_http=True,\n    http_insecure=True  # DO NOT USE IN PRODUCTION\n)\n</code></pre> <p>Per-request insecure mode in YAML:</p> <pre><code># DANGEROUS: Skip TLS verification\nvalue: ${http:https://dev.local/config,insecure=true}\n</code></pre>"},{"location":"guide/resolvers/#lazy-resolution","title":"Lazy Resolution","text":"<p>Resolvers are invoked lazily - values are only resolved when accessed, not when the configuration is loaded. This means:</p> <ul> <li>Environment variables are read at access time</li> <li>Files are read at access time</li> <li>HTTP requests are made at access time</li> <li>Default values are only resolved if the primary resolver fails</li> </ul> <p>See ADR-005 Resolver Timing for the design rationale.</p>"},{"location":"guide/resolvers/#sensitive-values","title":"Sensitive Values","text":"<p>Mark values as sensitive to prevent them from appearing in logs or dumps:</p> <pre><code>api:\n  key: ${env:API_KEY,sensitive=true}\n  secret: ${env:API_SECRET,default=dev-secret,sensitive=true}\n</code></pre> <p>When dumping configuration with <code>redact=True</code>:</p> <pre><code>config = Config.from_file(\"config.yaml\")\nprint(config.to_yaml(redact=True))\n# api:\n#   key: '[REDACTED]'\n#   secret: '[REDACTED]'\n</code></pre>"},{"location":"guide/resolvers/#aws-resolvers-holoconf-aws","title":"AWS Resolvers (<code>holoconf-aws</code>)","text":"<p>The <code>holoconf-aws</code> package provides resolvers for AWS services. Install separately:</p> <pre><code>pip install holoconf-aws\n</code></pre> <p>Resolvers are automatically registered when holoconf is imported.</p>"},{"location":"guide/resolvers/#ssm-parameter-store-ssm","title":"SSM Parameter Store (<code>ssm</code>)","text":"<p>Fetch values from AWS Systems Manager Parameter Store.</p> <pre><code>database:\n  host: ${ssm:/app/prod/db-host}\n  password: ${ssm:/app/prod/db-password}\n  # With region override\n  config: ${ssm:/app/config,region=us-west-2}\n  # With profile override\n  secret: ${ssm:/app/secret,profile=production}\n</code></pre> Parameter Type Behavior String Returned as-is SecureString Automatically marked as sensitive StringList Returned as a Python list"},{"location":"guide/resolvers/#cloudformation-outputs-cfn","title":"CloudFormation Outputs (<code>cfn</code>)","text":"<p>Fetch outputs from CloudFormation stacks.</p> <pre><code>infrastructure:\n  endpoint: ${cfn:my-database-stack/DatabaseEndpoint}\n  bucket: ${cfn:my-storage-stack/BucketName}\n  # With region/profile\n  vpc_id: ${cfn:shared-infra/VpcId,region=us-west-2}\n</code></pre>"},{"location":"guide/resolvers/#s3-objects-s3","title":"S3 Objects (<code>s3</code>)","text":"<p>Fetch and parse objects from S3.</p> <pre><code># Auto-parsed based on file extension\nshared_config: ${s3:my-bucket/configs/shared.yaml}\nfeature_flags: ${s3:my-bucket/settings/flags.json}\n\n# Explicit parse mode\nraw_text: ${s3:my-bucket/docs/README.md,parse=text}\nbinary_data: ${s3:my-bucket/certs/cert.pem,parse=binary}\n</code></pre>"},{"location":"guide/resolvers/#s3-parse-modes","title":"S3 Parse Modes","text":"Mode Description <code>auto</code> (default) Detect by file extension or Content-Type <code>yaml</code> Parse as YAML <code>json</code> Parse as JSON <code>text</code> Return raw text <code>binary</code> Return raw bytes (<code>Value::Bytes</code>)"},{"location":"guide/resolvers/#aws-authentication","title":"AWS Authentication","text":"<p>All AWS resolvers use the standard AWS credential chain:</p> <ol> <li>Environment variables (<code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code>)</li> <li>Shared credential file (<code>~/.aws/credentials</code>)</li> <li>AWS config file (<code>~/.aws/config</code>)</li> <li>IAM role (EC2/ECS/Lambda)</li> </ol>"},{"location":"guide/resolvers/#custom-resolvers","title":"Custom Resolvers","text":"<p>You can register custom resolvers in Python to integrate with any data source.</p>"},{"location":"guide/resolvers/#function-resolvers","title":"Function Resolvers","text":"<p>The simplest form is a function that takes a key and optional keyword arguments:</p> <pre><code>import holoconf\n\ndef my_lookup(key, region=None, **kwargs):\n    \"\"\"Custom resolver that looks up values from an internal service.\"\"\"\n    result = internal_api.get(key, region=region)\n    return result\n\nholoconf.register_resolver(\"lookup\", my_lookup)\n</code></pre> <p>Now use it in your config:</p> <pre><code>database:\n  host: ${lookup:db-host,region=us-east-1}\n</code></pre>"},{"location":"guide/resolvers/#async-resolvers","title":"Async Resolvers","text":"<p>Async functions work automatically - HoloConf will await them:</p> <pre><code>import holoconf\n\nasync def fetch_secret(key, **kwargs):\n    \"\"\"Async resolver that fetches secrets from a remote service.\"\"\"\n    async with aiohttp.ClientSession() as session:\n        async with session.get(f\"https://secrets.example.com/{key}\") as resp:\n            return await resp.text()\n\nholoconf.register_resolver(\"secret\", fetch_secret)\n</code></pre>"},{"location":"guide/resolvers/#returning-sensitive-values","title":"Returning Sensitive Values","text":"<p>For values that should be redacted in output, return a <code>ResolvedValue</code>:</p> <pre><code>from holoconf import register_resolver, ResolvedValue\n\ndef vault_resolver(path, **kwargs):\n    \"\"\"Resolver for HashiCorp Vault secrets.\"\"\"\n    secret = vault_client.read(path)\n    # Mark all Vault values as sensitive\n    return ResolvedValue(secret[\"data\"][\"value\"], sensitive=True)\n\nregister_resolver(\"vault\", vault_resolver)\n</code></pre> <pre><code>api:\n  key: ${vault:secret/data/api-key}  # Will show as [REDACTED]\n</code></pre>"},{"location":"guide/resolvers/#return-types","title":"Return Types","text":"<p>Resolvers can return various types:</p> Return Type Result <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code> Scalar value <code>list</code> List/array value <code>dict</code> Dictionary/mapping value <code>ResolvedValue(value, sensitive=True)</code> Value marked for redaction"},{"location":"guide/resolvers/#error-handling","title":"Error Handling","text":"<p>Raise <code>KeyError</code> to indicate a resource wasn't found (enables <code>default=</code> fallback):</p> <pre><code>def my_resolver(key, **kwargs):\n    result = cache.get(key)\n    if result is None:\n        raise KeyError(f\"Key not found: {key}\")\n    return result\n\nregister_resolver(\"cache\", my_resolver)\n</code></pre> <pre><code># Uses default if key not found\nvalue: ${cache:my-key,default=fallback}\n</code></pre>"},{"location":"guide/resolvers/#callable-classes","title":"Callable Classes","text":"<p>For resolvers that need initialization or state, use a callable class:</p> <pre><code>from holoconf import register_resolver, ResolvedValue\n\nclass VaultResolver:\n    def __init__(self, vault_addr):\n        self.client = hvac.Client(url=vault_addr)\n\n    def __call__(self, path, **kwargs):\n        secret = self.client.secrets.kv.read_secret_version(path=path)\n        return ResolvedValue(secret[\"data\"][\"data\"], sensitive=True)\n\nregister_resolver(\"vault\", VaultResolver(\"https://vault.example.com\"))\n</code></pre>"},{"location":"guide/resolvers/#see-also","title":"See Also","text":"<ul> <li>ADR-002 Resolver Architecture - Design rationale</li> <li>FEAT-002 Core Resolvers - Full specification</li> <li>FEAT-007 AWS Resolvers - AWS resolver specification</li> <li>Interpolation - Interpolation syntax details</li> </ul>"},{"location":"guide/validation/","title":"Schema Validation","text":"<p>HoloConf supports validating configuration against JSON Schema, helping you catch configuration errors early, enforce structure requirements, and apply default values for missing fields.</p>"},{"location":"guide/validation/#overview","title":"Overview","text":"<p>Schemas serve two purposes in HoloConf:</p> <ol> <li>Validation: Verify your configuration matches the expected structure and types</li> <li>Default Values: Automatically provide values for missing configuration paths</li> </ol>"},{"location":"guide/validation/#loading-with-schema","title":"Loading with Schema","text":"PythonCLI <pre><code>from holoconf import Config\n\n# Load config with schema attached for default values\nconfig = Config.load(\"config.yaml\", schema=\"schema.yaml\")\n\n# Access a value that might be in config or schema default\nprint(config.database.pool_size)  # Returns schema default if not in config\n</code></pre> <pre><code># Get a value with schema defaults\nholoconf get config.yaml database.pool_size --schema schema.yaml\n\n# Dump config with schema defaults applied\nholoconf dump config.yaml --schema schema.yaml --resolve\n</code></pre>"},{"location":"guide/validation/#explicit-validation","title":"Explicit Validation","text":"<p>Attaching a schema for defaults does not automatically validate. Use <code>validate()</code> to check:</p> PythonCLI <pre><code>from holoconf import Config, Schema, ValidationError\n\nconfig = Config.load(\"config.yaml\", schema=\"schema.yaml\")\n\ntry:\n    config.validate()  # Uses attached schema\n    print(\"Configuration is valid\")\nexcept ValidationError as e:\n    print(f\"Validation failed: {e}\")\n\n# Or validate with a different schema\nother_schema = Schema.load(\"other.yaml\")\nconfig.validate(other_schema)\n</code></pre> <pre><code>holoconf validate config.yaml --schema schema.yaml\n</code></pre>"},{"location":"guide/validation/#example-schema","title":"Example Schema","text":"<pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"type\": \"object\",\n  \"required\": [\"app\", \"database\"],\n  \"properties\": {\n    \"app\": {\n      \"type\": \"object\",\n      \"required\": [\"name\"],\n      \"properties\": {\n        \"name\": { \"type\": \"string\" },\n        \"debug\": { \"type\": \"boolean\", \"default\": false }\n      }\n    },\n    \"database\": {\n      \"type\": \"object\",\n      \"required\": [\"host\"],\n      \"properties\": {\n        \"host\": { \"type\": \"string\" },\n        \"port\": { \"type\": \"integer\", \"minimum\": 1, \"maximum\": 65535 },\n        \"pool_size\": { \"type\": \"integer\", \"minimum\": 1, \"default\": 10 }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"guide/validation/#schema-default-values","title":"Schema Default Values","text":"<p>When a schema is attached to a config, accessing a missing path returns the schema default instead of raising <code>PathNotFoundError</code>:</p> Python <pre><code>from holoconf import Config, Schema\n\nconfig = Config.load(\"config.yaml\", schema=\"schema.yaml\")\n\n# If pool_size is not in config.yaml but schema has default: 10\nprint(config.database.pool_size)  # Returns 10\n\n# You can also attach a schema after loading\nconfig = Config.load(\"config.yaml\")\nschema = Schema.load(\"schema.yaml\")\nconfig.set_schema(schema)\n</code></pre>"},{"location":"guide/validation/#value-precedence","title":"Value Precedence","text":"<p>When accessing a value, the precedence is:</p> <ol> <li>Config value: If the path exists in the config, that value is used</li> <li>Resolver default: If using <code>${env:VAR,default=value}</code>, the resolver default</li> <li>Schema default: If the path is missing and schema has a default</li> </ol> <pre><code># schema.yaml\ntype: object\nproperties:\n  database:\n    type: object\n    properties:\n      pool_size:\n        type: integer\n        default: 10\n</code></pre> <pre><code># config.yaml\ndatabase:\n  pool_size: 20  # Config wins - returns 20\n</code></pre>"},{"location":"guide/validation/#null-handling","title":"Null Handling","text":"<p>If a config value is explicitly <code>null</code> and the schema doesn't allow null for that field, the schema default is used:</p> <pre><code># schema.yaml\nproperties:\n  timeout:\n    type: integer  # null not allowed\n    default: 30\n</code></pre> <pre><code># config.yaml\ntimeout: null  # null not allowed by schema\n</code></pre> <pre><code>config.timeout  # Returns 30 (schema default)\n</code></pre> <p>If the schema allows null (using <code>type: [\"integer\", \"null\"]</code>), the null value is preserved.</p>"},{"location":"guide/validation/#type-coercion","title":"Type Coercion","text":"<p>When validation is enabled, HoloConf can automatically coerce values to match the schema:</p> <pre><code># config.yaml\ndatabase:\n  port: \"5432\"  # String in YAML\n</code></pre> <p>With schema validation, <code>database.port</code> will be coerced to integer <code>5432</code> based on the schema definition.</p> <p>See ADR-012 Type Coercion for details on type coercion behavior.</p>"},{"location":"guide/validation/#validation-errors","title":"Validation Errors","text":"<p>Validation errors include detailed information about what failed:</p> PythonCLI <pre><code>from holoconf import Config, ValidationError\n\ntry:\n    config = Config.from_file(\"config.yaml\")\n    config.validate(\"schema.json\")\nexcept ValidationError as e:\n    print(f\"Path: {e.path}\")\n    print(f\"Message: {e.message}\")\n    # Path: database.port\n    # Message: -1 is less than the minimum of 1\n</code></pre> <pre><code>$ holoconf validate config.yaml --schema schema.json\nValidation error at 'database.port': -1 is less than the minimum of 1\n</code></pre> <p>See ADR-007 Schema Validation for the design rationale.</p>"},{"location":"specs/features/","title":"Feature Specifications","text":"<p>This directory contains feature specifications for HoloConf. Each spec defines a user-facing capability built on top of the architectural decisions in ADRs.</p>"},{"location":"specs/features/#what-is-a-feature-spec","title":"What is a Feature Spec?","text":"<p>A feature spec is a document that defines the expected behavior of a user-facing capability. Feature specs help us:</p> <ul> <li>Define clear acceptance criteria before implementation</li> <li>Ensure consistent behavior across language bindings</li> <li>Provide a reference for writing acceptance tests</li> <li>Document the public API surface</li> </ul>"},{"location":"specs/features/#feature-status","title":"Feature Status","text":"<ul> <li>Draft - Initial specification, under development</li> <li>Review - Ready for review, may change</li> <li>Accepted - Approved and ready for implementation</li> <li>Implemented - Fully implemented and tested</li> </ul>"},{"location":"specs/features/#features","title":"Features","text":"Feature Description Status FEAT-001 Configuration File Loading Draft FEAT-002 Core Resolvers (env, self, file) Draft FEAT-003 Configuration Merging Draft FEAT-004 Schema Validation Draft FEAT-005 Serialization and Export Draft FEAT-006 Command Line Interface Draft"},{"location":"specs/features/#creating-a-new-feature-spec","title":"Creating a New Feature Spec","text":"<ol> <li>Copy <code>template.md</code> to <code>FEAT-NNN-short-title.md</code></li> <li>Fill in all sections</li> <li>Submit for review</li> <li>Update this index</li> </ol>"},{"location":"specs/features/#template","title":"Template","text":"<p>See template.md for the feature spec template.</p>"},{"location":"specs/features/FEAT-001-config-loading/","title":"FEAT-001: Configuration File Loading","text":""},{"location":"specs/features/FEAT-001-config-loading/#overview","title":"Overview","text":"<p>Load configuration data from YAML or JSON files into a <code>Config</code> object that provides dot-notation access to values.</p>"},{"location":"specs/features/FEAT-001-config-loading/#user-stories","title":"User Stories","text":"<ul> <li>As a developer, I want to load a config file so I can access configuration values in my application</li> <li>As a developer, I want to load configs from different formats (YAML, JSON) without changing my code</li> <li>As a developer, I want clear errors when config files are missing or malformed</li> </ul>"},{"location":"specs/features/FEAT-001-config-loading/#dependencies","title":"Dependencies","text":"<ul> <li>ADR-001: Multi-Language Architecture (Rust core)</li> <li>ADR-008: Error Handling Strategy</li> </ul>"},{"location":"specs/features/FEAT-001-config-loading/#api-surface","title":"API Surface","text":""},{"location":"specs/features/FEAT-001-config-loading/#python","title":"Python","text":"<pre><code>from holoconf import Config\n\n# Load a single file\nconfig = Config.load(\"config.yaml\")\n\n# Load from JSON\nconfig = Config.load(\"config.json\")\n\n# Access values with dot notation\nhost = config.database.host\nport = config.database.port\n\n# Access with bracket notation (for dynamic keys)\nkey = \"database\"\ndb_config = config[key]\n\n# Check if key exists\nif \"database\" in config:\n    ...\n\n# Get with default\ntimeout = config.get(\"api.timeout\", 30)\n\n# Async loading (for async applications)\nconfig = await Config.load_async(\"config.yaml\")\n</code></pre>"},{"location":"specs/features/FEAT-001-config-loading/#javascripttypescript","title":"JavaScript/TypeScript","text":"<pre><code>import { Config } from 'holoconf';\n\n// Load a single file\nconst config = await Config.load(\"config.yaml\");\n\n// Access values\nconst host = config.database.host;\nconst port = config.database.port;\n\n// Bracket notation\nconst dbConfig = config[\"database\"];\n\n// Check existence\nif (\"database\" in config) { ... }\n\n// Get with default\nconst timeout = config.get(\"api.timeout\", 30);\n</code></pre>"},{"location":"specs/features/FEAT-001-config-loading/#rust","title":"Rust","text":"<pre><code>use holoconf::Config;\n\n// Load a single file\nlet config = Config::load(\"config.yaml\")?;\n\n// Access values\nlet host: &amp;str = config.get(\"database.host\")?;\nlet port: i32 = config.get(\"database.port\")?;\n\n// Async loading\nlet config = Config::load_async(\"config.yaml\").await?;\n</code></pre>"},{"location":"specs/features/FEAT-001-config-loading/#behavior","title":"Behavior","text":""},{"location":"specs/features/FEAT-001-config-loading/#file-format-detection","title":"File Format Detection","text":"<p>Format is detected by file extension: - <code>.yaml</code>, <code>.yml</code> \u2192 YAML parser - <code>.json</code> \u2192 JSON parser</p> <p>If extension is ambiguous or missing, attempt YAML first (YAML is a superset of JSON).</p>"},{"location":"specs/features/FEAT-001-config-loading/#config-object-structure","title":"Config Object Structure","text":"<p>The <code>Config</code> object wraps the parsed data and provides:</p> <ol> <li>Dot-notation access: <code>config.database.host</code></li> <li>Bracket access: <code>config[\"database\"][\"host\"]</code></li> <li>Path access: <code>config.get(\"database.host\")</code></li> <li>Iteration: Iterate over keys at any level</li> <li>Length: Number of keys at current level</li> </ol>"},{"location":"specs/features/FEAT-001-config-loading/#value-types","title":"Value Types","text":"YAML/JSON Type Python JavaScript Rust string <code>str</code> <code>string</code> <code>String</code> integer <code>int</code> <code>number</code> <code>i64</code> float <code>float</code> <code>number</code> <code>f64</code> boolean <code>bool</code> <code>boolean</code> <code>bool</code> null <code>None</code> <code>null</code> <code>Option::None</code> array <code>list</code> <code>Array</code> <code>Vec</code> object <code>Config</code> (nested) <code>Config</code> (nested) <code>Config</code> (nested)"},{"location":"specs/features/FEAT-001-config-loading/#nested-objects","title":"Nested Objects","text":"<p>Nested objects return <code>Config</code> wrappers, enabling chained dot-notation:</p> <pre><code>config = Config.load(\"config.yaml\")\n# config.yaml:\n#   database:\n#     host: localhost\n#     port: 5432\n\ndb = config.database      # Returns Config wrapping {host: localhost, port: 5432}\nhost = config.database.host  # Returns \"localhost\"\n</code></pre>"},{"location":"specs/features/FEAT-001-config-loading/#interpolation-placeholders","title":"Interpolation Placeholders","text":"<p>At load time, interpolation placeholders (<code>${...}</code>) are preserved as-is. Resolution happens on access (see FEAT-002).</p> <pre><code>config = Config.load(\"config.yaml\")\n# config.yaml:\n#   port: ${env:PORT}\n\n# Before access, value is the placeholder string\nraw = config._raw(\"port\")  # \"${env:PORT}\"\n\n# On access, resolution is triggered\nport = config.port  # Resolves to actual value\n</code></pre>"},{"location":"specs/features/FEAT-001-config-loading/#error-cases","title":"Error Cases","text":""},{"location":"specs/features/FEAT-001-config-loading/#filenotfounderror","title":"FileNotFoundError","text":"<p>Raised when the config file doesn't exist.</p> <pre><code>FileNotFoundError: Configuration file not found\n  Path: /path/to/missing.yaml\n  Help: Check that the file exists and the path is correct\n</code></pre>"},{"location":"specs/features/FEAT-001-config-loading/#parseerror","title":"ParseError","text":"<p>Raised when the file contains invalid YAML/JSON.</p> <pre><code>ParseError: Invalid YAML syntax\n  Path: config.yaml\n  Line: 15\n  Column: 3\n  Details: Unexpected indentation\n  Help: Check YAML indentation at line 15\n</code></pre>"},{"location":"specs/features/FEAT-001-config-loading/#typeerror-access","title":"TypeError (Access)","text":"<p>Raised when accessing a value with incorrect type expectations.</p> <pre><code>config.database.host.foo  # database.host is a string, not an object\n</code></pre> <pre><code>TypeError: Cannot access property on non-object value\n  Path: database.host.foo\n  Type: string\n  Help: 'database.host' is a string, not an object\n</code></pre>"},{"location":"specs/features/FEAT-001-config-loading/#keyerror-access","title":"KeyError (Access)","text":"<p>Raised when accessing a non-existent key.</p> <pre><code>config.nonexistent_key\n</code></pre> <pre><code>KeyError: Key not found in configuration\n  Path: nonexistent_key\n  Available keys: database, api, logging\n  Help: Check spelling or use config.get() with a default\n</code></pre>"},{"location":"specs/features/FEAT-001-config-loading/#examples","title":"Examples","text":""},{"location":"specs/features/FEAT-001-config-loading/#basic-usage","title":"Basic Usage","text":"<pre><code># config.yaml\napp:\n  name: myapp\n  version: 1.0.0\n\ndatabase:\n  host: localhost\n  port: 5432\n\nlogging:\n  level: info\n  format: json\n</code></pre> <pre><code>from holoconf import Config\n\nconfig = Config.load(\"config.yaml\")\n\nprint(config.app.name)        # \"myapp\"\nprint(config.database.port)   # 5432\nprint(config.logging.level)   # \"info\"\n\n# Iterate over keys\nfor key in config:\n    print(key)  # \"app\", \"database\", \"logging\"\n\n# Check structure\nprint(len(config))  # 3\nprint(\"database\" in config)  # True\n</code></pre>"},{"location":"specs/features/FEAT-001-config-loading/#json-config","title":"JSON Config","text":"<pre><code>{\n  \"api\": {\n    \"endpoint\": \"https://api.example.com\",\n    \"timeout\": 30\n  }\n}\n</code></pre> <pre><code>config = Config.load(\"config.json\")\nprint(config.api.endpoint)  # \"https://api.example.com\"\n</code></pre>"},{"location":"specs/features/FEAT-001-config-loading/#error-handling","title":"Error Handling","text":"<pre><code>from holoconf import Config\nfrom holoconf.errors import FileNotFoundError, ParseError\n\ntry:\n    config = Config.load(\"config.yaml\")\nexcept FileNotFoundError as e:\n    print(f\"Config not found: {e.path}\")\nexcept ParseError as e:\n    print(f\"Invalid config at line {e.line}: {e.message}\")\n</code></pre>"},{"location":"specs/features/FEAT-001-config-loading/#implementation-notes","title":"Implementation Notes","text":""},{"location":"specs/features/FEAT-001-config-loading/#rust-core","title":"Rust Core","text":"<ul> <li>Use <code>serde_yaml</code> for YAML parsing</li> <li>Use <code>serde_json</code> for JSON parsing</li> <li>Store parsed data as internal tree structure</li> <li>Implement <code>Index</code> trait for bracket access</li> <li>FFI exposes opaque <code>Config</code> handle to language bindings</li> </ul>"},{"location":"specs/features/FEAT-001-config-loading/#language-bindings","title":"Language Bindings","text":"<ul> <li>Python: PyO3 with <code>__getattr__</code> for dot notation</li> <li>JavaScript: NAPI-RS with Proxy for dot notation</li> <li>Go: Struct with method chaining</li> </ul>"},{"location":"specs/features/FEAT-002-core-resolvers/","title":"FEAT-002: Core Resolvers","text":""},{"location":"specs/features/FEAT-002-core-resolvers/#overview","title":"Overview","text":"<p>Provide built-in resolvers for common value sources: environment variables, self-references within the config, local files, and remote URLs.</p>"},{"location":"specs/features/FEAT-002-core-resolvers/#user-stories","title":"User Stories","text":"<ul> <li>As a developer, I want to read values from environment variables so I can configure my app per environment</li> <li>As a developer, I want to reference other config values so I can avoid duplication</li> <li>As a developer, I want to include external config files so I can organize large configurations</li> <li>As a developer, I want to fetch config from URLs so I can use centralized configuration</li> </ul>"},{"location":"specs/features/FEAT-002-core-resolvers/#dependencies","title":"Dependencies","text":"<ul> <li>ADR-002: Resolver Architecture</li> <li>ADR-005: Resolver Timing (Lazy Resolution)</li> <li>ADR-011: Interpolation Syntax</li> <li>ADR-012: Type Coercion</li> <li>FEAT-001: Configuration File Loading</li> </ul>"},{"location":"specs/features/FEAT-002-core-resolvers/#core-resolvers","title":"Core Resolvers","text":""},{"location":"specs/features/FEAT-002-core-resolvers/#1-environment-resolver-env","title":"1. Environment Resolver (<code>env</code>)","text":"<p>Reads values from environment variables.</p> <p>Arguments:</p> Position Name Required Description 1 name Yes Environment variable name <p>Keyword Arguments:</p> Name Type Default Description <code>default</code> any none Default value if variable is not set <code>sensitive</code> bool <code>false</code> Mark the resolved value as sensitive <p>Behavior: - Returns the environment variable value as a string - If variable is not set and no default provided, raises <code>ResolverError</code> - If variable is not set and default is provided, returns default - Not sensitive by default; use <code>sensitive=true</code> for secrets</p> <p>Examples: <pre><code># Basic usage\nport: ${env:PORT}\n\n# With default value\nport: ${env:PORT,default=8080}\n\n# Mark as sensitive (for secrets)\ndb_password: ${env:DB_PASSWORD,sensitive=true}\n\n# Combined default and sensitive\napi_key: ${env:API_KEY,default=dev-key,sensitive=true}\n\n# With nested default\nport: ${env:PORT,default=${env:DEFAULT_PORT,default=8080}}\n</code></pre></p>"},{"location":"specs/features/FEAT-002-core-resolvers/#2-self-reference-resolver-implicit","title":"2. Self-Reference Resolver (implicit)","text":"<p>References other values within the same configuration.</p> <p>Syntax: <pre><code>defaults:\n  timeout: 30\n  host: localhost\n\ndatabase:\n  host: ${defaults.host}\n  timeout: ${defaults.timeout}\n\n  # Relative reference (sibling)\n  connection_string: \"postgres://${.host}:5432/db\"\n\n  # Relative reference (parent's sibling)\n  api_timeout: ${..api.timeout}\n\napi:\n  timeout: 60\n</code></pre></p> <p>Path Syntax: - <code>${path.to.value}</code> - Absolute path from config root - <code>${.sibling}</code> - Relative path to sibling key - <code>${..parent.key}</code> - Relative path going up one level - <code>${...grandparent.key}</code> - Relative path going up two levels</p> <p>Keyword Arguments:</p> Name Type Default Description <code>default</code> any none Default value if path doesn't exist <code>sensitive</code> bool inherited Override sensitivity (inherits from referenced value by default) <p>Behavior: - Resolves to the value at the specified path - If path doesn't exist and no default provided, raises <code>ResolverError</code> - If path doesn't exist and default is provided, returns default - Circular references are detected and raise <code>CircularReferenceError</code> - Sensitivity is inherited from the referenced value by default; can be overridden</p> <p>Array Access: <pre><code>servers:\n  - host: server1.example.com\n  - host: server2.example.com\n\nprimary_host: ${servers[0].host}\n</code></pre></p> <p>Examples: <pre><code># Basic reference\ntimeout: ${defaults.timeout}\n\n# With default for optional config\nfeature_timeout: ${features.timeout,default=30}\n\n# Sensitivity inherited from referenced value\nsecrets:\n  api_key: ${env:API_KEY,sensitive=true}\n\nderived_key: ${secrets.api_key}  # Inherits sensitive=true\n\n# Override sensitivity (rare, use with caution)\npublic_ref: ${secrets.api_key,sensitive=false}\n</code></pre></p>"},{"location":"specs/features/FEAT-002-core-resolvers/#3-file-resolver-file","title":"3. File Resolver (<code>file</code>)","text":"<p>Reads content from local files.</p> <p>Arguments:</p> Position Name Required Description 1 path Yes Local file path (relative to config file directory) <p>Keyword Arguments:</p> Name Type Default Description <code>default</code> any none Default value if file doesn't exist <code>parse</code> string <code>auto</code> How to interpret content: <code>auto</code>, <code>yaml</code>, <code>json</code>, <code>text</code>, <code>binary</code> <code>encoding</code> string <code>utf-8</code> Text encoding: <code>utf-8</code>, <code>ascii</code>, <code>latin-1</code> (ignored for <code>binary</code>) <code>sensitive</code> bool <code>false</code> Mark the resolved value as sensitive <p>Parse Modes:</p> Mode Return Type Description <code>auto</code> varies Detect by file extension (<code>.yaml</code>, <code>.yml</code>, <code>.json</code> \u2192 parsed; else \u2192 text) <code>yaml</code> structured data Parse as YAML, accessible via dot notation <code>json</code> structured data Parse as JSON, accessible via dot notation <code>text</code> string Return raw text content <code>binary</code> bytes Return raw bytes (<code>bytes</code> in Python, <code>Vec&lt;u8&gt;</code> in Rust) <p>Behavior: - Paths are relative to the config file's directory - If file doesn't exist and no default provided, raises <code>ResolverError</code> - If file doesn't exist and default is provided, returns default - When <code>parse=auto</code>, format is detected by file extension - Parsed content (YAML/JSON) returns a Config object for nested access - Text content returns a string - Binary content returns raw bytes (useful for certificates, keys, images) - Not sensitive by default; use <code>sensitive=true</code> for secrets</p> <p>Examples: <pre><code># Auto-detect format by extension\nconfig: ${file:./extra.yaml}\n\n# With default if file doesn't exist\nconfig: ${file:./optional.yaml,default={}}\n\n# Explicit text mode\nreadme: ${file:./README.md,parse=text}\n\n# Binary file (certificates, keys, etc.)\ncertificate: ${file:./ca.pem,parse=binary}\np12_cert: ${file:./client.p12,parse=binary,sensitive=true}\n\n# Different encoding for legacy files\nlegacy_config: ${file:./old.txt,encoding=latin-1}\n\n# Mark as sensitive\nsecret_key: ${file:./secret.key,sensitive=true}\n</code></pre></p> <p>Security: - Local file access is sandboxed to config directory by default</p> <pre><code># Expand sandbox to include other directories\nconfig = Config.load(\"config.yaml\", file_roots=[\"/etc/myapp\", \"./config\"])\n</code></pre>"},{"location":"specs/features/FEAT-002-core-resolvers/#4-http-resolver-http","title":"4. HTTP Resolver (<code>http</code>)","text":"<p>Fetches content from remote URLs.</p> <p>Arguments:</p> Position Name Required Description 1 url Yes HTTP or HTTPS URL <p>Keyword Arguments:</p> Name Type Default Description <code>default</code> any none Default value if request fails <code>parse</code> string <code>auto</code> How to interpret content: <code>auto</code>, <code>yaml</code>, <code>json</code>, <code>text</code>, <code>binary</code> <code>encoding</code> string <code>utf-8</code> Text encoding: <code>utf-8</code>, <code>ascii</code>, <code>latin-1</code> (ignored for <code>binary</code>) <code>timeout</code> int 30 Request timeout in seconds <code>header</code> string - HTTP header to include as <code>Name:Value</code> (repeatable) <code>sensitive</code> bool <code>false</code> Mark the resolved value as sensitive <code>proxy</code> string - HTTP or SOCKS proxy URL (overrides config-level <code>http_proxy</code>) <code>ca_bundle</code> string - Path to CA bundle (replaces default roots, overrides <code>http_ca_bundle</code>) <code>extra_ca_bundle</code> string - Path to extra CA (adds to default roots, overrides <code>http_extra_ca_bundle</code>) <code>client_cert</code> string - Path to client certificate (PEM or P12/PFX) <code>client_key</code> string - Path to client private key (PEM) <code>key_password</code> string - Password for encrypted key or P12/PFX <code>insecure</code> bool <code>false</code> Skip TLS verification (DANGEROUS, dev only) <p>Parse Modes:</p> Mode Return Type Description <code>auto</code> varies Detect by Content-Type header or URL extension <code>yaml</code> structured data Parse as YAML, accessible via dot notation <code>json</code> structured data Parse as JSON, accessible via dot notation <code>text</code> string Return raw text content <code>binary</code> bytes Return raw bytes (<code>bytes</code> in Python, <code>Vec&lt;u8&gt;</code> in Rust) <p>Behavior: - Supports <code>http://</code> and <code>https://</code> URLs - If request fails and no default provided, raises <code>ResolverError</code> - If request fails and default is provided, returns default - When <code>parse=auto</code>, format is detected by Content-Type header or URL extension - Parsed content (YAML/JSON) returns a Config object for nested access - Text content returns a string - Binary content returns raw bytes (useful for certificates, images) - Not sensitive by default; use <code>sensitive=true</code> for secrets</p> <p>Examples: <pre><code># Fetch remote config (auto-detect format)\nremote_config: ${http:https://config.example.com/shared.yaml}\n\n# With default if request fails\nremote_config: ${http:https://config.example.com/shared.yaml,default={}}\n\n# With timeout\nremote_config: ${http:https://config.example.com/shared.yaml,timeout=60}\n\n# With authentication header\nremote_config: ${http:https://config.example.com/shared.yaml,header=Authorization:Bearer ${env:API_TOKEN}}\n\n# Explicit JSON parsing\napi_config: ${http:https://api.example.com/config,parse=json}\n\n# Binary content (certificate from URL)\nca_cert: ${http:https://pki.internal/ca.pem,parse=binary}\n\n# Mark as sensitive\nsecret_config: ${http:https://vault.internal/config,sensitive=true}\n</code></pre></p> <p>Security: - Disabled by default to prevent SSRF attacks - Must be explicitly enabled at load time - Consider using URL allowlists in production</p> <pre><code># Enable HTTP resolver\nconfig = Config.load(\"config.yaml\", allow_http=True)\n\n# With URL allowlist (recommended for production)\nconfig = Config.load(\n    \"config.yaml\",\n    allow_http=True,\n    http_allowlist=[\"https://config.internal/*\", \"https://api.example.com/config/*\"]\n)\n</code></pre> <p>TLS/Proxy Configuration:</p> <p>Config-level options apply to all HTTP requests. Per-request kwargs override config-level settings.</p> Option Type Description <code>http_proxy</code> string HTTP or SOCKS proxy URL (e.g., <code>http://proxy:8080</code>, <code>socks5://proxy:1080</code>) <code>http_proxy_from_env</code> bool Auto-detect proxy from <code>HTTP_PROXY</code>/<code>HTTPS_PROXY</code> environment variables <code>http_ca_bundle</code> path Replace default root certificates with custom CA bundle <code>http_extra_ca_bundle</code> path Add extra CA certificates to default root certificates <code>http_client_cert</code> path Client certificate for mTLS (PEM or P12/PFX format) <code>http_client_key</code> path Client private key for mTLS (PEM format, not needed for P12/PFX) <code>http_client_key_password</code> string Password for encrypted private key or P12/PFX bundle <code>http_insecure</code> bool Skip TLS verification (DANGEROUS, dev only) <p>Supported Key/Certificate Formats: - Unencrypted PEM certificate and key files - Encrypted PKCS#8 PEM private keys (password protected) - P12/PFX bundles containing certificate and key (password protected)</p> <pre><code># mTLS with PEM files\nconfig = Config.load(\n    \"config.yaml\",\n    allow_http=True,\n    http_client_cert=\"/path/to/client.pem\",\n    http_client_key=\"/path/to/client-key.pem\"\n)\n\n# mTLS with encrypted key\nconfig = Config.load(\n    \"config.yaml\",\n    allow_http=True,\n    http_client_cert=\"/path/to/client.pem\",\n    http_client_key=\"/path/to/client-key.pem\",\n    http_client_key_password=\"secret\"\n)\n\n# mTLS with P12/PFX bundle\nconfig = Config.load(\n    \"config.yaml\",\n    allow_http=True,\n    http_client_cert=\"/path/to/identity.p12\",\n    http_client_key_password=\"secret\"\n)\n\n# Custom CA for internal services\nconfig = Config.load(\n    \"config.yaml\",\n    allow_http=True,\n    http_extra_ca_bundle=\"/etc/ssl/certs/internal-ca.pem\"\n)\n\n# Proxy configuration\nconfig = Config.load(\n    \"config.yaml\",\n    allow_http=True,\n    http_proxy=\"http://proxy.corp.com:8080\"\n)\n</code></pre> <p>Per-request overrides in YAML:</p> <pre><code># Override proxy for specific request\nvalue: ${http:https://api.example.com/config,proxy=http://proxy:8080}\n\n# mTLS for specific request\nvalue: ${http:https://secure.corp/config,client_cert=/path/cert.pem,client_key=/path/key.pem}\n\n# Custom CA for specific request\nvalue: ${http:https://internal.corp/config,extra_ca_bundle=/path/to/ca.pem}\n</code></pre>"},{"location":"specs/features/FEAT-002-core-resolvers/#api-surface","title":"API Surface","text":""},{"location":"specs/features/FEAT-002-core-resolvers/#registering-resolvers","title":"Registering Resolvers","text":"<p>Core resolvers are registered automatically. Custom resolvers can be added:</p> <pre><code>from holoconf import Config, Resolver, ResolvedValue\n\n# Simple function resolver\ndef my_resolver(key: str, default: str = None) -&gt; str:\n    value = lookup(key)\n    return value if value else default\n\nConfig.register_resolver(\"myresolver\", my_resolver)\n\n# Class resolver with sensitivity\nclass VaultResolver(Resolver):\n    def resolve(self, path: str) -&gt; ResolvedValue:\n        secret = self.client.read(path)\n        return ResolvedValue(value=secret, sensitive=True)\n\nConfig.register_resolver(\"vault\", VaultResolver())\n</code></pre>"},{"location":"specs/features/FEAT-002-core-resolvers/#resolver-arguments","title":"Resolver Arguments","text":"<p>Resolvers receive arguments as parsed from the interpolation:</p> <pre><code>value: ${resolver:arg1,arg2,key=value}\n</code></pre> <pre><code>def my_resolver(arg1: str, arg2: str, key: str = None) -&gt; str:\n    # arg1 = \"arg1\", arg2 = \"arg2\", key = \"value\"\n    ...\n</code></pre>"},{"location":"specs/features/FEAT-002-core-resolvers/#behavior","title":"Behavior","text":""},{"location":"specs/features/FEAT-002-core-resolvers/#resolution-timing","title":"Resolution Timing","text":"<p>Per ADR-005, resolution is lazy:</p> <pre><code>config = Config.load(\"config.yaml\")  # No resolution yet\n\n# Resolution happens on access\nport = config.port  # ${env:PORT} resolved here\n</code></pre>"},{"location":"specs/features/FEAT-002-core-resolvers/#caching","title":"Caching","text":"<p>Resolved values are memoized per config instance:</p> <pre><code>config.port  # Resolves ${env:PORT}\nconfig.port  # Returns cached value, no re-resolution\n\n# Different config instance = independent cache\nconfig2 = Config.load(\"config.yaml\")\nconfig2.port  # Resolves again\n</code></pre>"},{"location":"specs/features/FEAT-002-core-resolvers/#parallel-resolution","title":"Parallel Resolution","text":"<p>When using <code>resolve_all()</code>, independent resolutions happen in parallel:</p> <pre><code>await config.resolve_all()  # Resolves all values in parallel where possible\n</code></pre>"},{"location":"specs/features/FEAT-002-core-resolvers/#circular-reference-detection","title":"Circular Reference Detection","text":"<pre><code>a: ${b}\nb: ${c}\nc: ${a}  # Circular!\n</code></pre> <pre><code>CircularReferenceError: Circular reference detected\n  Path: c\n  Chain: a \u2192 b \u2192 c \u2192 a\n  Help: Break the circular dependency\n</code></pre>"},{"location":"specs/features/FEAT-002-core-resolvers/#error-cases","title":"Error Cases","text":""},{"location":"specs/features/FEAT-002-core-resolvers/#missing-environment-variable","title":"Missing Environment Variable","text":"<pre><code>port: ${env:UNDEFINED_VAR}\n</code></pre> <pre><code>ResolverError: Environment variable not found\n  Resolver: env\n  Key: UNDEFINED_VAR\n  Path: port\n  Help: Set the UNDEFINED_VAR environment variable or provide a default: ${env:UNDEFINED_VAR,default=value}\n</code></pre>"},{"location":"specs/features/FEAT-002-core-resolvers/#invalid-self-reference-path","title":"Invalid Self-Reference Path","text":"<pre><code>value: ${nonexistent.path}\n</code></pre> <pre><code>ResolverError: Referenced path not found\n  Resolver: self\n  Key: nonexistent.path\n  Path: value\n  Help: Check that 'nonexistent.path' exists in the configuration\n</code></pre>"},{"location":"specs/features/FEAT-002-core-resolvers/#file-not-found","title":"File Not Found","text":"<pre><code>content: ${file:./missing.txt}\n</code></pre> <pre><code>ResolverError: File not found\n  Resolver: file\n  Key: ./missing.txt\n  Path: content\n  Help: Check that the file exists relative to the config file\n</code></pre>"},{"location":"specs/features/FEAT-002-core-resolvers/#http-request-error","title":"HTTP Request Error","text":"<pre><code>config: ${http:https://example.com/config.yaml}\n</code></pre> <pre><code>ResolverError: Failed to fetch remote configuration\n  Resolver: http\n  Key: https://example.com/config.yaml\n  Path: config\n  Cause: HTTP 404 Not Found\n  Help: Check the URL is correct and accessible\n</code></pre>"},{"location":"specs/features/FEAT-002-core-resolvers/#http-resolver-disabled","title":"HTTP Resolver Disabled","text":"<pre><code>config: ${http:https://example.com/config.yaml}\n</code></pre> <pre><code>ResolverError: HTTP resolver is disabled\n  Resolver: http\n  Key: https://example.com/config.yaml\n  Path: config\n  Help: Enable HTTP resolver with Config.load(..., allow_http=True)\n</code></pre>"},{"location":"specs/features/FEAT-002-core-resolvers/#http-url-not-in-allowlist","title":"HTTP URL Not in Allowlist","text":"<pre><code>config: ${http:https://untrusted.com/config.yaml}\n</code></pre> <pre><code>ResolverError: URL not in allowlist\n  Resolver: http\n  Key: https://untrusted.com/config.yaml\n  Path: config\n  Allowlist: https://config.internal/*, https://api.example.com/config/*\n  Help: Add the URL to http_allowlist or check for typos\n</code></pre>"},{"location":"specs/features/FEAT-002-core-resolvers/#examples","title":"Examples","text":""},{"location":"specs/features/FEAT-002-core-resolvers/#environment-based-configuration","title":"Environment-Based Configuration","text":"<pre><code># config.yaml\ndatabase:\n  host: ${env:DB_HOST,default=localhost}\n  port: ${env:DB_PORT,default=5432}\n  username: ${env:DB_USER}\n  password: ${env:DB_PASSWORD,sensitive=true}\n\nlogging:\n  level: ${env:LOG_LEVEL,default=info}\n</code></pre> <pre><code>import os\nos.environ[\"DB_HOST\"] = \"prod-db.example.com\"\nos.environ[\"DB_USER\"] = \"admin\"\nos.environ[\"DB_PASSWORD\"] = \"secret\"\n\nconfig = Config.load(\"config.yaml\")\nprint(config.database.host)  # \"prod-db.example.com\"\nprint(config.database.port)  # \"5432\" (default)\n</code></pre>"},{"location":"specs/features/FEAT-002-core-resolvers/#dry-configuration-with-self-references","title":"DRY Configuration with Self-References","text":"<pre><code># config.yaml\ndefaults:\n  region: us-east-1\n  environment: production\n\naws:\n  region: ${defaults.region}\n\n  s3:\n    bucket: myapp-${defaults.environment}-${defaults.region}\n\n  dynamodb:\n    table: myapp-${defaults.environment}-data\n</code></pre>"},{"location":"specs/features/FEAT-002-core-resolvers/#including-external-files","title":"Including External Files","text":"<pre><code># config.yaml\napp:\n  name: myapp\n\n# Include shared database config\ndatabase: ${file:./database.yaml}\n\n# Include environment-specific overrides\noverrides: ${file:./envs/${env:ENVIRONMENT,default=development}.yaml}\n</code></pre> <pre><code># database.yaml\nhost: localhost\nport: 5432\npool_size: 10\n</code></pre>"},{"location":"specs/features/FEAT-002-core-resolvers/#remote-configuration","title":"Remote Configuration","text":"<pre><code># config.yaml\n# Fetch shared config from config server\nshared: ${http:https://config.internal/shared/v1.yaml}\n\n# Override with local values\nlocal:\n  feature_flags: ${http:https://config.internal/flags/${env:APP_ENV}.json}\n</code></pre> <pre><code>config = Config.load(\"config.yaml\", allow_http=True)\n</code></pre>"},{"location":"specs/features/FEAT-002-core-resolvers/#transformation-resolvers","title":"Transformation Resolvers","text":"<p>These resolvers transform string values into structured data. They are useful for parsing JSON or YAML stored in environment variables, SSM parameters, or other string sources.</p>"},{"location":"specs/features/FEAT-002-core-resolvers/#5-json-resolver-json","title":"5. JSON Resolver (<code>json</code>)","text":"<p>Parses a JSON string into a structured value.</p> <p>Syntax: <pre><code># Parse JSON from environment variable\nsettings: ${json:${env:SETTINGS_JSON}}\n\n# Access nested values after parsing\ndb_host: ${json:${env:DB_CONFIG}}.host\n\n# With sensitivity override\nsecrets: ${json:${ssm:/app/secrets},sensitive=false}\n</code></pre></p> <p>Arguments:</p> Position Name Required Description 1 value Yes JSON string to parse <p>Keyword Arguments:</p> Name Type Default Description <code>sensitive</code> bool inherited Override sensitivity (inherits from input by default) <p>Behavior: - Parses strict JSON (no trailing commas, no comments) - Supports all JSON root types: object, array, string, number, boolean, null - Returns structured data accessible via dot notation - Parse errors raise <code>ResolverError</code> with line/column information and truncated input preview (first 50 chars) - Sensitivity is inherited from the input value by default; can be overridden</p> <p>Error Example: <pre><code>ResolverError: Invalid JSON at line 1, column 15: expected ':' but found '}'\n  Resolver: json\n  Input preview: {\"invalid json}\n  Path: settings\n  Help: Check that the input is valid JSON\n</code></pre></p>"},{"location":"specs/features/FEAT-002-core-resolvers/#6-yaml-resolver-yaml","title":"6. YAML Resolver (<code>yaml</code>)","text":"<p>Parses a YAML string into a structured value.</p> <p>Syntax: <pre><code># Parse YAML from environment variable\nconfig: ${yaml:${env:CONFIG_YAML}}\n\n# Parse YAML from file content\nsettings: ${yaml:${file:./settings.txt}}\n\n# With sensitivity override\nsecrets: ${yaml:${ssm:/app/secrets},sensitive=false}\n</code></pre></p> <p>Arguments:</p> Position Name Required Description 1 value Yes YAML string to parse <p>Keyword Arguments:</p> Name Type Default Description <code>sensitive</code> bool inherited Override sensitivity (inherits from input by default) <p>Behavior: - Parses the first YAML document only (ignores <code>---</code> separated documents) - Preserves YAML's native type coercion (<code>yes</code> \u2192 boolean, <code>1.0</code> \u2192 float, etc.) - Returns structured data accessible via dot notation - Parse errors raise <code>ResolverError</code> with position information and truncated input preview - Sensitivity is inherited from the input value by default; can be overridden</p> <p>Error Example: <pre><code>ResolverError: Invalid YAML at line 3, column 5: mapping values are not allowed here\n  Resolver: yaml\n  Input preview: \"key: value\\n  invalid: - item\"\n  Path: config\n  Help: Check that the input is valid YAML\n</code></pre></p>"},{"location":"specs/features/FEAT-002-core-resolvers/#7-split-resolver-split","title":"7. Split Resolver (<code>split</code>)","text":"<p>Splits a string into an array of strings using a delimiter.</p> <p>Syntax: <pre><code># Default delimiter (comma), with whitespace trimming\nhosts: ${split:${env:DB_HOSTS}}\n# Input: \"host1, host2, host3\" \u2192 [\"host1\", \"host2\", \"host3\"]\n\n# Custom delimiter\npath_parts: ${split:${env:PATH},delim=:}\n# Input: \"/usr/bin:/usr/local/bin\" \u2192 [\"/usr/bin\", \"/usr/local/bin\"]\n\n# Disable trimming\nraw_values: ${split:${env:VALUES},trim=false}\n# Input: \"a, b, c\" \u2192 [\"a\", \" b\", \" c\"]\n\n# Skip empty elements\nnon_empty: ${split:${env:LIST},skip_empty=true}\n# Input: \"a,,b\" \u2192 [\"a\", \"b\"]\n\n# Limit number of splits\nkey_value: ${split:${env:PAIR},delim==,limit=2}\n# Input: \"key=value=with=equals\" \u2192 [\"key\", \"value=with=equals\"]\n</code></pre></p> <p>Arguments:</p> Position Name Required Description 1 value Yes String to split <p>Keyword Arguments:</p> Name Type Default Description <code>delim</code> string <code>,</code> Delimiter to split on <code>trim</code> bool <code>true</code> Trim whitespace from each element <code>skip_empty</code> bool <code>false</code> Remove empty strings from result <code>limit</code> int none Maximum number of splits (results in at most <code>limit + 1</code> elements) <code>sensitive</code> bool inherited Override sensitivity (inherits from input by default) <p>Behavior: - Splits string by delimiter (no escape sequence support) - Trims whitespace from each element by default - Empty input string returns empty array <code>[]</code> - Empty elements are preserved by default (use <code>skip_empty=true</code> to filter) - Always returns an array of strings (no type coercion) - Sensitivity is inherited from the input value by default; can be overridden</p> <p>Examples:</p> <pre><code># Environment: DB_HOSTS=\"primary.db.local, replica1.db.local, replica2.db.local\"\ndatabase:\n  hosts: ${split:${env:DB_HOSTS}}\n  # Result: [\"primary.db.local\", \"replica1.db.local\", \"replica2.db.local\"]\n\n  primary: ${split:${env:DB_HOSTS}}[0]\n  # Result: \"primary.db.local\"\n\n# Environment: FEATURES=\"dark_mode,,beta_ui,new_checkout\"\nfeatures:\n  all: ${split:${env:FEATURES}}\n  # Result: [\"dark_mode\", \"\", \"beta_ui\", \"new_checkout\"]\n\n  enabled: ${split:${env:FEATURES},skip_empty=true}\n  # Result: [\"dark_mode\", \"beta_ui\", \"new_checkout\"]\n\n# Environment: CONNECTION=\"user:password:host:5432:database\"\nconnection:\n  parts: ${split:${env:CONNECTION},delim=:,limit=4}\n  # Result: [\"user\", \"password\", \"host\", \"5432\", \"database\"]\n  # Note: limit=4 means 4 splits, resulting in 5 elements max\n</code></pre>"},{"location":"specs/features/FEAT-002-core-resolvers/#implementation-notes","title":"Implementation Notes","text":""},{"location":"specs/features/FEAT-002-core-resolvers/#rust-core","title":"Rust Core","text":"<ul> <li><code>env</code> resolver: Use <code>std::env::var</code></li> <li><code>self</code> resolver: Tree traversal with path parsing</li> <li><code>file</code> resolver: Use <code>std::fs::read</code> for binary, <code>std::fs::read_to_string</code> for text</li> <li><code>http</code> resolver: Use <code>reqwest</code> with async support, <code>bytes()</code> for binary mode</li> <li><code>json</code> resolver: Use <code>serde_json::from_str</code></li> <li><code>yaml</code> resolver: Use <code>serde_yaml::from_str</code> (first document only)</li> <li><code>split</code> resolver: Use <code>str::split</code> with trim/filter options</li> <li>Circular detection: Track resolution stack, error if path revisited</li> <li>Binary values: Represent as <code>Vec&lt;u8&gt;</code> in Rust, <code>bytes</code> in Python</li> </ul>"},{"location":"specs/features/FEAT-002-core-resolvers/#security-considerations","title":"Security Considerations","text":"<ul> <li>HTTP resolver disabled by default to prevent SSRF</li> <li>Local file access sandboxed by default</li> <li>URL allowlists for HTTP resolver in production</li> <li>Log resolver calls for audit trail (opt-in)</li> <li>Transformation resolvers inherit sensitivity from input to prevent accidental exposure</li> <li>All resolvers support <code>sensitive</code> keyword for explicit marking</li> </ul>"},{"location":"specs/features/FEAT-003-config-merging/","title":"FEAT-003: Configuration Merging","text":""},{"location":"specs/features/FEAT-003-config-merging/#overview","title":"Overview","text":"<p>Load and merge multiple configuration files in a specified order, with later files overriding earlier ones. This enables layered configuration (base \u2192 environment \u2192 local overrides).</p>"},{"location":"specs/features/FEAT-003-config-merging/#user-stories","title":"User Stories","text":"<ul> <li>As a developer, I want to have a base config with environment-specific overrides</li> <li>As a developer, I want local development settings without modifying shared configs</li> <li>As a developer, I want to understand which file a value came from when debugging</li> </ul>"},{"location":"specs/features/FEAT-003-config-merging/#dependencies","title":"Dependencies","text":"<ul> <li>ADR-004: Config Merging Semantics</li> <li>FEAT-001: Configuration File Loading</li> </ul>"},{"location":"specs/features/FEAT-003-config-merging/#api-surface","title":"API Surface","text":""},{"location":"specs/features/FEAT-003-config-merging/#loading-multiple-files","title":"Loading Multiple Files","text":"<pre><code>from holoconf import Config\n\n# Load multiple files - later files override earlier\nconfig = Config.load(\n    \"base.yaml\",\n    \"environment.yaml\",\n    \"local.yaml\"  # Highest priority\n)\n\n# Load with glob patterns\nconfig = Config.load(\"config/*.yaml\")  # Sorted alphabetically\n\n# Load with explicit order\nconfig = Config.load(\n    \"config/00-base.yaml\",\n    \"config/10-environment.yaml\",\n    \"config/99-local.yaml\"\n)\n</code></pre>"},{"location":"specs/features/FEAT-003-config-merging/#javascript","title":"JavaScript","text":"<pre><code>const config = await Config.load(\n    \"base.yaml\",\n    \"environment.yaml\",\n    \"local.yaml\"\n);\n</code></pre>"},{"location":"specs/features/FEAT-003-config-merging/#rust","title":"Rust","text":"<pre><code>let config = Config::load(&amp;[\n    \"base.yaml\",\n    \"environment.yaml\",\n    \"local.yaml\",\n])?;\n</code></pre>"},{"location":"specs/features/FEAT-003-config-merging/#behavior","title":"Behavior","text":""},{"location":"specs/features/FEAT-003-config-merging/#merge-semantics-from-adr-004","title":"Merge Semantics (from ADR-004)","text":"<p>Deep merge with last-writer-wins:</p> Scenario Behavior Key exists in both Later value wins Key only in base Preserved Key only in overlay Added Both are objects Deep merge recursively Type mismatch Later value replaces entirely Value is <code>null</code> Removes key from result"},{"location":"specs/features/FEAT-003-config-merging/#deep-merge-example","title":"Deep Merge Example","text":"<pre><code># base.yaml\ndatabase:\n  host: localhost\n  port: 5432\n  pool:\n    min: 5\n    max: 20\n\nlogging:\n  level: debug\n</code></pre> <pre><code># production.yaml\ndatabase:\n  host: prod-db.example.com\n  pool:\n    max: 100  # Only override max, keep min\n\nlogging:\n  level: info\n</code></pre> <pre><code># Result after merge\ndatabase:\n  host: prod-db.example.com  # From production.yaml\n  port: 5432                  # From base.yaml\n  pool:\n    min: 5                    # From base.yaml\n    max: 100                  # From production.yaml\n\nlogging:\n  level: info                 # From production.yaml\n</code></pre>"},{"location":"specs/features/FEAT-003-config-merging/#removing-keys-with-null","title":"Removing Keys with Null","text":"<pre><code># base.yaml\ndatabase:\n  host: localhost\n  port: 5432\n  debug_logging: true\n\n# production.yaml\ndatabase:\n  debug_logging: null  # Remove this key\n</code></pre> <pre><code># Result\ndatabase:\n  host: localhost\n  port: 5432\n  # debug_logging is removed\n</code></pre>"},{"location":"specs/features/FEAT-003-config-merging/#array-handling","title":"Array Handling","text":"<p>Arrays are replaced entirely, not merged:</p> <pre><code># base.yaml\nservers:\n  - host: server1.example.com\n  - host: server2.example.com\n\n# override.yaml\nservers:\n  - host: prod1.example.com\n</code></pre> <pre><code># Result - array is replaced, not merged\nservers:\n  - host: prod1.example.com\n</code></pre>"},{"location":"specs/features/FEAT-003-config-merging/#glob-pattern-loading","title":"Glob Pattern Loading","text":"<p>When using glob patterns, files are sorted alphabetically:</p> <pre><code>config = Config.load(\"config/*.yaml\")\n# Loads: 00-base.yaml, 10-database.yaml, 20-api.yaml, 99-local.yaml\n# in that order\n</code></pre>"},{"location":"specs/features/FEAT-003-config-merging/#optional-files","title":"Optional Files","text":"<p>Files can be marked as optional (no error if missing):</p> <pre><code>config = Config.load(\n    \"base.yaml\",                    # Required\n    \"environment.yaml\",             # Required\n    Config.optional(\"local.yaml\")   # Optional\n)\n</code></pre> <pre><code>const config = await Config.load(\n    \"base.yaml\",\n    \"environment.yaml\",\n    { path: \"local.yaml\", optional: true }\n);\n</code></pre>"},{"location":"specs/features/FEAT-003-config-merging/#source-tracking-debug","title":"Source Tracking (Debug)","text":"<p>Source tracking is available when loading a single file with <code>Config.load()</code>:</p> <pre><code>config = Config.load(\"config.yaml\")\n\n# Get source file for a specific path\nsource = config.get_source(\"database.host\")\nprint(source)  # \"config.yaml\"\n\n# Get all sources as a dict\nsources = config.dump_sources()\n# {\"database.host\": \"config.yaml\", \"database.port\": \"config.yaml\", ...}\n</code></pre> <p>Note: Source tracking does not persist through <code>merge()</code> operations. For merged configs, individual file loading provides source info, but merged results track only values.</p>"},{"location":"specs/features/FEAT-003-config-merging/#cli-usage","title":"CLI Usage","text":"<pre><code># Show source files instead of values\nholoconf dump --sources base.yaml override.yaml\n# Output:\n# database.host: override.yaml\n# database.port: base.yaml\n\n# JSON format\nholoconf dump --sources --format json base.yaml override.yaml\n</code></pre>"},{"location":"specs/features/FEAT-003-config-merging/#error-cases","title":"Error Cases","text":""},{"location":"specs/features/FEAT-003-config-merging/#file-not-found-required","title":"File Not Found (Required)","text":"<pre><code>config = Config.load(\"base.yaml\", \"missing.yaml\")\n</code></pre> <pre><code>FileNotFoundError: Configuration file not found\n  Path: missing.yaml\n  Help: Check that the file exists or mark it as optional\n</code></pre>"},{"location":"specs/features/FEAT-003-config-merging/#glob-no-matches","title":"Glob No Matches","text":"<pre><code>config = Config.load(\"config/*.yaml\")  # No matching files\n</code></pre> <pre><code>FileNotFoundError: No configuration files matched pattern\n  Pattern: config/*.yaml\n  Help: Check the pattern and directory exist\n</code></pre>"},{"location":"specs/features/FEAT-003-config-merging/#parse-error-in-any-file","title":"Parse Error in Any File","text":"<pre><code>config = Config.load(\"base.yaml\", \"broken.yaml\")\n</code></pre> <pre><code>ParseError: Invalid YAML syntax\n  Path: broken.yaml\n  Line: 10\n  Help: Fix syntax error before merging\n</code></pre>"},{"location":"specs/features/FEAT-003-config-merging/#examples","title":"Examples","text":""},{"location":"specs/features/FEAT-003-config-merging/#environment-based-configuration","title":"Environment-Based Configuration","text":"<pre><code>config/\n\u251c\u2500\u2500 base.yaml           # Shared defaults\n\u251c\u2500\u2500 development.yaml    # Dev settings\n\u251c\u2500\u2500 staging.yaml        # Staging settings\n\u2514\u2500\u2500 production.yaml     # Production settings\n</code></pre> <pre><code>import os\n\nenv = os.environ.get(\"APP_ENV\", \"development\")\n\nconfig = Config.load(\n    \"config/base.yaml\",\n    f\"config/{env}.yaml\",\n    Config.optional(\"config/local.yaml\")  # Developer overrides\n)\n</code></pre>"},{"location":"specs/features/FEAT-003-config-merging/#feature-flags-overlay","title":"Feature Flags Overlay","text":"<pre><code># base.yaml\nfeatures:\n  new_checkout: false\n  dark_mode: false\n  beta_api: false\n</code></pre> <pre><code># features-enabled.yaml\nfeatures:\n  new_checkout: true\n  beta_api: true\n</code></pre> <pre><code>config = Config.load(\"base.yaml\")\n\nif enable_features:\n    config = Config.load(\"base.yaml\", \"features-enabled.yaml\")\n</code></pre>"},{"location":"specs/features/FEAT-003-config-merging/#multi-region-configuration","title":"Multi-Region Configuration","text":"<pre><code># base.yaml\naws:\n  region: us-east-1\n\ndatabase:\n  host: ${env:DB_HOST}\n</code></pre> <pre><code># regions/eu-west-1.yaml\naws:\n  region: eu-west-1\n\nendpoints:\n  api: https://api.eu.example.com\n</code></pre> <pre><code>region = os.environ.get(\"AWS_REGION\", \"us-east-1\")\nconfig = Config.load(\n    \"base.yaml\",\n    f\"regions/{region}.yaml\"\n)\n</code></pre>"},{"location":"specs/features/FEAT-003-config-merging/#debugging-merge-issues","title":"Debugging Merge Issues","text":"<pre><code># Load with source tracking\nconfig = Config.load(\n    \"base.yaml\",\n    \"override.yaml\",\n    track_sources=True\n)\n\n# Find where a value came from\nsource = config.get_source(\"database.pool.max\")\nprint(f\"Value came from {source.file}:{source.line}\")\n\n# Dump full merge trace\nfor path, source in config.sources():\n    print(f\"{path}: {source.file}:{source.line}\")\n</code></pre>"},{"location":"specs/features/FEAT-003-config-merging/#implementation-notes","title":"Implementation Notes","text":""},{"location":"specs/features/FEAT-003-config-merging/#merge-algorithm","title":"Merge Algorithm","text":"<pre><code>function merge(base, overlay):\n    result = copy(base)\n\n    for key, value in overlay:\n        if value is null:\n            delete result[key]\n        else if key not in result:\n            result[key] = value\n        else if both are objects:\n            result[key] = merge(result[key], value)\n        else:\n            result[key] = value  # Replace\n\n    return result\n</code></pre>"},{"location":"specs/features/FEAT-003-config-merging/#source-tracking","title":"Source Tracking","text":"<p>Source tracking is always enabled (low overhead): - Store filename for each leaf value path - Update on merge (overlay source replaces base source) - File-level only (no line numbers) - sufficient for debugging merged configs - Accessed via <code>get_source(path)</code> and <code>dump_sources()</code> methods</p>"},{"location":"specs/features/FEAT-003-config-merging/#glob-handling","title":"Glob Handling","text":"<ul> <li>Use <code>glob</code> crate in Rust</li> <li>Sort results alphabetically for deterministic order</li> <li>Expand before loading</li> </ul>"},{"location":"specs/features/FEAT-004-schema-validation/","title":"FEAT-004: Schema Validation","text":""},{"location":"specs/features/FEAT-004-schema-validation/#overview","title":"Overview","text":"<p>Validate configuration against a JSON Schema to catch errors early, document the expected structure, and enable type coercion for resolved values.</p>"},{"location":"specs/features/FEAT-004-schema-validation/#user-stories","title":"User Stories","text":"<ul> <li>As a developer, I want to define what my config should look like so mistakes are caught early</li> <li>As a developer, I want helpful error messages when config doesn't match the schema</li> <li>As a developer, I want environment variables (strings) automatically converted to the right types</li> <li>As a developer, I want to document my config structure in a standard format</li> </ul>"},{"location":"specs/features/FEAT-004-schema-validation/#dependencies","title":"Dependencies","text":"<ul> <li>ADR-007: Schema and Validation</li> <li>ADR-012: Type Coercion</li> <li>FEAT-001: Configuration File Loading</li> </ul>"},{"location":"specs/features/FEAT-004-schema-validation/#api-surface","title":"API Surface","text":""},{"location":"specs/features/FEAT-004-schema-validation/#loading-with-schema","title":"Loading with Schema","text":"<pre><code>from holoconf import Config\n\n# Load with schema validation\nconfig = Config.load(\n    \"config.yaml\",\n    schema=\"schema.yaml\"\n)\n\n# Schema can be JSON or YAML\nconfig = Config.load(\"config.yaml\", schema=\"schema.json\")\n\n# Validate after loading\nconfig = Config.load(\"config.yaml\")\nconfig.validate(schema=\"schema.yaml\")\n\n# Validate resolved values explicitly\nawait config.resolve_all()\nconfig.validate()  # Re-validates with resolved values\n</code></pre>"},{"location":"specs/features/FEAT-004-schema-validation/#javascript","title":"JavaScript","text":"<pre><code>const config = await Config.load(\"config.yaml\", {\n    schema: \"schema.yaml\"\n});\n\n// Or validate separately\nconst config = await Config.load(\"config.yaml\");\nconfig.validate(\"schema.yaml\");\n</code></pre>"},{"location":"specs/features/FEAT-004-schema-validation/#schema-format","title":"Schema Format","text":"<p>Schemas use JSON Schema (Draft 2020-12), written in YAML or JSON:</p> <pre><code># schema.yaml\ntype: object\nrequired:\n  - database\n  - api\n\nproperties:\n  database:\n    type: object\n    required: [host, port]\n    properties:\n      host:\n        type: string\n        description: Database hostname\n      port:\n        type: integer\n        minimum: 1\n        maximum: 65535\n      pool_size:\n        type: integer\n        minimum: 1\n        default: 10\n\n  api:\n    type: object\n    properties:\n      timeout:\n        type: number\n        minimum: 0\n        description: Request timeout in seconds\n      retries:\n        type: integer\n        minimum: 0\n        maximum: 10\n        default: 3\n</code></pre>"},{"location":"specs/features/FEAT-004-schema-validation/#behavior","title":"Behavior","text":""},{"location":"specs/features/FEAT-004-schema-validation/#two-phase-validation-from-adr-007","title":"Two-Phase Validation (from ADR-007)","text":"<p>Phase 1: Structural Validation (at load time) - Required keys present - Object/array structure matches - Additional properties allowed/denied - Interpolations (<code>${...}</code>) pass as valid placeholders</p> <p>Phase 2: Type/Value Validation (on access or <code>validate()</code>) - Resolved values match expected types - Constraints (min, max, pattern, enum) are checked - Type coercion applied if schema expects different type</p>"},{"location":"specs/features/FEAT-004-schema-validation/#type-coercion-from-adr-012","title":"Type Coercion (from ADR-012)","text":"<p>When a schema specifies a type, string values are automatically coerced:</p> <pre><code># schema.yaml\nproperties:\n  port:\n    type: integer\n</code></pre> <pre><code># config.yaml\nport: ${env:PORT}  # Returns \"8080\" (string)\n</code></pre> <pre><code>config = Config.load(\"config.yaml\", schema=\"schema.yaml\")\nport = config.port  # Returns 8080 (integer) - coerced\n</code></pre> <p>Coercion Rules:</p> From To Rule string integer Parse as integer string number Parse as float string boolean <code>\"true\"/\"false\"/\"1\"/\"0\"</code>"},{"location":"specs/features/FEAT-004-schema-validation/#schema-composition-with-ref","title":"Schema Composition with $ref","text":"<p>Split schemas across files:</p> <pre><code># schema.yaml\ntype: object\nproperties:\n  database:\n    $ref: \"./schemas/database.yaml\"\n  api:\n    $ref: \"./schemas/api.yaml\"\n</code></pre> <pre><code># schemas/database.yaml\ntype: object\nrequired: [host]\nproperties:\n  host:\n    type: string\n  port:\n    type: integer\n    default: 5432\n</code></pre> <p>Refs are resolved relative to the schema file.</p>"},{"location":"specs/features/FEAT-004-schema-validation/#default-values","title":"Default Values","text":"<p>Schema defaults are applied during validation:</p> <pre><code># schema.yaml\nproperties:\n  pool_size:\n    type: integer\n    default: 10\n</code></pre> <pre><code># config.yaml\n# pool_size not specified\n</code></pre> <pre><code>config = Config.load(\"config.yaml\", schema=\"schema.yaml\")\nprint(config.pool_size)  # 10 (from schema default)\n</code></pre>"},{"location":"specs/features/FEAT-004-schema-validation/#additional-properties","title":"Additional Properties","text":"<p>By default, extra keys are allowed. Use <code>additionalProperties: false</code> to reject:</p> <pre><code># schema.yaml\ntype: object\nproperties:\n  name:\n    type: string\nadditionalProperties: false  # Only 'name' allowed\n</code></pre> <pre><code># config.yaml\nname: myapp\nextra_key: value  # This will cause an error\n</code></pre>"},{"location":"specs/features/FEAT-004-schema-validation/#error-cases","title":"Error Cases","text":""},{"location":"specs/features/FEAT-004-schema-validation/#missing-required-key","title":"Missing Required Key","text":"<pre><code>StructuralValidationError: Missing required key\n  Path: database.host\n  Schema: schema.yaml#/properties/database/required\n  Help: Add 'host' key to the database section\n</code></pre>"},{"location":"specs/features/FEAT-004-schema-validation/#type-mismatch","title":"Type Mismatch","text":"<pre><code>TypeValidationError: Invalid type\n  Path: database.port\n  Expected: integer\n  Got: string (\"not-a-number\")\n  Resolved from: ${env:DB_PORT}\n  Help: Ensure DB_PORT contains a valid integer\n</code></pre>"},{"location":"specs/features/FEAT-004-schema-validation/#constraint-violation","title":"Constraint Violation","text":"<pre><code>TypeValidationError: Value out of range\n  Path: database.port\n  Constraint: minimum: 1, maximum: 65535\n  Got: 70000\n  Help: Port must be between 1 and 65535\n</code></pre>"},{"location":"specs/features/FEAT-004-schema-validation/#additional-property-not-allowed","title":"Additional Property Not Allowed","text":"<pre><code>StructuralValidationError: Additional property not allowed\n  Path: extra_key\n  Schema: schema.yaml#/additionalProperties\n  Help: Remove 'extra_key' or update schema to allow it\n</code></pre>"},{"location":"specs/features/FEAT-004-schema-validation/#enum-violation","title":"Enum Violation","text":"<pre><code># schema.yaml\nproperties:\n  log_level:\n    type: string\n    enum: [debug, info, warn, error]\n</code></pre> <pre><code>TypeValidationError: Value not in allowed set\n  Path: log_level\n  Allowed: debug, info, warn, error\n  Got: \"verbose\"\n  Help: Use one of the allowed values\n</code></pre>"},{"location":"specs/features/FEAT-004-schema-validation/#examples","title":"Examples","text":""},{"location":"specs/features/FEAT-004-schema-validation/#complete-schema-example","title":"Complete Schema Example","text":"<pre><code># schema.yaml\n$schema: \"https://json-schema.org/draft/2020-12/schema\"\ntitle: Application Configuration\ndescription: Configuration schema for MyApp\n\ntype: object\nrequired:\n  - app\n  - database\n\nproperties:\n  app:\n    type: object\n    required: [name]\n    properties:\n      name:\n        type: string\n        minLength: 1\n        description: Application name\n      version:\n        type: string\n        pattern: \"^\\\\d+\\\\.\\\\d+\\\\.\\\\d+$\"\n        description: Semantic version\n      debug:\n        type: boolean\n        default: false\n\n  database:\n    type: object\n    required: [host]\n    properties:\n      host:\n        type: string\n        description: Database hostname\n      port:\n        type: integer\n        minimum: 1\n        maximum: 65535\n        default: 5432\n      ssl:\n        type: boolean\n        default: true\n      pool:\n        type: object\n        properties:\n          min:\n            type: integer\n            minimum: 1\n            default: 5\n          max:\n            type: integer\n            minimum: 1\n            default: 20\n\n  logging:\n    type: object\n    properties:\n      level:\n        type: string\n        enum: [debug, info, warn, error]\n        default: info\n      format:\n        type: string\n        enum: [json, text]\n        default: json\n</code></pre>"},{"location":"specs/features/FEAT-004-schema-validation/#using-the-schema","title":"Using the Schema","text":"<pre><code># config.yaml\napp:\n  name: myapp\n  version: 1.0.0\n\ndatabase:\n  host: ${env:DB_HOST}\n  port: ${env:DB_PORT,default=5432}\n\nlogging:\n  level: ${env:LOG_LEVEL,default=info}\n</code></pre> <pre><code>config = Config.load(\"config.yaml\", schema=\"schema.yaml\")\n\n# Access triggers resolution + type validation\nprint(config.app.name)       # \"myapp\"\nprint(config.database.port)  # 5432 (integer, coerced from string)\nprint(config.app.debug)      # False (from default)\nprint(config.database.ssl)   # True (from default)\n</code></pre>"},{"location":"specs/features/FEAT-004-schema-validation/#validation-errors","title":"Validation Errors","text":"<pre><code>from holoconf import Config\nfrom holoconf.errors import ValidationError\n\ntry:\n    config = Config.load(\"config.yaml\", schema=\"schema.yaml\")\n    await config.resolve_all()\n    config.validate()\nexcept ValidationError as e:\n    print(f\"Validation failed at {e.path}: {e.message}\")\n    print(f\"Help: {e.help}\")\n</code></pre>"},{"location":"specs/features/FEAT-004-schema-validation/#custom-error-handling","title":"Custom Error Handling","text":"<pre><code># Collect all validation errors instead of failing on first\nerrors = config.validate(collect_errors=True)\n\nfor error in errors:\n    print(f\"{error.path}: {error.message}\")\n</code></pre>"},{"location":"specs/features/FEAT-004-schema-validation/#implementation-notes","title":"Implementation Notes","text":""},{"location":"specs/features/FEAT-004-schema-validation/#json-schema-library","title":"JSON Schema Library","text":"<p>Use a Rust JSON Schema library (e.g., <code>jsonschema-rs</code>) that supports Draft 2020-12.</p>"},{"location":"specs/features/FEAT-004-schema-validation/#two-phase-implementation","title":"Two-Phase Implementation","text":"<ol> <li>Phase 1 (structural): Run JSON Schema validation, but treat <code>${...}</code> strings as wildcards that match any type</li> <li>Phase 2 (type/value): After resolution, validate individual values against their schema constraints</li> </ol>"},{"location":"specs/features/FEAT-004-schema-validation/#default-application","title":"Default Application","text":"<ul> <li>Track which values have schema defaults</li> <li>Apply defaults lazily (on access) or eagerly (on <code>resolve_all()</code>)</li> <li>Defaults don't override explicit values</li> </ul>"},{"location":"specs/features/FEAT-004-schema-validation/#ref-resolution","title":"$ref Resolution","text":"<ul> <li>Parse schema files with a custom loader that handles <code>$ref</code></li> <li>Resolve relative paths from schema file location</li> <li>Cache resolved schemas</li> </ul>"},{"location":"specs/features/FEAT-005-serialization/","title":"FEAT-005: Serialization and Export","text":""},{"location":"specs/features/FEAT-005-serialization/#overview","title":"Overview","text":"<p>Export configuration to YAML, JSON, or dict formats for debugging, auditing, and integration with other tools. Includes resolver-aware redaction to prevent secrets from being exposed.</p>"},{"location":"specs/features/FEAT-005-serialization/#user-stories","title":"User Stories","text":"<ul> <li>As a developer, I want to see the fully resolved config for debugging</li> <li>As an operator, I want to audit what config was used for a deployment</li> <li>As a developer, I want to export config without exposing secrets</li> <li>As a developer, I want to see the raw config with placeholders for documentation</li> </ul>"},{"location":"specs/features/FEAT-005-serialization/#dependencies","title":"Dependencies","text":"<ul> <li>ADR-009: Serialization and Export</li> <li>FEAT-001: Configuration File Loading</li> <li>FEAT-002: Core Resolvers</li> </ul>"},{"location":"specs/features/FEAT-005-serialization/#api-surface","title":"API Surface","text":""},{"location":"specs/features/FEAT-005-serialization/#python","title":"Python","text":"<pre><code>from holoconf import Config\n\nconfig = Config.load(\"config.yaml\")\n\n# Export as YAML (default: unresolved, shows ${...} placeholders)\nyaml_str = config.to_yaml()\n\n# Export resolved values with automatic secret redaction\nyaml_str = config.to_yaml(resolve=True, redact=True)\n\n# Export resolved values WITHOUT redaction (use with caution!)\nyaml_str = config.to_yaml(resolve=True, redact=False)\n\n# Export as JSON\njson_str = config.to_json()\njson_str = config.to_json(resolve=True, redact=True)\n\n# Export as dict (for programmatic use)\ndata = config.to_dict()\ndata = config.to_dict(resolve=True, redact=True)\n</code></pre>"},{"location":"specs/features/FEAT-005-serialization/#javascript","title":"JavaScript","text":"<pre><code>const config = await Config.load(\"config.yaml\");\n\n// Export as YAML\nconst yaml = config.toYaml();\nconst yaml = config.toYaml({ resolve: true, redact: true });\n\n// Export as JSON\nconst json = config.toJson();\nconst json = config.toJson({ resolve: true, redact: true });\n\n// Export as object\nconst obj = config.toObject();\nconst obj = config.toObject({ resolve: true, redact: true });\n</code></pre>"},{"location":"specs/features/FEAT-005-serialization/#behavior","title":"Behavior","text":""},{"location":"specs/features/FEAT-005-serialization/#export-modes","title":"Export Modes","text":"Mode <code>resolve</code> <code>redact</code> Output Default (safe) <code>false</code> N/A Shows <code>${env:VAR}</code> placeholders Debug (resolved) <code>true</code> <code>true</code> Resolved values, secrets redacted Full export <code>true</code> <code>false</code> Everything including secrets"},{"location":"specs/features/FEAT-005-serialization/#unresolved-export-default","title":"Unresolved Export (Default)","text":"<p>Shows the configuration as-is with interpolation placeholders:</p> <pre><code># Input config\ndatabase:\n  host: ${env:DB_HOST}\n  password: ${ssm:/prod/db/password}\n  port: 5432\n</code></pre> <pre><code>config.to_yaml()\n</code></pre> <pre><code># Output\ndatabase:\n  host: ${env:DB_HOST}\n  password: ${ssm:/prod/db/password}\n  port: 5432\n</code></pre>"},{"location":"specs/features/FEAT-005-serialization/#resolved-export-with-redaction","title":"Resolved Export with Redaction","text":"<p>Resolves values and redacts sensitive ones:</p> <pre><code>config.to_yaml(resolve=True, redact=True)\n</code></pre> <pre><code># Output\ndatabase:\n  host: db.prod.example.com       # Resolved from env\n  password: \"[REDACTED]\"          # SSM SecureString - redacted\n  port: 5432\n</code></pre>"},{"location":"specs/features/FEAT-005-serialization/#resolver-aware-redaction-from-adr-009","title":"Resolver-Aware Redaction (from ADR-009)","text":"<p>Redaction is determined by the resolver, not just the resolver name:</p> Resolver Redaction Rule <code>env</code> Not redacted (by default) <code>ssm</code> SecureString \u2192 redacted, String \u2192 not redacted <code>vault</code> Always redacted <code>secretsmanager</code> Always redacted <code>file</code> Not redacted Self-reference Inherits from source value <pre><code># config.yaml\ndatabase:\n  host: ${ssm:/prod/db/host}          # SSM String \u2192 not redacted\n  password: ${ssm:/prod/db/password}  # SSM SecureString \u2192 redacted\n  api_key: ${vault:secret/api/key}    # Vault \u2192 redacted\n  port: ${env:DB_PORT}                # Env \u2192 not redacted\n</code></pre> <pre><code># Output with resolve=True, redact=True\ndatabase:\n  host: \"db.prod.example.com\"\n  password: \"[REDACTED]\"\n  api_key: \"[REDACTED]\"\n  port: \"5432\"\n</code></pre>"},{"location":"specs/features/FEAT-005-serialization/#redaction-format","title":"Redaction Format","text":"<p>Redacted values are replaced with the string <code>\"[REDACTED]\"</code>:</p> <pre><code>REDACTED_VALUE = \"[REDACTED]\"\n</code></pre>"},{"location":"specs/features/FEAT-005-serialization/#full-export-no-redaction","title":"Full Export (No Redaction)","text":"<p>For cases where you need the actual values (use with extreme caution):</p> <pre><code># WARNING: This exposes secrets!\nconfig.to_yaml(resolve=True, redact=False)\n</code></pre> <pre><code>database:\n  host: \"db.prod.example.com\"\n  password: \"actual-secret-password\"  # Exposed!\n  api_key: \"sk-1234567890\"            # Exposed!\n  port: \"5432\"\n</code></pre>"},{"location":"specs/features/FEAT-005-serialization/#dictobject-export","title":"Dict/Object Export","text":"<p>For programmatic use, export to native dict/object:</p> <pre><code>data = config.to_dict(resolve=True, redact=True)\n\n# Returns:\n{\n    \"database\": {\n        \"host\": \"db.prod.example.com\",\n        \"password\": \"[REDACTED]\",\n        \"port\": 5432\n    }\n}\n</code></pre>"},{"location":"specs/features/FEAT-005-serialization/#type-preservation","title":"Type Preservation","text":"<p>Resolved values maintain their types:</p> <pre><code>config.to_dict(resolve=True)\n# {\n#     \"port\": 5432,          # integer (if coerced via schema)\n#     \"debug\": True,         # boolean\n#     \"timeout\": 30.5,       # float\n#     \"name\": \"myapp\"        # string\n# }\n</code></pre>"},{"location":"specs/features/FEAT-005-serialization/#error-cases","title":"Error Cases","text":""},{"location":"specs/features/FEAT-005-serialization/#resolution-error-during-export","title":"Resolution Error During Export","text":"<p>If resolution fails during export, the error is raised:</p> <pre><code>try:\n    yaml_str = config.to_yaml(resolve=True)\nexcept ResolverError as e:\n    print(f\"Failed to resolve {e.path}: {e.message}\")\n</code></pre>"},{"location":"specs/features/FEAT-005-serialization/#circular-reference","title":"Circular Reference","text":"<pre><code>CircularReferenceError: Circular reference detected during export\n  Path: a\n  Chain: a \u2192 b \u2192 c \u2192 a\n</code></pre>"},{"location":"specs/features/FEAT-005-serialization/#examples","title":"Examples","text":""},{"location":"specs/features/FEAT-005-serialization/#debugging-configuration","title":"Debugging Configuration","text":"<pre><code>config = Config.load(\"config.yaml\")\n\n# See what the config looks like before resolution\nprint(\"=== Raw Config ===\")\nprint(config.to_yaml())\n\n# See resolved values (safe for logs)\nawait config.resolve_all()\nprint(\"=== Resolved Config (redacted) ===\")\nprint(config.to_yaml(resolve=True, redact=True))\n</code></pre>"},{"location":"specs/features/FEAT-005-serialization/#audit-logging","title":"Audit Logging","text":"<pre><code>import logging\n\nlogger = logging.getLogger(__name__)\n\nconfig = Config.load(\"config.yaml\", \"production.yaml\")\n\n# Log the config used for deployment (safe, no secrets)\nlogger.info(\n    \"Deployment configuration\",\n    extra={\"config\": config.to_dict(resolve=True, redact=True)}\n)\n</code></pre>"},{"location":"specs/features/FEAT-005-serialization/#configuration-diff","title":"Configuration Diff","text":"<pre><code># Compare configs across environments\ndev_config = Config.load(\"base.yaml\", \"development.yaml\")\nprod_config = Config.load(\"base.yaml\", \"production.yaml\")\n\ndev_dict = dev_config.to_dict()\nprod_dict = prod_config.to_dict()\n\n# Use your preferred diff tool\nfrom deepdiff import DeepDiff\ndiff = DeepDiff(dev_dict, prod_dict)\nprint(diff)\n</code></pre>"},{"location":"specs/features/FEAT-005-serialization/#export-for-other-tools","title":"Export for Other Tools","text":"<pre><code># Generate config for another tool that needs JSON\nconfig = Config.load(\"holoconf.yaml\")\n\nwith open(\"output.json\", \"w\") as f:\n    f.write(config.to_json(resolve=True, redact=False))\n</code></pre>"},{"location":"specs/features/FEAT-005-serialization/#template-generation","title":"Template Generation","text":"<pre><code># Export unresolved config as documentation template\nconfig = Config.load(\"config.yaml\")\n\nwith open(\"config.template.yaml\", \"w\") as f:\n    f.write(\"# Configuration Template\\n\")\n    f.write(\"# Replace ${...} placeholders with your values\\n\\n\")\n    f.write(config.to_yaml())\n</code></pre>"},{"location":"specs/features/FEAT-005-serialization/#implementation-notes","title":"Implementation Notes","text":""},{"location":"specs/features/FEAT-005-serialization/#serialization-libraries","title":"Serialization Libraries","text":"<ul> <li>YAML: Use <code>serde_yaml</code> in Rust</li> <li>JSON: Use <code>serde_json</code> in Rust</li> <li>Both support pretty-printing options</li> </ul>"},{"location":"specs/features/FEAT-005-serialization/#redaction-implementation","title":"Redaction Implementation","text":"<ol> <li>During serialization, check each value's metadata</li> <li>If <code>sensitive=True</code> and <code>redact=True</code>, replace with <code>\"[REDACTED]\"</code></li> <li>Sensitivity is tracked per-value from resolver results</li> </ol>"},{"location":"specs/features/FEAT-005-serialization/#resolution-during-export","title":"Resolution During Export","text":"<p>When <code>resolve=True</code>: 1. Walk the config tree 2. For each interpolation, resolve it (may be cached) 3. Check sensitivity metadata 4. Apply redaction if needed 5. Serialize the result</p>"},{"location":"specs/features/FEAT-005-serialization/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Unresolved export is fast (just serialize stored values)</li> <li>Resolved export may trigger resolver calls (unless already cached)</li> <li>Consider <code>resolve_all()</code> before export if doing multiple exports</li> </ul>"},{"location":"specs/features/FEAT-006-cli/","title":"FEAT-006: Command Line Interface","text":""},{"location":"specs/features/FEAT-006-cli/#status","title":"Status","text":"<p>Draft</p>"},{"location":"specs/features/FEAT-006-cli/#changelog","title":"Changelog","text":"<ul> <li>2026-01-11: Removed standalone <code>holoconf sources</code> command; use <code>holoconf dump --sources</code> instead</li> </ul>"},{"location":"specs/features/FEAT-006-cli/#overview","title":"Overview","text":"<p>Provide a <code>holoconf</code> CLI for validating configs, resolving values, debugging, and generating documentation outside of application code.</p>"},{"location":"specs/features/FEAT-006-cli/#user-stories","title":"User Stories","text":"<ul> <li>As a developer, I want to validate my config files in CI before deployment</li> <li>As an operator, I want to see the resolved config for debugging</li> <li>As a developer, I want to check my schema is valid</li> <li>As a developer, I want to see where config values come from when debugging merge issues</li> </ul>"},{"location":"specs/features/FEAT-006-cli/#dependencies","title":"Dependencies","text":"<ul> <li>FEAT-001: Configuration File Loading</li> <li>FEAT-002: Core Resolvers</li> <li>FEAT-003: Configuration Merging</li> <li>FEAT-004: Schema Validation</li> <li>FEAT-005: Serialization and Export</li> </ul>"},{"location":"specs/features/FEAT-006-cli/#installation","title":"Installation","text":"<pre><code># Install via pip (Python)\npip install holoconf\n\n# Install via npm (Node.js)\nnpm install -g holoconf\n\n# Install via cargo (Rust)\ncargo install holoconf-cli\n</code></pre>"},{"location":"specs/features/FEAT-006-cli/#commands","title":"Commands","text":""},{"location":"specs/features/FEAT-006-cli/#holoconf-validate","title":"<code>holoconf validate</code>","text":"<p>Validate configuration files against a schema.</p> <pre><code># Validate a single file\nholoconf validate config.yaml --schema schema.yaml\n\n# Validate merged configs\nholoconf validate base.yaml production.yaml --schema schema.yaml\n\n# Validate with resolution (checks resolved values against schema)\nholoconf validate config.yaml --schema schema.yaml --resolve\n\n# Output format\nholoconf validate config.yaml --schema schema.yaml --format json\n</code></pre> <p>Options:</p> Option Description <code>--schema, -s</code> Path to schema file <code>--resolve, -r</code> Resolve interpolations before validating <code>--format, -f</code> Output format: <code>text</code> (default), <code>json</code> <code>--quiet, -q</code> Only output errors <p>Exit Codes:</p> Code Meaning 0 Valid 1 Validation errors 2 File not found or parse error <p>Output: <pre><code>$ holoconf validate config.yaml --schema schema.yaml\n\u2713 config.yaml is valid\n\n$ holoconf validate config.yaml --schema schema.yaml\n\u2717 Validation failed\n\n  database.port: Value out of range\n    Expected: integer between 1 and 65535\n    Got: 70000\n    Location: config.yaml:5\n\n  api.timeout: Missing required key\n    Location: config.yaml\n    Help: Add 'timeout' to the api section\n</code></pre></p>"},{"location":"specs/features/FEAT-006-cli/#holoconf-dump","title":"<code>holoconf dump</code>","text":"<p>Export configuration in various formats.</p> <pre><code># Dump raw config (with placeholders)\nholoconf dump config.yaml\n\n# Dump resolved config (with redaction)\nholoconf dump config.yaml --resolve\n\n# Dump resolved without redaction (careful!)\nholoconf dump config.yaml --resolve --no-redact\n\n# Output as JSON\nholoconf dump config.yaml --format json\n\n# Dump merged configs\nholoconf dump base.yaml production.yaml --resolve\n</code></pre> <p>Options:</p> Option Description <code>--resolve, -r</code> Resolve interpolations <code>--no-redact</code> Don't redact sensitive values (requires <code>--resolve</code>) <code>--format, -f</code> Output format: <code>yaml</code> (default), <code>json</code> <code>--output, -o</code> Write to file instead of stdout <code>--sources</code> Show source file for each value instead of values <p>Output: <pre><code>$ holoconf dump config.yaml --resolve\ndatabase:\n  host: db.prod.example.com\n  password: \"[REDACTED]\"\n  port: 5432\n\napi:\n  endpoint: https://api.example.com\n  timeout: 30\n\n$ holoconf dump base.yaml production.yaml --sources\ndatabase.host         base.yaml\ndatabase.port         base.yaml\ndatabase.pool.min     base.yaml\ndatabase.pool.max     production.yaml (overrides base.yaml)\napi.endpoint          production.yaml\napi.timeout           production.yaml\n\n$ holoconf dump base.yaml production.yaml --sources --format json\n{\n  \"database.host\": {\"source\": \"base.yaml\"},\n  \"database.port\": {\"source\": \"base.yaml\"},\n  \"database.pool.max\": {\"source\": \"production.yaml\", \"overrides\": \"base.yaml\"}\n}\n</code></pre></p>"},{"location":"specs/features/FEAT-006-cli/#holoconf-get","title":"<code>holoconf get</code>","text":"<p>Get a specific value from the configuration.</p> <pre><code># Get a single value\nholoconf get config.yaml database.host\n# Output: localhost\n\n# Get with resolution\nholoconf get config.yaml database.host --resolve\n# Output: db.prod.example.com\n\n# Get nested value\nholoconf get config.yaml database.pool.max\n# Output: 20\n\n# Get as JSON (for complex values)\nholoconf get config.yaml database --format json\n# Output: {\"host\": \"localhost\", \"port\": 5432, \"pool\": {\"min\": 5, \"max\": 20}}\n</code></pre> <p>Options:</p> Option Description <code>--resolve, -r</code> Resolve interpolations <code>--format, -f</code> Output format: <code>text</code> (default), <code>json</code>, <code>yaml</code> <code>--default, -d</code> Default value if key not found"},{"location":"specs/features/FEAT-006-cli/#holoconf-schema","title":"<code>holoconf schema</code>","text":"<p>Schema-related utilities.</p> <pre><code># Validate a schema file\nholoconf schema validate schema.yaml\n\n# Generate a template config from schema\nholoconf schema template schema.yaml &gt; config.template.yaml\n\n# Show schema documentation\nholoconf schema docs schema.yaml\n</code></pre> <p>Subcommands:</p>"},{"location":"specs/features/FEAT-006-cli/#holoconf-schema-validate","title":"<code>holoconf schema validate</code>","text":"<p>Check that a schema is valid JSON Schema.</p> <pre><code>holoconf schema validate schema.yaml\n</code></pre>"},{"location":"specs/features/FEAT-006-cli/#holoconf-schema-template","title":"<code>holoconf schema template</code>","text":"<p>Generate a config template with placeholders from schema:</p> <pre><code>holoconf schema template schema.yaml\n</code></pre> <p>Output: <pre><code># Generated from schema.yaml\n# Required fields marked with # REQUIRED\n\ndatabase:  # REQUIRED\n  host: \"\"  # REQUIRED - Database hostname\n  port: 5432  # Default: 5432\n  pool:\n    min: 5  # Default: 5\n    max: 20  # Default: 20\n\napi:\n  timeout: 30  # Default: 30\n  retries: 3  # Default: 3\n</code></pre></p>"},{"location":"specs/features/FEAT-006-cli/#holoconf-schema-docs","title":"<code>holoconf schema docs</code>","text":"<p>Generate human-readable documentation from schema:</p> <pre><code>holoconf schema docs schema.yaml --format markdown\n</code></pre> <p>Output: <pre><code># Configuration Reference\n\n## database (required)\n\nDatabase connection settings.\n\n| Key | Type | Required | Default | Description |\n|-----|------|----------|---------|-------------|\n| host | string | Yes | - | Database hostname |\n| port | integer | No | 5432 | Port number (1-65535) |\n| pool.min | integer | No | 5 | Minimum pool size |\n| pool.max | integer | No | 20 | Maximum pool size |\n\n## api\n\nAPI settings.\n\n| Key | Type | Required | Default | Description |\n|-----|------|----------|---------|-------------|\n| timeout | number | No | 30 | Request timeout in seconds |\n| retries | integer | No | 3 | Number of retries (0-10) |\n</code></pre></p>"},{"location":"specs/features/FEAT-006-cli/#holoconf-check","title":"<code>holoconf check</code>","text":"<p>Quick syntax check without full validation.</p> <pre><code># Check YAML/JSON syntax\nholoconf check config.yaml\n\n# Check multiple files\nholoconf check config/*.yaml\n</code></pre> <p>Output: <pre><code>$ holoconf check config.yaml\n\u2713 config.yaml: valid YAML\n\n$ holoconf check broken.yaml\n\u2717 broken.yaml: invalid YAML\n  Line 15: Unexpected indentation\n</code></pre></p>"},{"location":"specs/features/FEAT-006-cli/#environment-variables","title":"Environment Variables","text":"Variable Description <code>HOLOCONF_ALLOW_REMOTE</code> Enable remote URL resolution (<code>true</code>/<code>false</code>) <code>HOLOCONF_FILE_ROOTS</code> Colon-separated list of allowed file paths <code>HOLOCONF_NO_COLOR</code> Disable colored output <code>HOLOCONF_DEBUG</code> Enable debug logging"},{"location":"specs/features/FEAT-006-cli/#examples","title":"Examples","text":""},{"location":"specs/features/FEAT-006-cli/#cicd-validation","title":"CI/CD Validation","text":"<pre><code># .github/workflows/validate.yml\njobs:\n  validate:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - run: pip install holoconf\n      - run: holoconf validate config/*.yaml --schema schema.yaml\n</code></pre>"},{"location":"specs/features/FEAT-006-cli/#pre-commit-hook","title":"Pre-commit Hook","text":"<pre><code># .pre-commit-config.yaml\nrepos:\n  - repo: local\n    hooks:\n      - id: holoconf-validate\n        name: Validate holoconf configs\n        entry: holoconf validate --schema schema.yaml\n        language: system\n        files: ^config/.*\\.yaml$\n</code></pre>"},{"location":"specs/features/FEAT-006-cli/#debugging-merge-issues","title":"Debugging Merge Issues","text":"<pre><code># See which file each value comes from\nholoconf dump base.yaml env/production.yaml local.yaml --sources\n\n# See the final merged result\nholoconf dump base.yaml env/production.yaml local.yaml\n\n# Get a specific value to check\nholoconf get base.yaml env/production.yaml database.pool.max\n</code></pre>"},{"location":"specs/features/FEAT-006-cli/#generating-documentation","title":"Generating Documentation","text":"<pre><code># Generate markdown docs from schema\nholoconf schema docs schema.yaml --format markdown &gt; docs/CONFIG.md\n\n# Generate a template for new configs\nholoconf schema template schema.yaml &gt; config.template.yaml\n</code></pre>"},{"location":"specs/features/FEAT-006-cli/#implementation-notes","title":"Implementation Notes","text":""},{"location":"specs/features/FEAT-006-cli/#cli-framework","title":"CLI Framework","text":"<ul> <li>Rust: Use <code>clap</code> for argument parsing</li> <li>Provide as standalone binary (<code>holoconf</code>) and language-specific wrappers</li> </ul>"},{"location":"specs/features/FEAT-006-cli/#output-formatting","title":"Output Formatting","text":"<ul> <li>Support <code>--format</code> for machine-readable output (JSON)</li> <li>Use colors for human-readable output (disable with <code>--no-color</code> or <code>NO_COLOR</code> env)</li> <li>Structured exit codes for scripting</li> </ul>"},{"location":"specs/features/FEAT-006-cli/#error-output","title":"Error Output","text":"<ul> <li>Errors go to stderr</li> <li>Include file paths and line numbers where possible</li> <li>Provide actionable help text</li> </ul>"},{"location":"specs/features/FEAT-007-aws-resolvers/","title":"FEAT-007: AWS Resolvers","text":""},{"location":"specs/features/FEAT-007-aws-resolvers/#status","title":"Status","text":"<p>Draft</p>"},{"location":"specs/features/FEAT-007-aws-resolvers/#changelog","title":"Changelog","text":"<ul> <li>2026-01-11: Initial draft</li> </ul>"},{"location":"specs/features/FEAT-007-aws-resolvers/#overview","title":"Overview","text":"<p>Provide AWS-specific resolvers for fetching configuration values from AWS services: SSM Parameter Store, CloudFormation outputs, and S3 objects. These resolvers are distributed as a separate package (<code>holoconf-aws</code>) to keep the core library lean.</p>"},{"location":"specs/features/FEAT-007-aws-resolvers/#user-stories","title":"User Stories","text":"<ul> <li>As a developer, I want to read secrets from SSM Parameter Store so I can manage sensitive config securely</li> <li>As a developer, I want to reference CloudFormation stack outputs so my config stays in sync with infrastructure</li> <li>As a developer, I want to include shared config files from S3 so teams can share configuration</li> <li>As a developer, I want to mock AWS calls in tests using moto so I can test locally</li> </ul>"},{"location":"specs/features/FEAT-007-aws-resolvers/#dependencies","title":"Dependencies","text":"<ul> <li>ADR-002: Resolver Architecture</li> <li>FEAT-001: Configuration File Loading</li> <li>FEAT-002: Core Resolvers</li> </ul>"},{"location":"specs/features/FEAT-007-aws-resolvers/#package-structure","title":"Package Structure","text":"<p>AWS resolvers are provided as a separate package to avoid bundling AWS SDK dependencies in the core library:</p> <pre><code>crates/\n  holoconf-aws/           # Rust crate\n    Cargo.toml\n    src/\n      lib.rs              # Re-exports, resolver registration\n      ssm.rs              # SSM Parameter Store resolver\n      cfn.rs              # CloudFormation outputs resolver\n      s3.rs               # S3 resolver\n      client.rs           # AWS SDK client management\n      cache.rs            # TTL-based value caching\n\npackages/\n  python/\n    holoconf-aws/         # Python package (separate wheel)\n      pyproject.toml\n      src/holoconf_aws/\n        __init__.py\n        _holoconf_aws.pyi\n</code></pre>"},{"location":"specs/features/FEAT-007-aws-resolvers/#installation","title":"Installation","text":"<pre><code># Python\npip install holoconf holoconf-aws\n\n# Rust\ncargo add holoconf-core holoconf-aws\n</code></pre>"},{"location":"specs/features/FEAT-007-aws-resolvers/#registration","title":"Registration","text":""},{"location":"specs/features/FEAT-007-aws-resolvers/#python-auto-discovery","title":"Python (Auto-Discovery)","text":"<p>AWS resolvers are automatically discovered and registered when holoconf is imported. No explicit import or registration is needed:</p> <pre><code>import holoconf  # Auto-discovers holoconf-aws if installed\n\n# SSM resolver is already available\nconfig = holoconf.Config.loads(\"password: ${ssm:/app/secret}\")\n</code></pre> <p>For manual registration (e.g., in tests):</p> <pre><code>from holoconf_aws import register_ssm\n\nregister_ssm()  # Register SSM resolver\nregister_ssm(force=True)  # Force re-registration\n</code></pre>"},{"location":"specs/features/FEAT-007-aws-resolvers/#rust","title":"Rust","text":"<p>Rust requires explicit registration:</p> <pre><code>use holoconf_core::Config;\nuse holoconf_aws;\n\n// Register AWS resolvers\nholoconf_aws::register_all();\n\nlet config = Config::from_yaml_file(\"config.yaml\")?;\n</code></pre>"},{"location":"specs/features/FEAT-007-aws-resolvers/#resolvers","title":"Resolvers","text":""},{"location":"specs/features/FEAT-007-aws-resolvers/#1-ssm-parameter-store-ssm","title":"1. SSM Parameter Store (<code>ssm</code>)","text":"<p>Fetches values from AWS Systems Manager Parameter Store.</p> <p>Arguments:</p> Position Name Required Description 1 path Yes SSM parameter path (must start with <code>/</code>) <p>Keyword Arguments:</p> Name Type Default Description <code>default</code> any none Default value if parameter not found <code>sensitive</code> bool auto Override sensitivity detection <code>region</code> string SDK default AWS region for this lookup <code>profile</code> string SDK default AWS profile for credentials <p>Examples: <pre><code># Basic usage\ndatabase:\n  host: ${ssm:/myapp/prod/db-host}\n  password: ${ssm:/myapp/prod/db-password}\n\n# With default value\ntimeout: ${ssm:/myapp/prod/timeout,default=30}\n\n# Explicit sensitivity\napi_key: ${ssm:/myapp/prod/api-key,sensitive=true}\n\n# Cross-region lookup\nother_region: ${ssm:/myapp/config,region=us-west-2}\n\n# Cross-account (via profile)\nother_account: ${ssm:/shared/config,profile=shared-account}\n\n# Access Secrets Manager via SSM\nsecret: ${ssm:/aws/reference/secretsmanager/myapp/db-creds}\n</code></pre></p> <p>Behavior: - Fetches parameter with automatic decryption (<code>WithDecryption=true</code>) - Parameter type is detected automatically and handled appropriately (see table below) - Parameters not found raise <code>ResolverError</code> (unless default provided) - Supports Secrets Manager access via <code>/aws/reference/secretsmanager/</code> prefix</p> <p>Parameter Type Handling:</p> SSM Type Return Type Default Sensitive Notes String string No Plain text parameter SecureString string Yes Encrypted parameter, auto-decrypted StringList array of strings No Comma-separated list, automatically split <p>All types support the <code>sensitive</code> keyword argument to override the default:</p> <pre><code># String - mark as sensitive\ninternal_config: ${ssm:/app/internal-config,sensitive=true}\n\n# SecureString - sensitive by default, can override (rare)\nnon_secret_encrypted: ${ssm:/app/some-param,sensitive=false}\n\n# StringList - mark as sensitive\ninternal_ips: ${ssm:/app/internal-ips,sensitive=true}\n</code></pre> <p>StringList Example:</p> <pre><code># SSM parameter /app/allowed-origins contains: \"https://example.com,https://app.example.com,https://admin.example.com\"\n# Type: StringList\n\n# Automatically returns as array\nallowed_origins: ${ssm:/app/allowed-origins}\n# Result: [\"https://example.com\", \"https://app.example.com\", \"https://admin.example.com\"]\n\n# Access individual elements\nprimary_origin: ${ssm:/app/allowed-origins}[0]\n# Result: \"https://example.com\"\n</code></pre> <p>Secrets Manager Access:</p> <p>SSM provides transparent access to Secrets Manager secrets via a special path prefix. This is the recommended way to access secrets:</p> <pre><code># Instead of a separate secretsmanager resolver:\ndb_password: ${ssm:/aws/reference/secretsmanager/myapp/db-password}\n\n# The path after the prefix is the Secrets Manager secret name\napi_key: ${ssm:/aws/reference/secretsmanager/prod/api-keys/stripe}\n</code></pre>"},{"location":"specs/features/FEAT-007-aws-resolvers/#2-cloudformation-outputs-cfn","title":"2. CloudFormation Outputs (<code>cfn</code>)","text":"<p>Fetches outputs from CloudFormation stacks.</p> <p>Arguments:</p> Position Name Required Description 1 stack/output Yes Stack name and output key separated by <code>/</code> <p>Keyword Arguments:</p> Name Type Default Description <code>default</code> any none Default value if output not found <code>region</code> string SDK default AWS region for this lookup <code>profile</code> string SDK default AWS profile for credentials <code>sensitive</code> bool <code>false</code> Mark value as sensitive <p>Examples: <pre><code>database:\n  # Basic usage: stack-name/OutputKey\n  endpoint: ${cfn:my-database-stack/DatabaseEndpoint}\n  port: ${cfn:my-database-stack/DatabasePort}\n\n# With default value\nbucket: ${cfn:my-stack/BucketName,default=my-default-bucket}\n\n# Cross-region lookup\nwest_bucket: ${cfn:my-stack/BucketName,region=us-west-2}\n\n# Cross-account (via profile)\nshared_vpc: ${cfn:shared-infra/VpcId,profile=network-account}\n</code></pre></p> <p>Behavior: - Fetches stack outputs via <code>DescribeStacks</code> API - If output not found and no default provided, raises <code>ResolverError</code> - If output not found and default is provided, returns default - Stack not found or not in <code>*_COMPLETE</code> state raises <code>ResolverError</code> - Not sensitive by default (stack outputs are typically public)</p>"},{"location":"specs/features/FEAT-007-aws-resolvers/#3-s3-s3","title":"3. S3 (<code>s3</code>)","text":"<p>Fetches objects from Amazon S3.</p> <p>Arguments:</p> Position Name Required Description 1 bucket/key Yes S3 bucket and object key separated by <code>/</code> (first <code>/</code> separates bucket from key) <p>Keyword Arguments:</p> Name Type Default Description <code>default</code> any none Default value if object not found <code>parse</code> string <code>auto</code> How to interpret content: <code>auto</code>, <code>yaml</code>, <code>json</code>, <code>text</code>, <code>binary</code> <code>encoding</code> string <code>utf-8</code> Text encoding: <code>utf-8</code>, <code>ascii</code>, <code>latin-1</code> (ignored for <code>binary</code>) <code>region</code> string SDK default AWS region for this lookup <code>profile</code> string SDK default AWS profile for credentials <code>sensitive</code> bool <code>false</code> Mark value as sensitive <p>Parse Modes:</p> Mode Return Type Description <code>auto</code> varies Detect by object key extension or <code>Content-Type</code> header <code>yaml</code> structured data Parse as YAML, accessible via dot notation <code>json</code> structured data Parse as JSON, accessible via dot notation <code>text</code> string Return raw text content <code>binary</code> bytes Return raw bytes (<code>bytes</code> in Python, <code>Vec&lt;u8&gt;</code> in Rust) <p>Behavior: - Fetches object content via <code>GetObject</code> API - If object not found and no default provided, raises <code>ResolverError</code> - If object not found and default is provided, returns default - When <code>parse=auto</code>, format is detected by key extension (<code>.yaml</code>, <code>.yml</code>, <code>.json</code> \u2192 parsed; else \u2192 text) - Parsed content (YAML/JSON) returns a Config object for nested access - Text content returns a string - Binary content returns raw bytes (useful for certificates, keys, images) - Not sensitive by default; use <code>sensitive=true</code> for secrets</p> <p>Examples: <pre><code># Auto-detect format by key extension\nshared_config: ${s3:my-bucket/configs/shared.yaml}\n\n# With default if object doesn't exist\noptional_config: ${s3:my-bucket/configs/optional.yaml,default={}}\n\n# Explicit parsing mode\nfeature_flags: ${s3:config-bucket/flags.json,parse=json}\n\n# Raw text content\nreadme: ${s3:my-bucket/docs/README.md,parse=text}\n\n# Binary file (certificates, keys, images)\ncertificate: ${s3:my-bucket/certs/ca.pem,parse=binary}\nclient_cert: ${s3:my-bucket/certs/client.p12,parse=binary,sensitive=true}\n\n# Cross-region lookup\nremote_config: ${s3:other-bucket/config.yaml,region=eu-west-1}\n\n# Cross-account (via profile)\nshared_config: ${s3:shared-bucket/common.yaml,profile=shared-account}\n\n# Different encoding for legacy files\nlegacy_data: ${s3:my-bucket/legacy/data.txt,encoding=latin-1}\n\n# Mark as sensitive\nsecret_config: ${s3:my-bucket/secrets/config.yaml,sensitive=true}\n</code></pre></p>"},{"location":"specs/features/FEAT-007-aws-resolvers/#credential-resolution","title":"Credential Resolution","text":"<p>All AWS resolvers use the standard AWS SDK credential provider chain:</p> <ol> <li>Environment variables (<code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code>, <code>AWS_SESSION_TOKEN</code>)</li> <li>Shared credentials file (<code>~/.aws/credentials</code>)</li> <li>Shared config file (<code>~/.aws/config</code>) with profile support</li> <li>Web Identity Token (for EKS workloads)</li> <li>ECS Container credentials (for ECS tasks)</li> <li>EC2 Instance Metadata (IMDS v2 for EC2 instances)</li> </ol> <p>The <code>region</code> keyword argument overrides the region for that specific lookup. The <code>profile</code> keyword argument selects a named profile from the shared config files.</p>"},{"location":"specs/features/FEAT-007-aws-resolvers/#client-caching","title":"Client Caching","text":"<p>AWS SDK clients are immutable after creation. To avoid creating redundant clients, holoconf-aws caches clients by <code>(region, profile)</code> tuple:</p> <pre><code>Resolution: ${ssm:/path,region=us-west-2,profile=prod}\n    \u2193\nCache lookup: (Some(\"us-west-2\"), Some(\"prod\"))\n    \u2193\nCache miss \u2192 Create client \u2192 Cache it\n    \u2193\nSubsequent calls with same region/profile reuse cached client\n</code></pre> <p>The default client (no region/profile overrides) uses key <code>(None, None)</code> and resolves credentials via the SDK's default chain.</p>"},{"location":"specs/features/FEAT-007-aws-resolvers/#configuration-api","title":"Configuration API","text":"<p>Note: The <code>configure()</code> and <code>reset()</code> APIs described below are planned for future releases. Currently, AWS configuration is handled via standard AWS SDK environment variables and config files.</p> <p>For testing and advanced use cases, the global AWS configuration can be overridden:</p> <pre><code>import holoconf_aws\n\n# Configure endpoint URL (for moto/LocalStack)\nholoconf_aws.configure(\n    endpoint_url=\"http://localhost:5000\",  # All services\n)\n\n# Or per-service endpoints\nholoconf_aws.configure(\n    ssm_endpoint=\"http://localhost:5000\",\n    s3_endpoint=\"http://localhost:5000\",\n    cfn_endpoint=\"http://localhost:5000\",\n)\n\n# Override default region/profile\nholoconf_aws.configure(\n    region=\"us-east-1\",\n    profile=\"testing\",\n)\n\n# Reset to defaults (clears client cache)\nholoconf_aws.reset()\n</code></pre>"},{"location":"specs/features/FEAT-007-aws-resolvers/#testing-with-mock-resolvers","title":"Testing with Mock Resolvers","text":"<p>The acceptance test framework supports mock resolvers for testing AWS resolver behavior without actual AWS credentials. Tests define mock responses in their YAML spec:</p> <pre><code>name: resolves_ssm_parameter\ngiven:\n  mocks:\n    ssm:\n      /app/db-host:\n        value: \"test-db.local\"\n        type: String\n      /app/db-password:\n        value: \"secret123\"\n        type: SecureString\n  config: |\n    database:\n      host: ${ssm:/app/db-host}\n      password: ${ssm:/app/db-password}\nwhen:\n  access: database.host\nthen:\n  value: \"test-db.local\"\n</code></pre> <p>For Python unit tests, you can register custom resolver functions:</p> <pre><code>import holoconf\n\ndef mock_ssm(path, **kwargs):\n    mock_data = {\n        \"/app/db-host\": \"test-db.local\",\n        \"/app/db-password\": holoconf.ResolvedValue(\"secret123\", sensitive=True),\n    }\n    if path in mock_data:\n        return mock_data[path]\n    raise KeyError(f\"Parameter not found: {path}\")\n\n# Override the SSM resolver with mock\nholoconf.register_resolver(\"ssm\", mock_ssm, force=True)\n\nconfig = holoconf.Config.loads(\"\"\"\ndatabase:\n  host: ${ssm:/app/db-host}\n  password: ${ssm:/app/db-password}\n\"\"\")\n\nassert config.get(\"database.host\") == \"test-db.local\"\n</code></pre>"},{"location":"specs/features/FEAT-007-aws-resolvers/#error-handling","title":"Error Handling","text":"<p>AWS resolver errors include context about the failed operation:</p> <pre><code>try:\n    value = config.get(\"database.password\")\nexcept ResolverError as e:\n    # e.resolver = \"ssm\"\n    # e.key = \"/app/db-password\"\n    # e.message = \"Parameter not found\"\n    # e.cause = &lt;underlying AWS SDK error&gt;\n</code></pre> <p>Common error scenarios:</p> Scenario Error Parameter/output/object not found <code>ResolverError</code> with \"not found\" message Invalid credentials <code>ResolverError</code> with \"access denied\" message Network error <code>ResolverError</code> with \"connection\" message Stack not ready <code>ResolverError</code> with \"stack not in COMPLETE state\""},{"location":"specs/features/FEAT-007-aws-resolvers/#implementation-notes","title":"Implementation Notes","text":""},{"location":"specs/features/FEAT-007-aws-resolvers/#rust-crate","title":"Rust Crate","text":"<pre><code>// holoconf-aws/src/lib.rs\nuse holoconf_core::resolver::Registry;\n\npub mod ssm;\npub mod cfn;\npub mod s3;\nmod client;\nmod cache;\n\n/// Register all AWS resolvers with the global registry\npub fn register() {\n    let registry = Registry::global();\n    registry.register(\"ssm\", ssm::SsmResolver::new());\n    registry.register(\"cfn\", cfn::CfnResolver::new());\n    registry.register(\"s3\", s3::S3Resolver::new());\n}\n</code></pre>"},{"location":"specs/features/FEAT-007-aws-resolvers/#dependencies_1","title":"Dependencies","text":"<pre><code># holoconf-aws/Cargo.toml\n[dependencies]\nholoconf-core = { path = \"../holoconf-core\" }\naws-config = { version = \"1\", features = [\"behavior-version-latest\"] }\naws-sdk-ssm = \"1\"\naws-sdk-cloudformation = \"1\"\naws-sdk-s3 = \"1\"\ntokio = { version = \"1\", features = [\"rt-multi-thread\"] }\n</code></pre>"},{"location":"specs/features/FEAT-007-aws-resolvers/#python-bindings","title":"Python Bindings","text":"<p>The Python package wraps the Rust crate via PyO3. The package structure:</p> <pre><code>packages/python/holoconf-aws/\n\u251c\u2500\u2500 pyproject.toml              # maturin build, entry points\n\u251c\u2500\u2500 src/holoconf_aws/\n\u2502   \u251c\u2500\u2500 __init__.py             # Re-exports from Rust bindings\n\u2502   \u2514\u2500\u2500 _holoconf_aws.pyi       # Type stubs\n</code></pre> <p>The entry point in <code>pyproject.toml</code> enables auto-discovery:</p> <pre><code>[project.entry-points.\"holoconf.resolvers\"]\nssm = \"holoconf_aws:register_ssm\"\n</code></pre> <p>When <code>holoconf</code> is imported, it automatically discovers and calls <code>register_ssm()</code> via this entry point.</p>"},{"location":"specs/features/template/","title":"Feature: [Name]","text":""},{"location":"specs/features/template/#status","title":"Status","text":"<ul> <li>Status: Draft | In Review | Approved | Implemented | Deprecated</li> <li>Author: [name]</li> <li>Created: [date]</li> <li>Last Updated: [date]</li> </ul>"},{"location":"specs/features/template/#problem-statement","title":"Problem Statement","text":"<p>[What problem does this feature solve?]</p>"},{"location":"specs/features/template/#user-stories","title":"User Stories","text":"<ul> <li>As a [role], I want [goal] so that [benefit]</li> <li>...</li> </ul>"},{"location":"specs/features/template/#requirements","title":"Requirements","text":""},{"location":"specs/features/template/#functional-requirements","title":"Functional Requirements","text":"<ul> <li>FR-1: ...</li> <li>FR-2: ...</li> </ul>"},{"location":"specs/features/template/#non-functional-requirements","title":"Non-Functional Requirements","text":"<ul> <li>NFR-1: ...</li> </ul>"},{"location":"specs/features/template/#api-contract","title":"API Contract","text":""},{"location":"specs/features/template/#input","title":"Input","text":"<p>[Schema, examples]</p>"},{"location":"specs/features/template/#output","title":"Output","text":"<p>[Schema, examples]</p>"},{"location":"specs/features/template/#errors","title":"Errors","text":"<p>[Error codes, conditions]</p>"},{"location":"specs/features/template/#validation-rules","title":"Validation Rules","text":"<ul> <li>VR-1: ...</li> </ul>"},{"location":"specs/features/template/#data-model","title":"Data Model","text":"<p>[Schemas, types, relationships]</p>"},{"location":"specs/features/template/#architecture-considerations","title":"Architecture Considerations","text":"<ul> <li>Applicable ADRs: ADR-001, ADR-002</li> <li>Applicable Constraints: C-1, C-2</li> </ul>"},{"location":"specs/features/template/#access-patterns","title":"Access Patterns","text":"<p>[How will this feature be accessed/used?]</p>"},{"location":"specs/features/template/#implementation-checklist","title":"Implementation Checklist","text":"<ul> <li>[ ] Task 1</li> <li>[ ] Task 2</li> </ul>"},{"location":"specs/features/template/#test-scenarios","title":"Test Scenarios","text":""},{"location":"specs/features/template/#happy-path","title":"Happy Path","text":"<ul> <li>[ ] Scenario 1</li> </ul>"},{"location":"specs/features/template/#edge-cases","title":"Edge Cases","text":"<ul> <li>[ ] Scenario 2</li> </ul>"},{"location":"specs/features/template/#error-cases","title":"Error Cases","text":"<ul> <li>[ ] Scenario 3</li> </ul>"},{"location":"specs/features/template/#open-questions","title":"Open Questions","text":"<ul> <li>[ ] Question 1</li> </ul>"}]}